<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试笔记（二）线程池连环炮</title>
      <link href="20200909.html"/>
      <url>20200909.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-实现多线程有几种方式？有什么区别？"><a href="#1-实现多线程有几种方式？有什么区别？" class="headerlink" title="1. 实现多线程有几种方式？有什么区别？"></a>1. 实现多线程有几种方式？有什么区别？</h2><p>实现多线程有3种方式。</p><h3 id="1-1-继承-Thread-类"><a href="#1-1-继承-Thread-类" class="headerlink" title="1.1 继承 Thread 类"></a>1.1 继承 Thread 类</h3><p>继承 Thread 类，重新 run() 方法。实现代码如下：</p><pre><code>public class ExtendsThread extends Thread&#123;    @Override    public void run() &#123;        System.out.println(&quot;run ExtendsThread&quot;);    &#125;&#125;使用线程：public class LearningThread &#123;    public static void main(String[] args) &#123;        func1();    &#125;    public static void func1()&#123;        ExtendsThread extendsThread = new ExtendsThread();        System.out.println(&quot;run func1&quot;);        extendsThread.start();        System.out.println(&quot;run func1 end&quot;);    &#125;&#125;</code></pre><h3 id="1-2-实现-Runnable-接口"><a href="#1-2-实现-Runnable-接口" class="headerlink" title="1.2 实现 Runnable 接口"></a>1.2 实现 Runnable 接口</h3><p>实现 Runnable 接口，实现 run() 方法，通过 Thread 类来开启线程。代码如下：</p><pre><code>public class ImplRunnable implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;run ImplRunnable&quot;);    &#125;&#125;使用线程：public class LearningThread &#123;    public static void main(String[] args) &#123;        func2();    &#125;    public static void func2()&#123;        ImplRunnable implRunnable = new ImplRunnable();        System.out.println(&quot;run func2&quot;);        Thread thread = new Thread(implRunnable);        thread.start();        System.out.println(&quot;run func2 end&quot;);    &#125;&#125;</code></pre><h3 id="1-3-实现-Callable-接口"><a href="#1-3-实现-Callable-接口" class="headerlink" title="1.3 实现 Callable 接口"></a>1.3 实现 Callable 接口</h3><p>实现 Callable 接口，实现 call() 方法。代码如下：</p><pre><code>public class ImplCallable implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() throws Exception &#123;        return 2020;    &#125;&#125;使用线程：public class LearningThread &#123;    public static void main(String[] args) &#123;        func3();    &#125;    public static void func3() throws ExecutionException, InterruptedException &#123;        Callable&lt;Integer&gt; integerCallable = new ImplCallable();        System.out.println(&quot;run func3&quot;);        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(integerCallable);        Thread thread = new Thread(futureTask);        thread.start();        System.out.println(&quot;run func3 end&quot;);        System.out.println(&quot;futureTask.get = &quot; + futureTask.get());    &#125;&#125;</code></pre><p>这三种方式都可以实现多线程，第一种由于 Java 的单继承，不建议使用。至于实现 Runnable 接口，与实现 Callable 接口，的区别是，实现 Callable 接口后通过 futureTask.get() 方法可以获取线程内的执行结果。而 Runnable 是没有返回值的。</p><h2 id="2-为什么要用线程池？"><a href="#2-为什么要用线程池？" class="headerlink" title="2. 为什么要用线程池？"></a>2. 为什么要用线程池？</h2><p>线程池主要是为了减少每次创建线程时的资源消耗，重复利用创建好的线程，提高资源利用率。使用线程池由于减少了线程创建的过程，在每次接到请求时可以及时响应，提高响应速度。通过线程池统一管理线程，方便线程的分配，调优和监控。</p><h2 id="3-创建线程池的时候有哪些参数？"><a href="#3-创建线程池的时候有哪些参数？" class="headerlink" title="3. 创建线程池的时候有哪些参数？"></a>3. 创建线程池的时候有哪些参数？</h2><p>在 Java 源码中，创建线程池的构造方法最多有 7 个参数。</p><pre><code>public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler)</code></pre><ul><li>corePoolSize: 核心线程数，线程池的工作线程数量。</li><li>maximumPoolSize: 最大线程数，线程池中可以存活的最多的线程数量。当队列满了之后，会启用非核心线程，此时的线程池的大小变为最大线程数。</li><li>keepAliveTime: 非核心线程如果没有任务的话，可以存活的时间。</li><li>unit: 非核心线程存活时间的单位。</li><li>workQueue: 工作队列。当线程池中的线程达到 corePoolSize ,如果再来任务，就会放到工作队列里。</li><li>threadFactory: 线程工厂,线程池创建线程时使用的工厂。</li><li>handler：拒绝策略。如果线程池的线程达到了 maximumPoolSize ,如果再来任务，则执行拒绝策略。</li></ul><h2 id="4-线程池是如何工作的？"><a href="#4-线程池是如何工作的？" class="headerlink" title="4. 线程池是如何工作的？"></a>4. 线程池是如何工作的？</h2><p>当有任务提交到线程池时，首先启动核心线程。随着任务的增加，当核心线程用完之后，再次提交的线程将会进入工作队列。当工作队列满了之后，如果再次提交到线程池任务，将会判断，核心线程数是否小于最大线程数，如果小于，将会启用非核心线程，当工作的线程达到最大线程数后，如果还继续提交任务到线程池，则会执行拒绝策略来拒绝任务。</p><h2 id="5-常见的拒绝策略有哪些？"><a href="#5-常见的拒绝策略有哪些？" class="headerlink" title="5. 常见的拒绝策略有哪些？"></a>5. 常见的拒绝策略有哪些？</h2><p>JDK 自带了 4 种拒绝策略。</p><h3 id="5-1-AbortPolicy"><a href="#5-1-AbortPolicy" class="headerlink" title="5.1 AbortPolicy"></a>5.1 AbortPolicy</h3><p>直接丢弃任务，抛出 RejectedExecutionException</p><pre><code>public class ThreadPoolRunnable implements Runnable &#123;    private int number = 0;    public ThreadPoolRunnable(int number) &#123;        this.number = number;    &#125;    @Override    public void run() &#123;        System.out.println(&quot;run &quot;+Thread.currentThread().getName()+&quot;, number = &quot; + number);        try &#123;            Thread.sleep(3000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;使用线程池：    public static void func4()&#123;        ThreadPoolExecutor executor = new ThreadPoolExecutor(2,3,10,                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), new ThreadPoolExecutor.AbortPolicy());        for (int i = 0; i &lt; 7; i++) &#123;            Runnable runnable = new ThreadPoolRunnable(i);            executor.execute(runnable);        &#125;        executor.shutdown();    &#125;执行结果：run pool-1-thread-1, number = 0run pool-1-thread-3, number = 3run pool-1-thread-2, number = 1Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.learning.thread.ThreadPoolRunnable@1d44bcfa rejected from java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size = 3, active threads = 3, queued tasks = 1, completed tasks = 0]    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)    at com.learning.thread.LearningThread.func4(LearningThread.java:45)    at com.learning.thread.LearningThread.main(LearningThread.java:11)run pool-1-thread-1, number = 2</code></pre><p>由于最大线程数是 3 ,队列大小是 1，所以线程池最多可以同时存在 4 个线程，当提交第 5 任务时，主线程抛出异常。</p><h3 id="5-2-CallerRunsPolicy"><a href="#5-2-CallerRunsPolicy" class="headerlink" title="5.2 CallerRunsPolicy"></a>5.2 CallerRunsPolicy</h3><p>调用启用线程池的线程进行处理，不过会阻塞主线程。</p><pre><code>    public static void func4()&#123;        ThreadPoolExecutor executor = new ThreadPoolExecutor(2,3,10,                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), new ThreadPoolExecutor.CallerRunsPolicy());        for (int i = 0; i &lt; 7; i++) &#123;            Runnable runnable = new ThreadPoolRunnable(i);            executor.execute(runnable);        &#125;        executor.shutdown();    &#125;执行结果：run pool-1-thread-1, number = 0run main, number = 4run pool-1-thread-3, number = 3run pool-1-thread-2, number = 1run main, number = 5run pool-1-thread-3, number = 2run pool-1-thread-3, number = 6</code></pre><p>可以看到 第 5 个任务，即 number = 4，是在主线程中执行的，由于主线程被阻塞，导致第 6 个任务不能立即提交，当主线程执行结束后再提交时，线程池里已经有可用的线程了，所以第 6 个任务是线程池执行的。</p><h3 id="5-3-DiscardPolicy"><a href="#5-3-DiscardPolicy" class="headerlink" title="5.3 DiscardPolicy"></a>5.3 DiscardPolicy</h3><p>直接拒绝任务，不抛出任何异常</p><pre><code>    public static void func4()&#123;        ThreadPoolExecutor executor = new ThreadPoolExecutor(2,3,10,                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), new ThreadPoolExecutor.DiscardPolicy());        for (int i = 0; i &lt; 7; i++) &#123;            Runnable runnable = new ThreadPoolRunnable(i);            executor.execute(runnable);        &#125;        executor.shutdown();    &#125;执行结果：run pool-1-thread-2, number = 1run pool-1-thread-3, number = 3run pool-1-thread-1, number = 0run pool-1-thread-2, number = 2</code></pre><h3 id="5-4-DiscardOldestPolicy"><a href="#5-4-DiscardOldestPolicy" class="headerlink" title="5.4 DiscardOldestPolicy"></a>5.4 DiscardOldestPolicy</h3><p>抛弃队列中最先加入的任务，然后将当前任务提交到线程池。</p><pre><code>    public static void func4()&#123;        ThreadPoolExecutor executor = new ThreadPoolExecutor(2,3,10,                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), new ThreadPoolExecutor.DiscardOldestPolicy());        for (int i = 0; i &lt; 7; i++) &#123;            Runnable runnable = new ThreadPoolRunnable(i);            executor.execute(runnable);        &#125;        executor.shutdown();    &#125;执行结果：run pool-1-thread-1, number = 0run pool-1-thread-3, number = 3run pool-1-thread-2, number = 1run pool-1-thread-1, number = 6</code></pre><p>number 0、1，使用核心线程执行。</p><p>number 2，放入队列。</p><p>number 3，启用非核心线程执行。</p><p>number 4，抛弃 number 2，将 number 4 放入队列</p><p>number 5，抛弃 number 4，将 number 5 放入队列</p><p>number 6，抛弃 number 5，将 number 6 放入队列</p><p>执行 number 6</p><h3 id="5-5-自定义拒绝策略"><a href="#5-5-自定义拒绝策略" class="headerlink" title="5.5 自定义拒绝策略"></a>5.5 自定义拒绝策略</h3><p>当然，如果上面的拒绝策略都不满足的话,我们也可以定义拒绝策略。</p><pre><code>public class MyRejectedExecutionHandler implements RejectedExecutionHandler &#123;    @Override    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;        System.out.println(executor.toString());    &#125;&#125;执行结果：run pool-1-thread-2, number = 1run pool-1-thread-3, number = 3run pool-1-thread-1, number = 0java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Running, pool size = 3, active threads = 3, queued tasks = 1, completed tasks = 0]java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Running, pool size = 3, active threads = 3, queued tasks = 1, completed tasks = 0]java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Running, pool size = 3, active threads = 3, queued tasks = 1, completed tasks = 0]run pool-1-thread-2, number = 2</code></pre><h2 id="6-常见的线程池有哪些？各自有什么特点？"><a href="#6-常见的线程池有哪些？各自有什么特点？" class="headerlink" title="6. 常见的线程池有哪些？各自有什么特点？"></a>6. 常见的线程池有哪些？各自有什么特点？</h2><p>JDK自带了几个常见的线程池。</p><h3 id="6-1-FixedThreadPool"><a href="#6-1-FixedThreadPool" class="headerlink" title="6.1 FixedThreadPool"></a>6.1 FixedThreadPool</h3><p>FixedThreadPool 被称为可重用固定线程数的线程池。创建的源码如下：</p><pre><code>    public static ExecutorService newFixedThreadPool(int nThreads) &#123;        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;());    &#125;</code></pre><p>可以看到 FixedThreadPool 的的核心线程数和最大线程数都是传入的参数。使用的队列是 LinkedBlockingQueue 。<br>由于 LinkedBlockingQueue 是一个无界队列（队列的容量为 Intger.MAX_VALUE），所以运行中的 FixedThreadPool 不会拒绝任务，所以当任务过多的时候可能会造成 OOM 。</p><h3 id="6-2-SingleThreadExecutor"><a href="#6-2-SingleThreadExecutor" class="headerlink" title="6.2 SingleThreadExecutor"></a>6.2 SingleThreadExecutor</h3><p>SingleThreadExecutor 是只有一个线程的线程池。创建源码：</p><pre><code>    public static ExecutorService newSingleThreadExecutor() &#123;        return new FinalizableDelegatedExecutorService            (new ThreadPoolExecutor(1, 1,                                    0L, TimeUnit.MILLISECONDS,                                    new LinkedBlockingQueue&lt;Runnable&gt;()));    &#125;</code></pre><p>SingleThreadExecutor 的核心线程数和最大线程数都为 1，所以这个线程池只有一个线程。使用的队列也是 LinkedBlockingQueue ，所以当任务过多时也会存在 OOM 的问题。</p><h3 id="6-3-CachedThreadPool"><a href="#6-3-CachedThreadPool" class="headerlink" title="6.3 CachedThreadPool"></a>6.3 CachedThreadPool</h3><p>CachedThreadPool 无固定大小的线程池，随着任务的不断提交，创建新的线程来执行。创建源码：</p><pre><code>    public static ExecutorService newCachedThreadPool() &#123;        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                      60L, TimeUnit.SECONDS,                                      new SynchronousQueue&lt;Runnable&gt;());    &#125;</code></pre><p>CachedThreadPool 的核心线程数为 0 ，最大线程数是 Integer.MAX_VALUE，可见所有的线程都是非核心线程。如果线程池的线程 60 秒,没有执行任务则会被销毁。由于使用了 SynchronousQueue，所以当主线程通过 SynchronousQueue.offer(Runnable task) 提交任务到队列后会阻塞，如果线程池中有可用的线程，则会执行当前任务，如果没有则会创建一个新的线程来执任务。</p><p>可见，如果任务太多的话，依然会造成 OOM ，与 LinkedBlockingQueue 不同的是，LinkedBlockingQueue 是由于任务对象太多，导致 OOM，ThreadPoolExecutor 则是由于 线程数太多导致 OOM 。</p><h2 id="如何获取线程池中的返回结果？"><a href="#如何获取线程池中的返回结果？" class="headerlink" title="如何获取线程池中的返回结果？"></a>如何获取线程池中的返回结果？</h2><p>可以使用 <code>executor.submit(futureTask);</code>,提交一个 FutureTask。代码如下：</p><pre><code>自定义的线程public class ThreadPoolCallable implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() throws Exception &#123;        Random random = new Random();        int number = random.nextInt(100);        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number);        return number;    &#125;&#125;使用：    public static void func5() throws ExecutionException, InterruptedException &#123;        ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 3, 10,                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), new ThreadPoolExecutor.CallerRunsPolicy());        int result = 0;        for (int i = 0; i &lt; 7; i++) &#123;            Callable&lt;Integer&gt; callable = new ThreadPoolCallable();            FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callable);            executor.submit(futureTask);            result += futureTask.get();        &#125;        executor.shutdown();        System.out.println(&quot;result = &quot; + result);    &#125;执行结果：pool-1-thread-1:41pool-1-thread-2:83pool-1-thread-1:15pool-1-thread-2:21pool-1-thread-1:26pool-1-thread-2:38pool-1-thread-1:98result = 322</code></pre>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试笔记（一）事务连环炮</title>
      <link href="20200107.html"/>
      <url>20200107.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-熟悉-MySQL-的事务么？"><a href="#1-熟悉-MySQL-的事务么？" class="headerlink" title="1. 熟悉 MySQL 的事务么？"></a>1. 熟悉 MySQL 的事务么？</h2><p>在 MySQL 中只有使用 Innodb 引擎才支持事务，事务用于维护数据的完整性。</p><p>事务有四个特性：原子性、一致性、隔离性、持久性</p><ul><li>原子性：在同一个事务里的 SQL 要么都被执行，要么都不执行，如果某个SQL执行失败会触发回滚操作。</li><li>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</li><li>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力。数据库支持对不同事务的操作进行隔离，避免干扰</li><li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h2 id="2-事务的隔离级别有哪些？"><a href="#2-事务的隔离级别有哪些？" class="headerlink" title="2. 事务的隔离级别有哪些？"></a>2. 事务的隔离级别有哪些？</h2><p>事务的隔离级别有 4 个等级，分别是：读未提交（Read uncommitted）、读已提交（read committed）、可重复读（repeatable read）、串行化（Serializable）</p><h3 id="2-1-读未提交（Read-uncommitted）"><a href="#2-1-读未提交（Read-uncommitted）" class="headerlink" title="2.1 读未提交（Read uncommitted）"></a>2.1 读未提交（Read uncommitted）</h3><p>一般不会使用，这种情况下会出现<strong>脏读</strong>现象，即 A、B 两个事务同时执行，A事务读到的数据可能是 B 事务没有提交的数据（脏数据）。</p><h3 id="2-2-读已提交（read-committed）"><a href="#2-2-读已提交（read-committed）" class="headerlink" title="2.2 读已提交（read committed）"></a>2.2 读已提交（read committed）</h3><p>Innodb 为了解决 脏读现象，支持了对数据表和数据行进行加锁，即 B 事务更新数据时，不允许 A 事务进行更新操作。<br>这种情况下保证了 A 事务读到的数据都是 B 事务提交的数据，即 <strong>读已提交（read committed）</strong>。在这种情况下会出现另外一个问题，如果 A 需要读取两次数据，第一次读取后，数据被 B 事务更新了，A事务就会出现第一次和第二次读取的数据不一致，这种现象被称为<strong>不可重复读</strong>。</p><h3 id="2-3-可重复读（repeatable-read）"><a href="#2-3-可重复读（repeatable-read）" class="headerlink" title="2.3 可重复读（repeatable read）"></a>2.3 可重复读（repeatable read）</h3><p>在<strong>读已提交（read committed）</strong> 的情况下仅仅是对 update 加了写锁，可以对 select 加读锁，即 A 事务读取的时候不允许 B 事务读取，这样就可以解决<strong>不可重复读</strong> 的问题（不过由于性能问题，Innodb没有采用这种方式）</p><p>在<strong>可重复读（repeatable read）</strong>这种隔离级别下，解决了两次读取不一致的情况。但会带来新的问题，当 A 事务在两次读取的时候，B 事务进行了 insert/delete 操作，A 事务第二次会读取出来数据条数，就会出现不一致的情况，这种情况称为<strong>幻读</strong>。</p><h3 id="2-4-串行化（Serializable）"><a href="#2-4-串行化（Serializable）" class="headerlink" title="2.4 串行化（Serializable）"></a>2.4 串行化（Serializable）</h3><p>为了解决<strong>幻读</strong>问题，需要对读锁、写锁互斥，即加上读锁后，不允许加写锁。这种情况下就不会出现幻读现象。<br>（不过由于性能问题，Innodb并没有采用这种形式）。</p><h2 id="3-Innodb-是如何解决不可重复读和幻读问题的？"><a href="#3-Innodb-是如何解决不可重复读和幻读问题的？" class="headerlink" title="3. Innodb 是如何解决不可重复读和幻读问题的？"></a>3. Innodb 是如何解决不可重复读和幻读问题的？</h2><p>是通过 MVCC（多版本并发控制）来解决的。在 InnoDB 引擎中，每一条记录会自动增加两个字段，记录了这条数据在何时被创建，另一个字段记录了这条数据在何时被删除。实际存储的并不是时间，而是事务版本号，意味着，某条记录在第几个（版本号）事务里被创建，在第几个（版本号）事务里被删除。</p><p>我们再看一下<strong>不可重复读</strong>的问题，主要原因是，在一个事务读取两次期间，另外一个事务更新了数据。如果加上了 MVCC，</p><p>在<strong>可重复读（RR）</strong>隔离级别下：</p><ul><li>INSERT：保存当前事务版本号为创建版本号</li><li>DELETE：保存当前事务版本号为删除版本号</li><li>SELECT：读取创建版本号小于当前事务版本号，并且删除版本号为空或者大于当前事务版本号的数据，</li><li>UPDATE：<strong>插入一条新记录</strong>，保存当前事务版本号为创建版本号，并且保存当前事务版本号为原记录的删除版本号。</li></ul><p>我们以一条记录为例，这条记录一共有两个字段，姓名和余额，第三个字段是自动添加的创建版本号，第四个是删除版本号。</p><p>事务1创建了一条记录，事务2 将进行两次查询，在第一次查询后，事务3更新了这条记录，事务2查询到的仍然是原始数据。更新后的数据与新创建的数据创建版本号均大于 2，所以 在执行 SELECT 时是无法查到的。这样就解决了<strong>不可重复读</strong>和<strong>幻读</strong>问题。</p><p><img src="./images/20200107-1.png" alt="事务并发"></p><h2 id="4-数据库行锁"><a href="#4-数据库行锁" class="headerlink" title="4. 数据库行锁"></a>4. 数据库行锁</h2><p>通过 MVCC 虽然解决了不可重复读和幻读的问题，但是读取的数据并不是实时的数据。例如在上面的例子中，事务2 第二次读取的数据并不是最新的数据（事务3更新后的数据，事务4新增的数据都没有读到）。</p><p>在某些场景下，有时候需要读取实时的数据。比如常见的 SELECT FOR UPDATE，事务2 如果第二次执行的是 UPDATE 操作，将会覆盖事务3的更新。这个时候就需要地读取到最新的数据。 </p><p>Innodb 通过对数据行进行加锁，当事务2第一次读取时对数据行加锁，事务3将无法再次进行更新。这样就避免数据覆盖更新的问题。</p><h2 id="5-Next-Key-锁"><a href="#5-Next-Key-锁" class="headerlink" title="5. Next-Key 锁"></a>5. Next-Key 锁</h2><p>虽然数据库行锁，解决就覆盖更新的问题，但是并没有解决幻读的问题，事务2对张三的数据加了行锁，但是并不能阻止事务4插入数据，所以在第二次执行更新（UPDATE）操作的时候依然会操作到新增的数据。</p><p>为了解决这个问题 Innodb 使用了一种被称为 Next-Key 的锁，这种锁是行锁和间隙锁（GAP）的合并。之所以被称为间隙锁，是由于在 Innodb 中，聚族索引将数据分为了不同的区间，以 id = 102,id = 112 两条数据为例，则会将数据分为 </p><ul><li>(negative infinity,102]</li><li>(102,112]</li><li>(112,positive infinity)</li></ul><p>GAP 锁是加在区间上的一种锁，当执行 UPDATE 的数据 ID = 105 时，Innodb 会对 (102,112] 区间进行加锁操作，这样就避免了数据的新增操作。如果使用的不是索引字段，则会对全表加GAP锁。</p><p>行锁防止了其他事物的修改和删除，GAP锁防止了数据的新增。行锁和GAP锁组成的 Next-Key 锁共同解决了在RR级别的幻读问题。</p><h2 id="6-分布式事务"><a href="#6-分布式事务" class="headerlink" title="6. 分布式事务"></a>6. 分布式事务</h2><p>分布式事务是指，事务操作的数据分布在不同的多个数据库实例上，仍然需要保证分布式事务的ACID特性。</p><p>在同一个数据库实例中，为了保证事务的ACID特性可以通过加锁来解决问题，但是在分布式事务中，由于数据不在同一个数据库实例中，所以没办法通过简单的加锁来解决。</p><h2 id="7-CAP原则"><a href="#7-CAP原则" class="headerlink" title="7. CAP原则"></a>7. CAP原则</h2><p>CAP原则又称CAP定理。在分布式事务中，事务的一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance），这三个要素只能存在同时存在两个。</p><ul><li>一致性（C）: 在分布式系统中的所有数据备份，在同一时刻是否是同样的值。</li><li>可用性（A）: 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求</li><li>分区容错性（P）: 多个数据库实例的数据当发生不一致的情况下，需要考虑应对的办法</li></ul><p>一般情况下，分区容错性（P）是必须要考虑的。而如果要保证一致性，当需要对一个节点的数据库实例进行操作时，必须对另外的数据库实例进行加锁处理，等待数据同步后释放，在这期间是不具备可用性（A）的。如果要保证可用性（A），势必不能对数据库实例进行加锁，那么一致性（C）将无法保证。</p><p>所以，CAP原则说，这三个要素只能同时存在两个。</p><p>由于CAP原则的存在，业界主流的做法是<strong>放弃实时一致性，保证事务的最终一致性</strong>。就是说，在分布式事务中，不保证事务执行时数据立即生效，而是保证数据最终是一致的。遵守CAP的AP原则。通过技术手段来达到数据在事务执行之后是一致的。</p><h2 id="7-两阶段提交"><a href="#7-两阶段提交" class="headerlink" title="7. 两阶段提交"></a>7. 两阶段提交</h2><p>两阶段提交（Two-phase Commit，2PC），通过引入全局事务管理器来协调参与事务的数据库实例的行为，并最终决定是否要真正执行事务。</p><p>两阶段提交分为两个阶段，准备阶段和提交阶段。</p><p>在准备阶段，全局事务管理器向所有参与事务的节点发起请求执行事务，并返回事务是否执行成。</p><p>在提交阶段，如果全局事务管理器收到的响应均为执行成功，则通知所有节点提交事务。否则通知所有节点回滚事务。<br><strong>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段才会提交或者回滚事务</strong></p><p>两阶段提交存在下面几个问题：</p><ul><li>同步阻塞，所有参与事务的节点都需要同步阻塞等待响应，无法进行其他操作。</li><li>全局事务管理器的单点问题，一旦全局事务管理器发生故障，尤其是在第二阶段，所有节点将会一直同步阻塞等待全局事务管理器的响应。</li><li>数据一致性问题，如果在准备阶段，所有事务执行成功，而在提交阶段部分节点没有收到请求，则会导致只有部分节点提交了事务，导致数据不一致。</li><li>太过保守,任意节点失败都会导致事务失败。没有容错机制。</li></ul><h2 id="8-基于MQ实现的最终一致性"><a href="#8-基于MQ实现的最终一致性" class="headerlink" title="8. 基于MQ实现的最终一致性"></a>8. 基于MQ实现的最终一致性</h2><p>由于舍弃了数据的实时一致性，可以将事务的操作保存到MQ中，然后通过MQ发送到其他节点上。首先在事务开始阶段发送预备消息，然后执行本地事务，本地事务执行成功后，再次发送确认消息，如果确认消息发送失败，MQ则需要定期扫描MQ上的预备消息，回调事务节点，如果事务节点执行失败，则回滚事务消息。如果执行成功，则向其他节点请求执行事务。</p><p><img src="./images/20200107-2.png" alt="基于MQ的事务最终一致性"></p><p>基于MQ消息的分布式事务最大的问题是实现难度比较大，目前主流MQ并不支持。</p><h2 id="9-基于本地事件表实现的最终一致性"><a href="#9-基于本地事件表实现的最终一致性" class="headerlink" title="9. 基于本地事件表实现的最终一致性"></a>9. 基于本地事件表实现的最终一致性</h2><p>基于本地事件表的实现是通过在本地保存一份事件表，记录事务需要执行的操作，通过程序向其他节点同步事务的执行，其他节点同样保存事件表。并记录事务的执行状态。</p><p>本地事务执行成功后，将保存事务的操作到事件表。然后将事件表的数据发送到MQ，通过MQ发送到其他数据库实例上，其他数据库实例中事务执行成功后，将结果写入到本地事件表。</p><p>基于本地事件表的方法的缺点是事件表与业务表在同一个库中，耦合性比较大。而且需要对事物进行定制化的封装，一旦封装不友好，则会与业务代码造成耦合。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 爬虫实战(二)  Selenium 爬取某起名网所有姓名</title>
      <link href="20191219.html"/>
      <url>20191219.html</url>
      
        <content type="html"><![CDATA[<p><strong>免责声明：本文仅供学习交流，如出现任何法律问题本人概不负责！</strong></p><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>Selenium 可以说是最简单的爬虫框架了，它是通过模拟浏览器的动作来达到数据抓取的。</p><p>这次打算使用 Selenium 抓取 <a href="https://www.meimingteng.com/Naming/" target="_blank" rel="noopener">https://www.meimingteng.com/Naming/</a> 网站所有姓名。<br>由于非会员只能抓取一页数据，所以我们可以通过设置不同的出生时间来抓取多页数据。</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>使用 <code>pip install selenium</code> 来安装 selenium 库，此外你还需要一个浏览器驱动，因为 selenium 就是通过操作这个驱动，来模拟浏览器的行为的。<a href="https://selenium-python.readthedocs.io/installation.html" target="_blank" rel="noopener">官网</a> 提供了主流浏览器的驱动下载地址。我使用的是 <a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">Chrome</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 学习笔记(一) 选择器</title>
      <link href="20191111.html"/>
      <url>20191111.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、选择器"><a href="#一、选择器" class="headerlink" title="一、选择器"></a>一、选择器</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><p>元素选择器是最基本的选择器。也是最简单的选择器。可以选择某个或者某些标签</p><pre><code>h1, h2 &#123;    color: red;     background: gray;&#125;</code></pre><p>上面的 CSS 会将所有的 h1 和 h2 标签变成红色,背景变成灰色。</p><h3 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h3><p>可以选择所有元素，或者说是整个文档</p><pre><code>* &#123;color: red&#125;</code></pre><p>上面的选择器可以让整个文档变成红色</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>选择一类元素，必须在标签上指定 class 的属性值。</p><pre><code>*.warning &#123;font-weight: bold&#125;</code></pre><p>这段 CSS 会选中下面 html 代码中的 p 标签和 text 标签：</p><pre><code>&lt;div&gt;    &lt;p class=&quot;warning&quot;&gt;被选中&lt;/p&gt;    &lt;text class=&quot;warning&quot;&gt;被选中&lt;/text&gt;&lt;/div&gt;</code></pre><p>注意，这里的选择器前面包含了一个星号（<code>*</code>）这里的星号是通配符的含义，即任意元素的 class 属性中如果包含 warning 即会被选中。由于星号是通配符，所以也可省略掉，像下面这样：</p><pre><code>.warning &#123;font-weight: bold&#125;</code></pre><p>效果是一样的。</p><p>你也可以指定某个特定的标签，例如：</p><pre><code>p.warning &#123;font-weight: bold&#125;</code></pre><p>这段 CSS 只会选中 p 标签，而不会选中 text 标签。不论 text 标签的 class 属性是否包含 warning </p><h3 id="多类选择器"><a href="#多类选择器" class="headerlink" title="多类选择器"></a>多类选择器</h3><p>class 属性可以包含多个，如果需要选中某个含有两个 class 的标签，可以使用多类选择器。</p><pre><code>.warning.uegent &#123;background: silver;&#125;</code></pre><p>上面这段 CSS 会选中即含有 warning 又含有 uegent 的标签。即下面的 h3 标签。</p><pre><code>&lt;div&gt;    &lt;h1 class = &quot;warning&quot;&gt;多类选择器&lt;/h1&gt;    &lt;h2 class = &quot;uegent&quot;&gt;多类选择器&lt;/h2&gt;    &lt;h3 class = &quot;warning uegent&quot;&gt;被选中&lt;/h3&gt;&lt;/div&gt;</code></pre><p>这两个词的顺序无关紧要，也可以写成 <code>&lt;h3 class = &quot;uegent warning&quot;&gt;</code>。</p><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p>选中某个id值得标签</p><pre><code>#first-h1 &#123;color: red&#125;</code></pre><p>上面这段 CSS 会选中 下面的 h1 标签</p><pre><code>&lt;div&gt;    &lt;h1 id = &quot;first-h1&quot;&gt;被选中&lt;/h1&gt;    &lt;h2 class = &quot;uegent&quot;&gt;ID选择器&lt;/h2&gt;    &lt;h3 class = &quot;warning uegent&quot;&gt;ID选择器&lt;/h3&gt;&lt;/div&gt;</code></pre><p><strong>注意：</strong> 在同一个 html 页面中所有元素的 id 是不可重复的，但是 class 是可以重复的。</p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>如果希望选择有某个属性的元素，而不关心具体的属性值。可以使用属性选择器。</p><h4 id="简单属性选择器"><a href="#简单属性选择器" class="headerlink" title="简单属性选择器"></a>简单属性选择器</h4><pre><code>h1[class] &#123;color: red&#125;</code></pre><p>上面的选择器可以选择所有含有 class 的 h1 标签。即下面第二个 h1 标签</p><pre><code>&lt;div&gt;    &lt;h1 id = &quot;first-h1&quot;&gt;简单属性选择器&lt;/h1&gt;    &lt;h1 class = &quot;warning uegent&quot;&gt;被选中&lt;/h1&gt;&lt;/div&gt;</code></pre><p>当然也可以使用通配符。下面的 CSS 会选中所有含有 class 属性的标签。</p><pre><code>*[class] &#123;color: red&#125;</code></pre><p>还可以使用多个属性。下面的 CSS 会选中所有含有 id 和 class 的标签。必须是同时含有两个属性</p><pre><code>*[id][class] &#123;color: red&#125;</code></pre><h4 id="属性值选择器"><a href="#属性值选择器" class="headerlink" title="属性值选择器"></a>属性值选择器</h4><p>可以根据某个属性的具体值来选择标签。</p><pre><code>h1[id = &quot;first-h1&quot;] &#123;color: red&#125;</code></pre><p>上面的 CSS 表示，选择 <code>id = first-h1</code> 的 h1 标签。即下面的第一个 h1 标签</p><pre><code>&lt;div&gt;    &lt;h1 id = &quot;first-h1&quot;&gt;被选中&lt;/h1&gt;    &lt;h1 class = &quot;warning uegent&quot;&gt;简单属性选择器&lt;/h1&gt;&lt;/div&gt;</code></pre><p>当然你也可以多个属性的值一起选择，比如:</p><pre><code>a[id = &quot;first-link&quot;][href = &quot;http://zdran.com&quot;] &#123;color: red&#125;</code></pre><p><strong>注意：</strong> CSS 里的值必须是完全匹配。比如：</p><pre><code>*[class = &quot;uegent&quot;]</code></pre><p>上面这段 CSS 只能选中 h2 标签，如果需要选择 h3 则需要写成：</p><pre><code>*[class = &quot;warning uegent&quot;] &#123;color: red&#125;</code></pre><p>属性的值必须是完全一样，才会选中标签</p><pre><code>&lt;div&gt;    &lt;h1 id = &quot;first-h1&quot;&gt;属性值选择器&lt;/h1&gt;    &lt;h2 class = &quot;uegent&quot;&gt;第一次被选中&lt;/h2&gt;    &lt;h3 class = &quot;warning uegent&quot;&gt;第二次被选中&lt;/h3&gt;&lt;/div&gt;</code></pre><h4 id="部分属性值选择器"><a href="#部分属性值选择器" class="headerlink" title="部分属性值选择器"></a>部分属性值选择器</h4><p>上面提到的属性值选择器要求完全匹配，这里的部分属性值选择器要求部分值匹配即可。</p><pre><code>p[class ~= &quot;uegent&quot;] &#123;color: red&#125;</code></pre><p>这段 CSS 会选中下面的 html 代码中的第二个和第三个标签。因为这两个标签的 class 属性值中都含有”uegent”</p><pre><code>&lt;div&gt;    &lt;p id = &quot;first-p&quot;&gt;部分属性值选择器&lt;/p&gt;    &lt;p class = &quot;uegent&quot;&gt;被选中&lt;/p&gt;    &lt;p class = &quot;warning uegent&quot;&gt;被选中&lt;/p&gt;&lt;/div&gt;</code></pre><h4 id="子串匹配选择器"><a href="#子串匹配选择器" class="headerlink" title="子串匹配选择器"></a>子串匹配选择器</h4><p>类似于正则表达式</p><pre><code>*[class^=&quot;start&quot;]    // 选中 class 的值以 start 开头的标签*[class$=&quot;end&quot;]    // 选中 class 的值以 end 结尾的标签*[class*=&quot;mid&quot;]    // 选中 class 的值中包含 mid 的标签</code></pre><h4 id="特定属性选择器"><a href="#特定属性选择器" class="headerlink" title="特定属性选择器"></a>特定属性选择器</h4><p>这个选择器应该是最常见的选择器。以下面的 CSS 为例：</p><pre><code>*[lang|=&quot;en&quot;]</code></pre><p>他会选中 lang 属性的值为 “en” 或者以 “en-“(注意：后面有个短线) 开头的元素。所以会选中下面的前两个 p 标签</p><pre><code>&lt;div&gt;    &lt;p lang = &quot;en&quot;&gt;被选中&lt;/p&gt;    &lt;p lang = &quot;en-zh&quot;&gt; 被选中&lt;/p&gt;    &lt;p class = &quot;zh&quot;&gt;特定属性选择器&lt;/p&gt;&lt;/div&gt;</code></pre><p><strong>PS:如果你不理解文档树结构，建议先了解下文档树结构再往下看</strong></p><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>也称为包含选择器，或者上下文选择器，它可以选中某个标签下的某些标签。比如，选择 div 下的 p 标签，可以这样写：</p><pre><code>div p &#123;color: red&#125;</code></pre><p>上面的 CSS 会选中第一个 p 标签，而不会选中第二个 p 标签</p><pre><code>&lt;div&gt;    &lt;p lang = &quot;en&quot;&gt;被选中&lt;/p&gt;&lt;/div&gt;&lt;p lang = &quot;en-zh&quot;&gt;后代选择器&lt;/p&gt;</code></pre><p>当然并不局限于两个元素，也可以写成下面这样</p><pre><code>html body div p span &#123;color: red&#125;</code></pre><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><p>选中某个元素的子元素，与后代选择器的区别是，后代选择器可以选中某个元素的子元素，某个元素的子元素的子元素（子孙元素），而子元素选择器只能选择某个元素的子元素。</p><pre><code>div &gt; span &#123;color: red&#125;</code></pre><p>上面的元素可以选中 div 下的 span 标签，即第一个 span 标签，第二个则无效，而使用后代选择器可以选中两个 span 标签。</p><pre><code>&lt;div&gt;    &lt;span&gt;被选中&lt;/span&gt;    &lt;p&gt;子元素&lt;span&gt;不被选中&lt;/span&gt;选择器&lt;/p&gt;&lt;/div&gt;</code></pre><p>子元素选择器只选择一级，而后代是所有的后代，以及后代的后代</p><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><p>选中紧接在一个元素后的元素。</p><pre><code>div + p &#123;color: red&#125;</code></pre><p>上面这段 CSS 可以选中第二个 p 标签，即 div 后的元素。</p><pre><code>&lt;div&gt;    &lt;p lang = &quot;en&quot;&gt;后代选择器&lt;/p&gt;&lt;/div&gt;&lt;p lang = &quot;en-zh&quot;&gt;被选中&lt;/p&gt;&lt;div&gt;    &lt;p lang = &quot;en&quot;&gt;不被选中&lt;/p&gt;&lt;/div&gt;</code></pre><p>相邻兄弟选择器可以和子元素选择器一起使用。例如：</p><pre><code>html &gt; body &gt; div + p &#123;color: red&#125;</code></pre><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><h4 id="链接伪类"><a href="#链接伪类" class="headerlink" title="链接伪类"></a>链接伪类</h4><p>伪类选择器可以选择某些元素处于特定状态的元素。比如，可以为已经被点击过的 a 标签添加一个 CSS。</p><pre><code>a:visited &#123;color: red&#125;</code></pre><p>上面的 CSS 会应用到已经被访问过的 a 标签。对应的，还有一个，选择没有被点击的<strong>超链接</strong>。</p><pre><code>a:link &#123;color: black&#125;</code></pre><p>上面的 CSS 会应用到没有被点击过的<strong>超链接</strong>上。注意，上面的 CSS 只会选中带有 href 属性的 a 标签。</p><pre><code>&lt;a href=&quot;http://zdran.com&quot;&gt;被选中&lt;/a&gt;&lt;a name =&quot;first&quot;&gt;不会被选中&lt;/a&gt;</code></pre><p>当然也可以和其他选择器配合使用，比如:</p><pre><code>#my_link:visited &#123;color:red&#125;</code></pre><h4 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h4><pre><code>a:focues &#123;color: red&#125;</code></pre><p>选中获取到输入焦点的 a 标签。</p><pre><code>a:hover &#123;color: red&#125;</code></pre><p>选中鼠标指针悬停的 a 标签</p><pre><code>a:active &#123;color:red&#125;</code></pre><p>选中鼠标点击的元素。<br><strong>PS</strong>有兴趣的同学可以试试将这几个伪类同时用到同一个 a 标签上，看看会发生什么神奇的效果。</p><h4 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h4><pre><code>li:not(.first-item) &#123;color: red&#125;</code></pre><p>如果 class 属性中含有 first-item 则不被选中。例如下面的第一个 li 标签将不被选中</p><pre><code>&lt;ul&gt;    &lt;li class=&quot;first-item&quot;&gt;不被选中&lt;/li&gt;    &lt;li&gt;被选中&lt;/li&gt;    &lt;li&gt;被选中&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code>li:first-child &#123;color: red&#125;</code></pre><p>选中第一个元素。</p><pre><code>&lt;ul&gt;    &lt;li&gt;被选中&lt;/li&gt;    &lt;li&gt;不被选中&lt;/li&gt;    &lt;li&gt;不被选中&lt;/li&gt;&lt;/ul&gt;</code></pre><p>同样还有选中最后一个元素的伪类</p><pre><code>li:last-child &#123;color:red&#125;</code></pre><p>还有一个可以根据一个参数来选择第几个元素。</p><pre><code>ol :nth-child(2n) &#123;color: red&#125;</code></pre><p>上面的 CSS 可以选中第 2n 个元素，即第2、4、6、8、10… 位置的元素。如果想选奇数位置的元素，可以设置为：</p><pre><code>ol :nth-child(2n+1) &#123;color: red&#125;</code></pre><p>如果想只选择第几个元素，可以直接写成具体的值，比如只选择第 5 个元素，可以设置为：</p><pre><code>ol :nth-child(5) &#123;color: red&#125;</code></pre><p>nth-child 可以接收一个 an+b 的参数，可以根据 a 和 b 的值计算具体的位置。</p><h4 id="表单伪类"><a href="#表单伪类" class="headerlink" title="表单伪类"></a>表单伪类</h4><p>选中 任意被勾选/选中的 radio(单选按钮),checkbox(复选框),或者option(select中的一项) </p><pre><code>input:checked + label &#123;color: red&#125;</code></pre><p>上面的 CSS 会选中下面被勾选的选项</p><pre><code>&lt;div&gt;  &lt;input type=&quot;checkbox&quot;&gt;  &lt;label &gt;勾选后，被 CSS 选中&lt;/label&gt;&lt;/div&gt;</code></pre><p>如果是 radio 可以这么写：</p><pre><code>input[type=&quot;radio&quot;]:checked &#123;color:red&#125;</code></pre><p>选中下面的一个勾选后的选项</p><pre><code>&lt;div&gt;  &lt;input type=&quot;radio&quot; name=&quot;my-input&quot; id=&quot;yes&quot;&gt;  &lt;label for=&quot;yes&quot;&gt;Yes&lt;/label&gt;  &lt;input type=&quot;radio&quot; name=&quot;my-input&quot; id=&quot;no&quot;&gt;  &lt;label for=&quot;no&quot;&gt;No&lt;/label&gt;&lt;/div&gt;</code></pre><p>valid 可以选中校验结果正确的元素。比如：</p><pre><code>input[type=email]:valid &#123;color:green&#125;</code></pre><p>上面的 CSS 可以在输入框中输入正确的email的时候被选中。</p><pre><code>&lt;input type=&quot;email&quot;/&gt;</code></pre><p>当然，还可以选中校验结果不正确的元素。</p><pre><code>input[type=email]:invalid  &#123;color: red&#125;</code></pre><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素选择器可以在文档中插入不存在的元素，从而达到某种效果。</p><h4 id="设置首字母的样式。"><a href="#设置首字母的样式。" class="headerlink" title="设置首字母的样式。"></a>设置首字母的样式。</h4><pre><code>p:first-letter &#123;font-size: 5em&#125;</code></pre><p>上面的 CSS 可以设置所有 p 标签的首字母的样式。当然也可以设置首行的样式。</p><pre><code>p:first-line &#123;font-size: 5em&#125;</code></pre><h4 id="在元素前后插入内容"><a href="#在元素前后插入内容" class="headerlink" title="在元素前后插入内容"></a>在元素前后插入内容</h4><pre><code>h1:before &#123;content: &quot;hello&quot;&#125;</code></pre><p>在 h1 标签之前插入”hello” 字符串。同样，也可以在某个元素后插入内容。</p><pre><code>h1:after &#123;content: &quot;hello&quot;&#125;</code></pre><p>当然，伪类与伪元素不止上面说的这些，还有一些其他的选择器，如果需要了解更多，可以看一下参考文章里的博客</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference#%E9%80%89%E6%8B%A9%E5%99%A8">MDN CSS 参考</a></li><li><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/">总结伪类与伪元素</a></li><li><a href="https://book.douban.com/subject/2308234/">《CSS 权威指南》第3版</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 读书笔记(二) 垃圾收集</title>
      <link href="20190912.html"/>
      <url>20190912.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://zdran.com/20190322.html">JVM 读书笔记(一) 内存划分</a></li><li><a href="https://zdran.com/20190912.html">JVM 读书笔记(二) 垃圾收集</a></li></ul><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h2><p>Java 的垃圾回收主要是针对 JVM 中的栈区、堆区、常量区进行的一系列的操作，回收(格式化)掉已经不会被使用到的对象占用的内存，合理化的利用内存资源。</p><h2 id="1-对象已死？"><a href="#1-对象已死？" class="headerlink" title="1. 对象已死？"></a>1. 对象已死？</h2><p>想要进行垃圾回收，首先要做的，就是如何判断对象是否已经不再被引用。目前有两种常见的算法。</p><ul><li>引用计数算法</li><li>可达性分析算法</li></ul><p>引用计数算法比较简单。其实就是给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。如果在某个时间段计数值为 0 ，那说明该对象已经不再被引用，可以被回收。</p><p>但是引用计数算法有一个非常致命的问题，就是它很难解决双向引用(循环引用)的问题。比如，</p><pre><code>ObjA objA = new ObjA();ObjB objB = new ObjB();objA.next = objB;objB.next = objA;objA = null;objB = null;</code></pre><p>这种情况下，objA 和 objB 对象的引用计数都不是 0，但是已经没办法使用 objA 和 objB 的对象了。因为出现循环引用，导致引用计数不为 0 ，无法被 GC。</p><p>由于<strong>引用计数算法</strong>存在这样的问题，目前主流的 JVM 均没有采用这种方式，而是采用的是<strong>可达性分析算法</strong>。</p><p><strong>可达性分析算法</strong>的核心思想是，通过一系列称之为“GC Roots”的对象作为起始节点，通过这些节点搜索所有可达的节点。当发现某些对象不可达，即说明此对象不可用。可以被回收。</p><p>在 Java 中可以作为 GC Roots 的对象包括：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><h2 id="2-finalize-方法"><a href="#2-finalize-方法" class="headerlink" title="2. finalize() 方法"></a>2. finalize() 方法</h2><p>finalize() 方法是在对象被回收之前调用的方法。但是 finalize() 方法的调用具有不确定性。</p><p>当进行完可达性分析之后，某个对象被标记为不可达时，会判断当前对象是否重写了 finalize() 方法，是否已经执行过对象的 finalize() 方法，如果没有覆盖，或者已经执行过，则不再执行，对象将被回收。</p><p>如果有必要执行 finalize() 方法，则会将这个对象放到一个 F-Queue 的低优先级队列里等待执行。之后 GC 将对 F-Queue 中的对象再次进行可达性分析。</p><p>所以，如果对象可以在 finalize() 方法中再次复活，即将自己的 this 指针，重新赋值到某个可达的对象的引用上。</p><p>下面的代码演示了如何在 finalize() 方法中复活对象。（PS:虽然可以这样做，但是一直没有遇到过这样的场景）</p><pre><code>public class MyGC &#123;    private static GCTest gcTest = null;    private static class GCTest&#123;        public String name;        public GCTest(String name) &#123;            this.name = name;        &#125;        @Override        protected void finalize() throws Throwable &#123;            super.finalize();            System.out.println(&quot;finalize 被执行&quot;);            //将自身的引用赋值到其他可达 GC Roots 上            gcTest = this;        &#125;    &#125;    public static void main(String[] args) &#123;        gcTest = new GCTest(&quot;myGc&quot;);        // GCTest 对象不可达        gcTest = null;        System.gc();        //等待 5s        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        //对象可达        System.out.println(gcTest.name);    &#125;&#125;</code></pre><p>我们定义了一个 MyGC 类，这个类有一个静态属性，类型是一个内部类（GCTest），GCTest 重写了 finalize() 方法，在 finalize() 方法中进行了自救，将自身的引用赋值到了 外部的属性上。所以在 main 方法中，即便是我们显示的将 gcTest 对象置为 null 但是还是可以引用得到。</p><p>关于对象的引用，在 Java 1.2 之后，对象的引用分为四大类：</p><ul><li><p>强引用（Strong Reference）</p><p>  类似”Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p></li><li><p>软引用（Soft Reference）</p><p>  对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收</p></li><li><p>弱引用（Weak Reference）</p><p>  被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</p></li><li><p>虚引用（Phantom Reference）</p><p>  它是最弱的一种关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></li></ul><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h2><p>常见的垃圾收集算法包括：</p><ul><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li><li>分代收集算法</li></ul><p>JVM 的垃圾收集算法是使用了分代收集算法，复制算法、标记-整理算法。三种算法都有使用。使用分代收集算法，将 JVM 中的内存分为新生代和老年代，新生代采用复制算法收集，而老年代采用的是标记-整理算法。</p><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>标记-清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。</p><p><img src="/images/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记-清除算法"></p><p>标记-清除算法有两个缺陷，一个是效率问题，标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。</p><h3 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h3><p>为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。</p><p><img src="/images/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p><p>复制算法解决了空间碎片的问题。但是也带来了新的问题。因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。</p><p>JVM 中新生代采用的就是复制算法进行的GC。针对内存利用率不足的问题做了一些优化。</p><p>IBM公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，意思是说，在新生代中，经过一次 GC 之后能够存活下来的对象仅有 2% 左右。</p><p>所以并不需要按照1:1的比例划分出两块内存空间。而是将内存划分出三块，一块较大的 Eden 区，和两块较小的 Survivor 区。其中 Eden 区占 80% 的内存，两块 Survivor 各占 10% 的内存。在创建新的对象时，只使用 Eden 区和其中的一块 Survivor 区，当进行 GC 时，把 Eden 区和 Survivor 区存活的对象全部复制到另一块 Survivor 区中，然后清理掉 Eden 区和刚刚用过的 Survivor 区。</p><p>这种内存的划分方式就解决了内存利用率的问题，每次在创建对象时，可用的内存为 90%(80% + 10%) 当前内存容量。</p><h3 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h3><p>复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。</p><p>标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</p><p><img src="/images/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-整理算法"></p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。</p><h2 id="4-GC算法实现"><a href="#4-GC算法实现" class="headerlink" title="4. GC算法实现"></a>4. GC算法实现</h2><h3 id="4-1-OopMap"><a href="#4-1-OopMap" class="headerlink" title="4.1 OopMap"></a>4.1 OopMap</h3><p>在进行可达性分析时，我们需要分析内存中所有对象的引用关系，找到不可达的对象，并标记为可回收。而在程序的运行过程中，内存中对象的引用关系是在不断变化的，这就有可能在我们分析可达性的这段时间内，对象的引用关系发生变化。所以，为了准确的分析出对象的引用关系，JVM 不得不停止所有 Java 的执行线程（Sun 将这个过程称之为 “Stop The World”）。即使是在号称（几乎）不会发生 STW 的 CMS 收集器中，在枚举根节点时，也会发生停顿。</p><p>在可达性分析时另外一个问题是，内存中的对象太多，如果要逐个检查对象的引用关系，会非常耗时。为了解决这个问题，在 HotSpot 虚拟机中，使用了一组 OopMap 的数据结构来记录对象内的偏移量上的类型，在 JIT 编译过程也会在特定位置记录下栈和寄存器中哪些位置是对象的引用。在发生 GC 时就可以直接扫描 OopMap 就可以直接得到对象的引用信息了。</p><h3 id="4-2-Safepoint"><a href="#4-2-Safepoint" class="headerlink" title="4.2 Safepoint"></a>4.2 Safepoint</h3><p>其实就是使用 OopMap 把对象的引用关系保存了下来，但是这样就引发了另外一个问题。可能导致 OopMap 内容变化的指令非常多，我们不能为每个指令都创建一个 OopMap，这样 GC 的空间成本会提高。</p><p>所以 JVM 做了一种改进，<strong>只在程序运行期间的某些特定的位置记录 OopMap</strong>，这些特定的位置被称为“安全点（Safepoint）”。这样就解决了 OopMap 随时变化的问题，JVM 不再实时的关注内存中引用关系的变化，而是在安全点处获取当前的内存引用关系。</p><p>安全点的选定，即不能太少，导致 GC 等待时间太长，也不能太频繁，会导致频繁的 GC。最好是选定在某些执行时间比较长的指令处，比如方法调用、循环跳转、异常跳转等。</p><p>由于安全点不能随意选定，所以带来的新的问题是，在 GC 发生时，如何让所有的线程都运行到安全点的位置。<br>有一种称为“主动式中断（Voluntary Suspension）”的方式，它的基本原理是，当 GC 发生时，设置一个标志。所有的线程当运行到安全点的位置时，访问这个标志，如果为真则自己中断挂起。目前绝大多数 JVM 都是采用的这种方式。</p><p>还有另外一种几乎没有被采用过的“抢先式中断（Preemptive Suspension）”的方式。这种方式是，当 GC 发生时，中断所有线程，如果发现有线程不在安全点上，会再次恢复线程的运行，让它运行到安全点的位置再次中断。</p><h3 id="4-3-Safe-Region"><a href="#4-3-Safe-Region" class="headerlink" title="4.3 Safe Region"></a>4.3 Safe Region</h3><p>使用安全点似乎已经解决了绝大部分问题，但是还有一个比较小的特例。比如，当某个线程处于 Sleep 或者 Blocked 状态时，不能够访问 GC 设置的标志，也没办法运行到安全点的位置（因为 Sleep 的线程无法运行）。而且，JVM 也不太可能等着这个线程恢复执行，运行到安全点的时候再次 GC。这种情况下当前 GC 就没办法执行。</p><p>这种情况下就需要使用“安全区域（Safe Region）”来解决。安全区域是指在一段代码片段之中，引用关系不会发生变化，在这段区域内随时都可以进行 GC。当代码执行到安全区域后，会标识自己进入到了安全区域，这样在进行 GC 时，JVM 就不需要处理这些处于安全区域内的线程了。当线程将要离开安全区域时，会去判断是否已经完成 GC，如果没有完成就中断自己，直到收到可以离开安全区域的信号，才可以继续执行。</p><h2 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h2><p>垃圾收集算法就像是 Java 中的接口一样，而垃圾收集器是接口的具体实现。所以，不同的厂商，不同版本的虚拟机实现的方式都有所不同。甚至是很大的差别。</p><p>下图是常见的 HotSpot 虚拟机中的垃圾收集器。</p><p><img src="/images/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="垃圾收集器"></p><p>其中，新生代有 Serial、ParNew、Parallel Scavenge，老年代包括 CMS、MSC、Parallel old，收集器之间的连线说明两者可以搭配使用。</p><h3 id="5-1-Serial-收集器"><a href="#5-1-Serial-收集器" class="headerlink" title="5.1 Serial 收集器"></a>5.1 Serial 收集器</h3><p>Serial 是最基本，历史最悠久，也是最简单的一个收集器。它是一个单线程的收集器。当它开始进行垃圾回收时，必须暂停其他所有工作线程，直到收集结束。虽然在垃圾回收时会发生“Stop The World”导致用户体验不佳，但是 Serial 收集器还是有优点的，<strong>在单CPU环境下</strong> Serial 收集器由于没有线程操作的开销，只做垃圾收集，所以效率远高于其他收集器。</p><h3 id="5-2-ParNew-收集器"><a href="#5-2-ParNew-收集器" class="headerlink" title="5.2 ParNew 收集器"></a>5.2 ParNew 收集器</h3><p>ParNew 收集器是 Serial 收集器的一个并行版本，与 Serial 的区别在于 STW 期间并行进行垃圾收集。它是大多数 Server 模式下新生代首选的收集器，一个比较重要的原因是，目前只有 ParNew 和 Serial 能与老年代的 CMS 收集器使用。也就是说如果老年代的收集器你选择了 CMS 新生代的收集器就只能从这两者中选择一个。</p><p>需要注意的是，<strong>在单CPC环境中</strong>，由于 ParNew 收集器存在与线程交互的开销，所以效率一定没有 Serial 收集器高。<br>甚至在两个 CPU 的情况下都不能百分之百的保证可以高于 Serial。当然，随着 CPU 的数量增多， ParNew 收集器的性能会越来越好。</p><h3 id="5-3-Parallel-Scavenge-收集器"><a href="#5-3-Parallel-Scavenge-收集器" class="headerlink" title="5.3 Parallel Scavenge 收集器"></a>5.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器是新生代的收集器，采用的是复制算法，并行收集。功能和 ParNew 很类似。其他收集器的关注点都是如何尽可能的缩短 STW 的时间，而 Parallel Scavenge 收集器的目标是控制 STW 占用时间的百分比。这个百分比称为吞吐量。其实就是 用户代码的执行时间与CPU的总执行时间的比值。比如，JVM 总共运行了 100 分钟，而 GC 用了 2 分钟，那么吞吐量就是 98%（ 98/(98+2) ）。使用 Parallel Scavenge 收集器，你可以通过“-XX:GCTimeRatio“参数设置吞吐量的大小。</p><p>GCTimeRatio 参数的值是一个（0，100）闭区间的整数值，含义是垃圾收集时间的占比。相当于吞吐量的倒数。默认值时 99，即最大允许 1%（ 1/(1+99)，的时间用来做垃圾收集。</p><p>还可以通过”-XX:MaxGCPauseMillis“ 参数设置每次 GC 的周期，收集器将<strong>尽可能的</strong>保证垃圾收集的时间不超过该值。不过，不要认为将该值设置的稍微小一点就能使得 GC 的时间更快。GC 的停顿时间是通过牺牲新生代的空间来换来的。新生代空间小了，有可能导致 GC 的次数增多，总体算下来吞吐量有可能不增反减。</p><h3 id="5-4-Serial-Old-收集器"><a href="#5-4-Serial-Old-收集器" class="headerlink" title="5.4 Serial Old 收集器"></a>5.4 Serial Old 收集器</h3><p>Serial Old 收集器是 Serial 收集器的老年代版本，同样是单线程的，使用的是”标记-整理算法“。它的两个主要用途是，一个用于 Client 端。另一个是在 Server 端用于 CMS 收集器的后备预案（详见 CMS 收集器）。</p><h3 id="5-5-Parallel-Old收集器"><a href="#5-5-Parallel-Old收集器" class="headerlink" title="5.5 Parallel Old收集器"></a>5.5 Parallel Old收集器</h3><p>同样，Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法”。需要注意的是，如果老年代使用 Parallel Old 那么新生代就只能使用 Parallel Scavenge 与之配合。在某些吞吐量优先的场景下可以考虑这种组合。</p><h3 id="5-6-CMS-收集器"><a href="#5-6-CMS-收集器" class="headerlink" title="5.6 CMS 收集器"></a>5.6 CMS 收集器</h3><p>重头戏来了。CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它是一种多线程的”标记-清除算法“收集器。目前主流 Java 应用的服务器端使用的都是这种收集器，在尤其重视服务的相应速度的场景下可以考虑使用 CMS 收集器。</p><p>CMS 的收集过程主要有下面四个步骤：</p><ul><li><p>初始标记（CMS initial mark）</p><p>  初始标记主要是枚举根节点，这一步需要 STW。不过这一步仅仅标记 GC Roots，所以时间很短。</p></li><li><p>并发标记（CMS concurrent mark）</p><p>  并发标记阶段主要进行可达性分析，这一步不需要 STW，所以 GC 线程是与用户线程并行的。</p></li><li><p>重新标记（CMS remark）</p><p>  这已阶段主要是修正并发标记时对象的引用关系发生变化的部分。需要 STW，时间也比初始标记阶段长一点。幸运的是这一过程是多线程并行的。</p></li><li><p>并发清除（CMS concurrent sweep）</p><p>  清除标记的对象，这一步也不需要 STW，GC 线程与用户线程是并行的。</p></li></ul><p><img src="/images/CMS-%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS-收集器"></p><p>CMS 收集器虽然通过并发的技术，降低了用户线程的停顿时间，但是也有一些不足。比如最明显的一个缺点就是，它使用的是”标记-清除算法“，如果你还记得这种算法，就应该知道，它有一个最明显的问题就是会产生大量的内存碎片。往往老年代明明有很大的空间，但是无法找到连续的空间分配对象，不得不提前触发 Full GC。</p><p>为了解决这个问题， CMS 提供了 -XX:+UseCMSCompactAtFullCollection 开关参数（默认开启）用于开启内存碎片的整理过程，遗憾的是，这个整理过程依然需要 STW，内存碎片没有了，但是停顿时间也变长了。JVM 还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction 这个参数可以设置一个整数值，表示执行多少次 Full GC 后进行一次碎片整理，默认为 0 (表示每次 Full GC 时都会进行碎片整理)。</p><p>由于 CMS 收集器是与用户线程并行的，所以带来的另一个问题就是占用了部分 CPU 的资源，导致应用程序变慢。目前，CMS 默认启动的回收线程数是（CPU数量+3）/4，也就是说，如果你的 CPU 个数 小于 4，可能对用户线程影响较大。但是对于大型的 Java 应用程序部署的服务器，动辄十几甚至几十个 CPU 来说，这个问题带来的影响越来越小。</p><p>CMS 最后一个问题出现在并发清理的过程。由于程序是一直在运行，所以在清理过程中也会产生垃圾。这部分垃圾出现在标记之后，所以没办法在这一次的 GC 过程中清理掉，只能留在下次 GC 时清理。</p><p>由于在垃圾收集阶段，有用户线程在运行，所以不能等到老年代的内存被填满之后再进行 GC,需要剩余一部分空间用于在 GC 期间的对象创建。可以通过 -XX:CMSInitiatingOccupancyFraction 参数来设置一个百分比，当老年代的使用率达到多少时触发 GC，默认值是 92%，就是说当老年代的使用率超过这个值就会触发 GC。</p><p>如果在 GC 期间，剩余的内存不足以满足用户线程的需要，那么就会发生“Concurrent Mode Failure”失败，这时 JVM 就会临时启用 Serial Old 收集器来做垃圾收集，同时，STW 的停顿时间也会变长。所以，如果 CMSInitiatingOccupancyFraction 参数设置的过高就会触发大量的”Concurrent Mode Failure“出现。</p><h3 id="5-7-G1-收集器"><a href="#5-7-G1-收集器" class="headerlink" title="5.7 G1 收集器"></a>5.7 G1 收集器</h3><p>G1 收集器是面向服务端的一款垃圾收集器。其设计目标是为了取代 CMS 收集器的。G1 收集器有内存整理的过程，所以不会产生内存碎片，而且 STW 的停顿时间更加可控，G1 收集器添加了预测机制，用户可以指定停顿时间。</p><h3 id="5-7-1-Region"><a href="#5-7-1-Region" class="headerlink" title="5.7.1 Region"></a>5.7.1 Region</h3><p>在传统的垃圾收集器中，新生代和老年代的内存是连续的。而在 G1 收集器虽然保留了新生代和老年代，但是他们的内存可以是不连续的。G1 收集器把内存划分为一个个的 Region，新生代和老年代由许多不连续的 Region 组成。</p><p><img src="/images/G1%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="G1内存划分"></p><center>图片来源:https://tech.meituan.com/2016/09/23/g1.html</center><p>可以看到，虽然保留了新生代和老年代的概念，但是二者之间不再是物理隔离了。而是由不同的 Region 构成。在 G1 收集器之前的其他收集器都是在整个新生代，或者老年代范围内进行垃圾收集，G1 收集器则是在 Region 内进行。G1 收集器会维护一个优先列表，根据回收时间，优先回收价值最大的 Region。G1 收集器的内存碎片整理也是在两个不同的 Region 之间通过”复制“算法进行的。</p><p>可以通过 -XX:G1HeapRegionSize设定一个 Region 的大小，取值范围从1M到32M，且是2的指数。</p><h3 id="5-7-2-Remembered-Set"><a href="#5-7-2-Remembered-Set" class="headerlink" title="5.7.2 Remembered Set"></a>5.7.2 Remembered Set</h3><p>我们之前说过 GC 是发生在新生代或者是老年代的。但是在进行可达性分析时，我们似乎有意避开了一个特殊的情况。如果老年代的对象引用了新生代的对象，那么在进行 新生代的 GC 时，我们需要进行整个老年代的扫描，获取引用关系，停顿时间将大大提高。</p><p>其实 JVM 并没有在新生代 GC 时扫描整个老年代。而是利用了空间换时间的办法。JVM 使用了一种叫卡表(Card Table)的数据结构来记录老年代对象到新生代的引用，当一个对象的引用关系发生改变时，首先去更新这张表（这个动作称为 Write Barrier 或者叫写屏障）。这样，在新生代进行 GC 时可以扫描这张表获取引用关系，而不必扫描整个老年代。</p><p>同样的问题，在 G1 收集器里也会出现。如果出现跨 Region 之间的引用关系，就需要扫描所有的 Region 了。与卡表类似，在 G1 收集器里出现了 Remembered Set，它的主要功能就是解决跨 Region 的引用问题。在 G1 中每一个 Region 都有一个与之对应的 Remembered Set，在进行引用类型的写操作时，同样会产生写屏障，然后会检查是否属于两个不同的 Region，如果是的话，会将卡表里的信息同步到对应的 Remembered Set 中，同样在进行 GC 时，只要扫描 Remembered Set 就可以了。</p><h3 id="5-7-3-GC-过程"><a href="#5-7-3-GC-过程" class="headerlink" title="5.7.3 GC 过程"></a>5.7.3 GC 过程</h3><p>G1 的收集过程与 CMS 很相似。主要分为 4 个步骤：</p><ul><li><p>初始标记（Initial Marking）</p><p>  初始阶段标记 GC Roots 能直接关联到的对象。这一阶段需要停顿线程，但是耗时较短。</p></li><li><p>并发标记（Concurrent Marking）  </p><p>  这一阶段是进行对象的可达性分析。耗时较长，但是可以与用户线程并行。</p></li><li><p>最终标记（Final Marking）</p><p>  同样，这一阶段是为了修正在并发标记时用户线程变更的内容。其实是 JVM 把并发标记阶段的变更都记录在了 Remembered Set Logs 里，在这一阶段只要把 Remembered Set Logs 的数据合并到 Remembered Set 里就可以了。这一阶段需要停顿线程，但是可以并行标记。</p></li><li><p>筛选回收（Live Data Counting and Evacuation）</p><p>  这一阶段首先对各个 Region 进行排序，然后根据设定的停顿时间来定制回收计划。最后进行垃圾回收。</p></li></ul><p><img src="/images/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="G1收集器"></p><h2 id="6-GC-日志"><a href="#6-GC-日志" class="headerlink" title="6. GC 日志"></a>6. GC 日志</h2><p>每一种 GC 收集器都有自己的日志格式，但是 JVM 的设计者为了方便阅读，将收集器的日志维持了一些共性。例如下面这段日志：</p><pre><code>33.125:[GC[DefNew:3324K-＞152K（3712K），0.0025925 secs]3324K-＞152K（11904K），0.0031680 secs]100.667:[Full GC[Tenured:0 K-＞210K（10240K），0.0149142secs]4603K-＞210K（19456K），[Perm:2999K-＞2999K（21248K）]，0.0150007 secs][Times:user=0.01 sys=0.00，real=0.02 secs]</code></pre><ol><li><p>GC 与 Full GC</p><p> Full GC 代表的是存在 STW ，GC 代表不存在 STW</p></li><li><p>DefNew、Tenured，Perm</p><p> 表示 GC 发生的区域，与使用的 GC 收集器有关。Serial 收集器的新生代是”DefNew“，ParNew 收集器的新生代是”ParNew“，Parallel Scavenge 的新生代是”PSYoungGen“。同样，老年代也有不同的名字。</p></li><li><p>3324K-＞152K（11904K）</p><p> 经过这次 GC 之后，该区域内存的变化，括号内的值是该区域的总内存大小。</p></li><li><p>0.0031680 secs</p><p> 这次 GC 的耗时。</p></li></ol><p>其实，有许多可视化的工具可以很好的分析 GC 日志，比如 GChisto、GC Easy等，大部分时间是不需要我们直接阅读 GC 日志的。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><ul><li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li><li><a href="https://tech.meituan.com/2016/09/23/g1.html">Java Hotspot G1 GC的一些关键技术</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(十四) 整合 Guava</title>
      <link href="20190909.html"/>
      <url>20190909.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="0-Guava"><a href="#0-Guava" class="headerlink" title="0. Guava"></a>0. Guava</h2><p><a href="https://github.com/google/guava"><strong>Guava</strong></a> 工程包含了若干被Google的 Java项目广泛依赖的核心库。或者说是 Google 工程师的瑞士军刀。Guava 里包含了集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。</p><p>想要使用 Guava 首先需要添加依赖。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;28.1-jre&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="1-Optional"><a href="#1-Optional" class="headerlink" title="1. Optional"></a>1. Optional</h2><p>Guava 用 Optional表示可能为 null 的 T 类型引用。一个 Optional 实例可能包含非 null 的引用（我们称之为引用存在），也可能什么也不包括（称之为引用缺失）。它从不说包含的是 null 值，而是用存在或缺失来表示。但 Optional 从不会包含 null 值引用。</p><h3 id="1-1-简单使用"><a href="#1-1-简单使用" class="headerlink" title="1.1 简单使用"></a>1.1 简单使用</h3><p>当某个方法有可能返回 null 值时候，我们可以返回一个 Optional 的泛型对象。代码如下：</p><pre><code>    /**     * 使用 empty 代替 null     *     * @param num     * @return     */    private Optional&lt;Integer&gt; getNum(int num) &#123;        if (num &gt; 0) &#123;            return Optional.of(num);        &#125; else &#123;            //使用 empty 代替 null            return Optional.empty();        &#125;    &#125;    public void testGetNum() &#123;        Optional&lt;Integer&gt; num = this.getNum(5);        if (num.isPresent()) &#123;            System.out.println(num.get());        &#125;        //也可以使用 ifPresent 方法        num.ifPresent(new Consumer&lt;Integer&gt;() &#123;            @Override            public void accept(Integer integer) &#123;                System.out.println(integer);            &#125;        &#125;);    &#125; </code></pre><p>使用 <code>Optional.of()</code> 来创建一个可用对象，使用 <code>Optional.empty();</code> 来创建一个不可引用的对象。用来替代之前直接返回 null 的情况。</p><p>使用 Optional 时，可以通过<code>Optional.isPresent()</code>方法，或者是<code>Optional.ifPresent()</code>方法来使用。</p><h3 id="1-2-使用-filter-方法"><a href="#1-2-使用-filter-方法" class="headerlink" title="1.2 使用 filter 方法"></a>1.2 使用 filter 方法</h3><p>可以使用 filter 方法 对返回结果做二次判断。</p><ol><li>使用<code>Predicates.in()</code> 方法，判断返回结果是否在集合内。</li></ol><pre><code>    public static void testIn()&#123;        List&lt;AccountInfo&gt; data = new ArrayList&lt;&gt;();        AccountInfo accountInfo = new AccountInfo();        accountInfo.setName(&quot;aaa&quot;);        accountInfo.setBalance(123);        data.add(accountInfo);        AccountInfo accountInfo2 = new AccountInfo();        accountInfo2.setName(&quot;aaa&quot;);        accountInfo2.setBalance(123);        System.out.println(&quot;equals：&quot;+accountInfo.equals(accountInfo2));        Optional&lt;AccountInfo&gt; optional = Optional.of(accountInfo2);        //通过 调用对象的 equals 方法来判断是否存在        optional.filter(Predicates.in(data)).ifPresent(new Consumer&lt;AccountInfo&gt;() &#123;            @Override            public void accept(AccountInfo accountInfo) &#123;                System.out.println(&quot;1：&quot;+accountInfo.toString());            &#125;        &#125;);    &#125;</code></pre><p>in 方法调用的是对象的 equals 方法，所以如果对象的 equals 方法返回 true，那么就会访问到该对象，否则就访问不到。</p><p>Predicates 类还有一些其他方法，用于过滤 Optional 对象。可以参考 Predicates 的API。</p><h2 id="2-Preconditions"><a href="#2-Preconditions" class="headerlink" title="2. Preconditions"></a>2. Preconditions</h2><p>Guava 在 Preconditions 类中提供了若干前置条件判断的实用方法。这些方法让调用的前置条件判断更简单。</p><pre><code>    /**     * 检查参数是否为 true     * @param attr     */    private static void testAttrs(boolean attr)&#123;        Preconditions.checkArgument(attr,&quot;参数错误&quot;);    &#125;    /**     * 检查参数是否为 null     * @param accountInfo     */    private static void testAttr2(AccountInfo accountInfo) &#123;        Preconditions.checkNotNull(accountInfo, &quot;参数不能为 null&quot;);    &#125;    /**     * 检查索引是否越界     * @param index     * @param size     */    private static void testAttr3(int index, int size) &#123;        Preconditions.checkElementIndex(index, size);    &#125;    /**     * 检查区间是否越界     * @param start     * @param end     * @param size     */    private static void testAttr4(int start,int end, int size) &#123;        Preconditions.checkPositionIndexes(start,end, size);    &#125;    public static void main(String[] args) &#123;        //testAttrs(Boolean.FALSE);        //testAttr2(null);        //testAttr3(3, 2);        testAttr4(2, 4, 3);    &#125;</code></pre><p>Guava 建议直接静态导入，就不用 Preconditions.checkArgument(), 来调用了，直接使用 checkArgument(),比较简洁。</p><h2 id="3-Ordering"><a href="#3-Ordering" class="headerlink" title="3. Ordering"></a>3. Ordering</h2><p>排序器[Ordering]是 Guava 流畅风格比较器[Comparator]的实现，它可以用来为构建复杂的比较器，以完成集<br>合排序的功能。</p><p>Guava 提供了 3 中常见的比较器。</p><ul><li>Ordering.natural()</li></ul><p>默认比较器，针对可比较对象。</p><ul><li>Ordering.usingToString()</li></ul><p>使用字符串的字典顺序排序。</p><ul><li>Ordering.arbitrary()</li></ul><p>插入顺序的倒序。</p><p>还可以根据 Comparator 生成 <code>Ordering.from(Comparator)</code>。</p><p>或者自定义比较器：</p><pre><code>    private static void lengthOrdering(List&lt;String&gt; list) &#123;        Ordering&lt;String&gt; lengthOrdering = new Ordering&lt;String&gt;() &#123;            @Override            public int compare(@Nullable String left, @Nullable String right) &#123;                return left.length() - right.length();            &#125;        &#125;;        list.sort(lengthOrdering);        //倒序        list.sort(lengthOrdering.reverse());    &#125;</code></pre><p>如果要根据对象的某个具体的属性排序，可以使用 onResultOf 方法。</p><pre><code>   private static void lengthOrdering2(List&lt;AccountInfo&gt; list) &#123;        Ordering&lt;AccountInfo&gt; lengthOrdering = Ordering.natural().nullsFirst().onResultOf(new Function&lt;AccountInfo, Integer&gt;() &#123;            @Nullable            @Override            public Integer apply(@Nullable AccountInfo accountInfo) &#123;                return accountInfo.getBalance();            &#125;        &#125;);        list.sort(lengthOrdering);        //倒序        list.sort(lengthOrdering.reverse());    &#125;</code></pre><p><strong>注意：这里跟平常的链式调用的不同是，执行顺序是从后往前执行！！！</strong>比如上面的例子。</p><pre><code>Ordering.natural().nullsFirst().onResultOf()</code></pre><p>首先执行 onResultOf 获取所有对象的 balance 值，然后将 null 值排在最前，然后再按照数字顺序排序。</p><p>Ordering 还提供了一些集合遍历、迭代的方法。比如：</p><ul><li>greatestOf(Iterableiterable, int k)</li></ul><p>获取最大的 k 个元素</p><ul><li>min(Iterable) </li></ul><p>获取最小的一个元素</p><ul><li>isOrdered(Iterable)  </li></ul><p>判断对象是否按照给定的排序器排序</p><h2 id="4-Collections"><a href="#4-Collections" class="headerlink" title="4. Collections"></a>4. Collections</h2><h3 id="4-1-不可变集合"><a href="#4-1-不可变集合" class="headerlink" title="4.1 不可变集合"></a>4.1 不可变集合</h3><p>创建对象的不可变拷贝是一项很好的防御性编程技巧。Guava 为所有 JDK 标准集合类型和 Guava 新集合类型都提供了简单易用的不可变版本。</p><p>使用方式：</p><pre><code>    public static void testImmutable()&#123;        ImmutableSet&lt;String&gt; immutableSet = ImmutableSet.&lt;String&gt;builder().add(&quot;c&quot;)                .add(&quot;b&quot;).build();        for (String s : immutableSet) &#123;            System.out.print(s + &quot;,&quot;);        &#125;    &#125;</code></pre><p>Guava 还提供了有序的不可变集合。</p><pre><code>    private static void testSort()&#123;        ImmutableSortedSet&lt;String&gt; immutableSortedSet = ImmutableSortedSet.of(&quot;c&quot;, &quot;a&quot;, &quot;b&quot;);        for (String s:immutableSortedSet) &#123;            System.out.print(s + &quot;,&quot;);        &#125;    &#125;</code></pre><h3 id="4-2-新集合类型"><a href="#4-2-新集合类型" class="headerlink" title="4.2 新集合类型"></a>4.2 新集合类型</h3><ul><li>Multiset</li></ul><p>Guava 提供了一个新集合类型 Multiset ，它可以多次添加相等的元素。你可以将 Multiset 类比成 Map&lt;E, Integer&gt;，键为元素，值为计数的一个 Map 集合。添加相同元素会增加计数，删除元素会减少计数。</p><pre><code>    private static void testMultiset()&#123;        Multiset&lt;String&gt; multiset = HashMultiset.create();        multiset.add(&quot;a&quot;);        multiset.add(&quot;a&quot;);        multiset.add(&quot;b&quot;);        multiset.add(&quot;c&quot;);        multiset.setCount(&quot;b&quot;, 3);        System.out.println(multiset.contains(&quot;a&quot;));        System.out.println(multiset.count(&quot;a&quot;));        System.out.println(multiset.remove(&quot;b&quot;));        System.out.println(multiset.count(&quot;b&quot;));        System.out.println(multiset.size());    &#125;</code></pre><p>当然，Guava 还提供了 TreeMultiset、LinkedHashMultiset、ConcurrentHashMultiset、ImmutableMultiset<br>的实现，需要注意的是，这些类都提供了 create 方法，所以尽量不要使用 new 来创建对象。更贴心的是，Guava 还提供了一个 SortedMultiset ,默认排序。</p><pre><code>    private static void testSortMultiset()&#123;        SortedMultiset&lt;Integer&gt; multiset = TreeMultiset.create();        multiset.addAll(Lists.newArrayList(3, 2, 5, 6, 9, 2, 5, 6, 8));        for (int num:multiset) &#123;            System.out.print(num + &quot;,&quot;);        &#125;    &#125;</code></pre><ul><li>Multimap</li></ul><p>Guava 的 Multimap 可以很容易地把一个键映射到多个值。换句话说，Multimap 是把键映射到任意多个值的一般方式。你可以将 Multimap 类比成 Map&lt;K, List&gt; 或 Map&lt;K, Set&gt;。</p><pre><code>    private static void testMultimap()&#123;        Multimap&lt;String, Integer&gt; multimap = ArrayListMultimap.create();        multimap.put(&quot;a&quot;, 1);        multimap.put(&quot;a&quot;, 2);        multimap.put(&quot;a&quot;, 3);        multimap.put(&quot;a&quot;, 4);        System.out.println(multimap.containsKey(&quot;a&quot;));        System.out.println(multimap.containsEntry(&quot;a&quot;, 1));        System.out.println(multimap.containsEntry(&quot;a&quot;, 0));        System.out.println(multimap.remove(&quot;a&quot;, 3));        System.out.println(Arrays.deepToString(multimap.get(&quot;a&quot;).toArray()));    &#125;</code></pre><p>Multimap 还提供了若干个视图</p><ul><li>multimap.asMap()</li></ul><p>返回一个 Map&lt;K,Collection&gt;形式的视图。</p><ul><li>multimap.entries()</li></ul><p>返回一个 Collection&lt;Map.Entry&lt;K, V&gt;&gt; 包含所有的键值对。</p><ul><li>multimap.keySet()</li></ul><p>返回一个 Set<K> 集合，包含所有<strong>不重复</strong>的键</p><ul><li>multimap.keys()</li></ul><p>返回一个 Multiset<K> 包含所有的 key。</p><ul><li>multimap.values()</li></ul><p>返回一个 Collection<V> 包含所有的 value</p><p>Multimap 的具体实现类包括 ArrayListMultimap、HashMultimap、TreeMultimap、ImmutableListMultimap 等。</p><ul><li>BiMap</li></ul><p>BiMap 是一个特殊的 Map ，可以用 inverse()反转 BiMap&lt;K, V&gt;的键值映射。所以，在插入值时需要注意，保证值时唯一的。强制将某个值插入到 BiMap 中，会更新该值对应的 key。</p><pre><code>    private static void testBiMap()&#123;        BiMap&lt;String, Integer&gt; biMap = HashBiMap.create();        biMap.put(&quot;a&quot;, 1);        biMap.put(&quot;b&quot;, 2);        System.out.println(biMap.inverse().get(2));        biMap.forcePut(&quot;c&quot;, 2);        System.out.println(biMap.inverse().get(2));    &#125;</code></pre><p>BiMap 的常见实现类 HashBiMap、ImmutableBiMap、EnumBiMap、EnumHashBiMap。</p><ul><li>other<br>还有一些不常用到的集合类，比如 </li></ul><ol><li>Table: 集合，可以根据行和列来存储和检索具体的值。</li><li>ClassToInstanceMap: 是一个类型 Map，它的键是类型，而值是符合键所指类型的对象。</li><li>RangeSet: 描述了一组不相连的区间。当把一个区间添加到可变的RangeSet时，所有相连的区间会被合并</li><li>RangeMap: 将一个区间映射到一个对应的 value 上</li></ol><h2 id="5-collection-utilities"><a href="#5-collection-utilities" class="headerlink" title="5. collection utilities"></a>5. collection utilities</h2><p>Guava 提供了大量的集合工具。包括 Lists、Maps、Sets 等等。</p><h3 id="5-1-静态工厂方法。"><a href="#5-1-静态工厂方法。" class="headerlink" title="5.1 静态工厂方法。"></a>5.1 静态工厂方法。</h3><p>Guava 提供了能够推断范型的静态工厂方法。</p><pre><code>     private static void testUtil1()&#123;        List&lt;AccountInfo&gt; accountInfoList = Lists.newArrayList();        List&lt;AccountInfo&gt; accountInfoList2 = Lists.newArrayListWithCapacity(3);        List&lt;AccountInfo&gt; accountInfoList3 = Lists.newArrayListWithExpectedSize(3);        List&lt;AccountInfo&gt; accountInfoList4 = Lists.newArrayList(new AccountInfo());    &#125;</code></pre><h3 id="5-2-Iterables"><a href="#5-2-Iterables" class="headerlink" title="5.2 Iterables"></a>5.2 Iterables</h3><p>Iterables 提供了一些集合操作的方法。</p><pre><code>    private static void testUtil1()&#123;        List&lt;AccountInfo&gt; accountInfoList = Lists.newArrayList();        List&lt;AccountInfo&gt; accountInfoList2 = Lists.newArrayListWithCapacity(3);        List&lt;AccountInfo&gt; accountInfoList3 = Lists.newArrayListWithExpectedSize(3);        List&lt;AccountInfo&gt; accountInfoList4 = Lists.newArrayList(new AccountInfo());        Iterable&lt;Integer&gt; concatenated = Iterables.concat(Ints.asList(1, 2, 3),                Ints.asList(3, 4, 5));        System.out.println(Iterables.frequency(concatenated, 3));        System.out.println(Iterables.getFirst(concatenated, 0));    &#125;</code></pre><ul><li>concat(Iterable<Iterable>)</li></ul><p>串联多个 iterables 的懒视图</p><ul><li>frequency(Iterable, Object)</li></ul><p>返回对象在 iterable 中出现的次数</p><ul><li>partition(Iterable, int)</li></ul><p>把 iterable 按指定大小分割，得到的子集都不能进行修改操作</p><ul><li>getFirst(Iterable, T default)</li></ul><p>返回 iterable 的第一个元素，若 iterable 为空则返回默认值</p><ul><li>getLast(Iterable)</li></ul><p>返回 iterable 的最后一个元素，若 iterable 为空则抛出NoSuchElementException</p><ul><li>elementsEqual(Iterable, Iterable)</li></ul><p>如果两个 iterable 中的所有元素相等且顺序一致，返回 true</p><ul><li>unmodifiableIterable(Iterable)</li></ul><p>返回 iterable 的不可变视图</p><ul><li>limit(Iterable, int)</li></ul><p>限制 iterable 的元素个数限制给定值</p><ul><li>getOnlyElement(Iterable)</li></ul><p>获取 iterable 中唯一的元素，如果 iterable 为空或有多个元素，则快速失败</p><h3 id="5-2-Sets"><a href="#5-2-Sets" class="headerlink" title="5.2 Sets"></a>5.2 Sets</h3><p>Guava 提供了很多标准的集合运算的方法。比如集合间的交集、并集、补集等</p><ul><li>Sets.union()</li></ul><p>返回两个集合的并集，并去除重复元素</p><ul><li>Sets.intersection()</li></ul><p>返回两个集合的交集</p><ul><li>Sets.difference(set1,set2)</li></ul><p>返回 set1 中，不存在在 set2 中的元素,或者说是 set2 在 set1 中的绝对补集</p><pre><code>    private static void testSets() &#123;        Set&lt;Integer&gt; set = Sets.union(Sets.newHashSet(1, 2, 3), Sets.newHashSet(3, 4, 5));        System.out.println(Arrays.deepToString(set.toArray()));        Set&lt;Integer&gt; set2 = Sets.intersection(Sets.newHashSet(1, 2, 3), Sets.newHashSet(3, 4, 5));        System.out.println(Arrays.deepToString(set2.toArray()));        Set&lt;Integer&gt; set3 = Sets.difference(Sets.newHashSet(1, 2, 3), Sets.newHashSet(1,2));        System.out.println(Arrays.deepToString(set3.toArray()));    &#125;</code></pre><h3 id="5-3-Maps"><a href="#5-3-Maps" class="headerlink" title="5.3 Maps"></a>5.3 Maps</h3><p>Maps 里有两个比较有意思的方法。</p><ul><li>Maps.filterKeys() / Maps.filterEntries</li></ul><p>根据给定的规则过滤键值对</p><ul><li>Maps.difference</li></ul><p>用来比较两个 Map 以获取所有不同点。</p><ul><li>Maps.uniqueIndex</li></ul><p>这个方法可以将一个 Iterable 对象 转成 Map 集合。</p><p><strong>PS: 有点没看懂这个方法，有了解的朋友可以留言</strong></p><pre><code>    private static void testMaps() &#123;        Map&lt;String, Integer&gt; hashMap = Maps.newHashMap();        hashMap.put(&quot;a&quot;, 1);        hashMap.put(&quot;bb&quot;, 2);        hashMap.put(&quot;ccc&quot;, 3);        Map&lt;String, Integer&gt; hashMap1 = Maps.filterKeys(hashMap, new Predicate&lt;String&gt;() &#123;            @Override            public boolean apply(@Nullable String input) &#123;                return input.length() &gt; 2;            &#125;        &#125;);        System.out.println(Arrays.deepToString(hashMap1.entrySet().toArray()));        Map&lt;String, Integer&gt; hashMap2 = Maps.filterEntries(hashMap, new Predicate&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;            @Override            public boolean apply(Map.@Nullable Entry&lt;String, Integer&gt; input) &#123;                return input.getValue() &gt; 2;            &#125;        &#125;);        System.out.println(Arrays.deepToString(hashMap2.entrySet().toArray()));        Map&lt;Integer, String&gt; hashMap3 = Maps.uniqueIndex(Lists.newArrayList(&quot;sss&quot;, &quot;ss&quot;, &quot;ssss&quot;),                new Function&lt;String, Integer&gt;() &#123;                    @Nullable                    @Override                    public Integer apply(@Nullable String input) &#123;                        return input.length();                    &#125;                &#125;);        System.out.println(Arrays.deepToString(hashMap3.entrySet().toArray()));        Map&lt;String, Integer&gt; left = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3);        Map&lt;String, Integer&gt; right = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3);        MapDifference&lt;String, Integer&gt; diff = Maps.difference(left, right);        diff.entriesInCommon(); // &#123;&quot;b&quot; =&gt; 2&#125;        diff.entriesInCommon(); // &#123;&quot;b&quot; =&gt; 2&#125;        diff.entriesOnlyOnLeft(); // &#123;&quot;a&quot; =&gt; 1&#125;        diff.entriesOnlyOnRight(); // &#123;&quot;d&quot; =&gt; 5&#125;MapDifference    &#125;</code></pre><h3 id="5-3-Forwarding"><a href="#5-3-Forwarding" class="headerlink" title="5.3 Forwarding"></a>5.3 Forwarding</h3><p>针对所有类型的集合接口，Guava 都提供了 Forwarding 抽象类以简化装饰者模式的使用</p><pre><code>    private static void testForwarding()&#123;        ForwardingList&lt;String&gt; forwardingList = new ForwardingList&lt;String&gt;() &#123;            final List&lt;String&gt; delegate = new ArrayList&lt;&gt;(); // backing list            @Override            protected List&lt;String&gt; delegate() &#123;                return delegate;            &#125;            @Override            public void add(int index, String element) &#123;                System.out.println(&quot;add:&quot; + element);                super.add(index, element);            &#125;            @Override            public String get(int index) &#123;                System.out.println(&quot;get:&quot; + index);                return super.get(index);            &#125;        &#125;;        forwardingList.add(0,&quot;aaa&quot;);        System.out.println(forwardingList.get(0));    &#125;</code></pre><p>类似于我们对 List 做了一层装饰（或者说说封装），在执行 List 的相关方法时，可以做一些其他的处理。</p><p>当然也可以通过一个类，来实现 Forwarding 的相关接口，比如：</p><pre><code>    class AddLoggingList&lt;E&gt; extends ForwardingList&lt;E&gt; &#123;        final List&lt;E&gt; delegate; // backing list        @Override protected List&lt;E&gt; delegate() &#123;            return delegate;        &#125;        @Override public void add(int index, E elem) &#123;            log(index, elem);            super.add(index, elem);        &#125;        @Override public boolean add(E elem) &#123;            return standardAdd(elem); // 用add(int, E)实现        &#125;        @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123;            return standardAddAll(c); // 用add实现        &#125;    &#125;</code></pre><p>上面的 AddLoggingList 在使用时与普通的 ArrayList 并没有什么区别，唯一的区别是，使用 AddLoggingList 时，添加元素会打印出相应的 log。</p><h2 id="6-Caches"><a href="#6-Caches" class="headerlink" title="6. Caches"></a>6. Caches</h2><p>通常来说，Guava Cache 适用于：</p><ul><li>你愿意消耗一些内存空间来提升速度。</li><li>你预料到某些键会被查询一次以上。</li><li>缓存中存放的数据总量不会超出内存容量。</li></ul><p>如果你的场景符合上述的每一条，Guava Cache 就适合你。</p><h3 id="6-1-LoadingCache"><a href="#6-1-LoadingCache" class="headerlink" title="6.1 LoadingCache"></a>6.1 LoadingCache</h3><pre><code>    private static LoadingCache&lt;String, AccountInfo&gt; loadingCache = CacheBuilder.newBuilder()            //最大缓存数量            .maximumSize(10).build(new CacheLoader&lt;String, AccountInfo&gt;() &#123;                @Override                public AccountInfo load(String key) throws Exception &#123;                    System.out.println(&quot;load 方法执行：&quot; + key);                    AccountInfo accountInfo = new AccountInfo();                    accountInfo.setName(key);                    return accountInfo;                &#125;            &#125;);    private static void testCaches() throws ExecutionException &#123;        //如果缓存中没有该值，就会添加新值        loadingCache.get(&quot;aaa&quot;).setBalance(123);        System.out.println(loadingCache.get(&quot;aaa&quot;));    &#125;</code></pre><p>可以通过 Builder 来创建一个缓存对象(或者叫本地缓存池)。可以设定缓存对象的一些基本参数，比如最大数量等。</p><p>load 方法用来加载需要缓存的对象。这些对象可以是手动创建的，也可以是从DB、Redis等其他外部存储加载进来的。</p><p>可以直接使用 get() 方法获取 LoadingCache 中的对象。<strong>注意：这里如果在缓存中没有找到对应的值，通过 load 方法创建一个新的值添加到缓存中，并返回该值。</strong></p><p>如果我们不希望 使用默认的 load 方法创建对象。也可以在使用 get 方法时传入一个 Call 对象，用来创建需要缓存的值。</p><pre><code>    private static void testCaches() throws ExecutionException &#123;        //如果缓存中没有该值，就会添加新值        loadingCache.get(&quot;aaa&quot;).setBalance(123);        System.out.println(loadingCache.get(&quot;aaa&quot;));        //如果没有值，就会执行 call 方法，创建对应的值，并返回        AccountInfo accountInfo = loadingCache.get(&quot;bbb&quot;, new Callable&lt;AccountInfo&gt;() &#123;            @Override            public AccountInfo call() throws Exception &#123;                AccountInfo accountInfo = new AccountInfo();                accountInfo.setName(&quot;bbb&quot;);                accountInfo.setPwd(&quot;call-add&quot;);                return accountInfo;            &#125;        &#125;);        System.out.println(accountInfo.toString());    &#125;</code></pre><p>如果你执行了上面的代码，就会发现，获取 “aaa” 时，调用了 load 方法，而获取 “bbb” 时，则没有执行 load 方法。</p><p>也可以直接向缓存中插入值。</p><pre><code>    loadingCache.put(&quot;ccc&quot;,accountInfo);    System.out.println(loadingCache.get(&quot;ccc&quot;));</code></pre><p>不过，尽量优先使用 Cache.get(K, Callable) 方法</p><h3 id="6-2-Eviction"><a href="#6-2-Eviction" class="headerlink" title="6.2 Eviction"></a>6.2 Eviction</h3><p>Guava Cache 提供了三种基本的缓存回收方式：基于容量回收、定时回收和基于引用回收。</p><ul><li>基于容量回收</li></ul><p>我们可以指定缓存的容量，通过 maximumSize() 方法，当超过容量时，缓存将尝试回收最近没有使用或总体上很少使用的缓存项</p><pre><code>    private static LoadingCache&lt;String, AccountInfo&gt; loadingCache = CacheBuilder.newBuilder()            //最大缓存数量            .maximumSize(10).build(new CacheLoader&lt;String, AccountInfo&gt;() &#123;                @Override                public AccountInfo load(String key) throws Exception &#123;                    System.out.println(&quot;load 方法执行：&quot; + key);                    AccountInfo accountInfo = new AccountInfo();                    accountInfo.setName(key);                    return accountInfo;                &#125;            &#125;);</code></pre><p>另外，Guava 缓存还提供了一种根据“权重(weights)” 来删除缓存的方式。你可以使用 CacheBuilder.weigher(Weigher)指定一个权重函数，并且用 CacheBuilder.maximumWeight(long)指定最大总重。</p><p><strong>注意：maximumWeight() 方法与 maximumSize() 方法不能同时使用</strong></p><pre><code>    private static void testEviction() throws ExecutionException &#123;        LoadingCache&lt;String, AccountInfo&gt; cache = CacheBuilder.newBuilder()                //最大缓存数量                //.maximumSize(10)                //最大权重                .maximumWeight(10L)                .weigher(new Weigher&lt;String, AccountInfo&gt;() &#123;                    @Override                    public int weigh(String key, AccountInfo value) &#123;                        return value.getBalance();                    &#125;                &#125;)                .build(new CacheLoader&lt;String, AccountInfo&gt;() &#123;                    @Override                    public AccountInfo load(String key) throws Exception &#123;                        AccountInfo accountInfo = new AccountInfo();                        accountInfo.setName(key);                        return accountInfo;                    &#125;                &#125;);        for (int i = 0; i &lt; 12; i++) &#123;            AccountInfo accountInfo = new AccountInfo();            accountInfo.setName(&quot;aaa&quot; + i);            accountInfo.setBalance(i);            cache.put(accountInfo.getName(), accountInfo);        &#125;        System.out.println(cache.asMap().size());        System.out.println(Arrays.deepToString(cache.asMap().entrySet().toArray()));    &#125;</code></pre><ul><li>定时回收</li></ul><p>CacheBuilder 提供两种定时回收的方法：</p><ol><li>expireAfterAccess(long, TimeUnit)：缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。</li><li>expireAfterWrite(long, TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。</li></ol><ul><li>基于引用的回收</li></ul><p>通过使用弱引用的键、或弱引用的值、或软引用的值，Guava Cache 可以把缓存设置为允许垃圾回收：</p><ol><li>CacheBuilder.weakKeys()：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（==），使用弱引用键的缓存用==而不是 equals 比较键。</li><li>CacheBuilder.weakValues()：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（==），使用弱引用值的缓存用==而不是 equals 比较值。</li><li>CacheBuilder.softValues()：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。考虑到使用软引用的性能影响，我们通常建议使用更有性能预测性的缓存大小限定（见上文，基于容量回收）。使用软引用值的缓存同样用==而不是 equals 比较值。<br>显</li></ol><ul><li>显式清除</li></ul><p>任何时候，你都可以显式地清除缓存项，而不是等到它被回收：</p><ol><li>个别清除：Cache.invalidate(key)</li><li>批量清除：Cache.invalidateAll(keys)</li><li>清除所有缓存项：Cache.invalidateAll()</li></ol><p><strong>注意：这里的清除缓存并不一定会删除元素，准确的说法是将缓存置为无效。如果你调用 Cache.asMap 方法，你会发现，里面的元素并没有少。但是当调用 invalidate() 方法之后，再次调用 get() 方法，会重新执行 load 方法，说明原来的数据已经是无效的了</strong></p><h2 id="7-Strings"><a href="#7-Strings" class="headerlink" title="7. Strings"></a>7. Strings</h2><h3 id="7-1-Joiner"><a href="#7-1-Joiner" class="headerlink" title="7.1 Joiner"></a>7.1 Joiner</h3><p>用分隔符把字符串序列连接起来也可能会遇上不必要的麻烦。如果字符串序列中含有 null，那连接操作会更难。Fluent 风格的 Joiner 让连接字符串更简单。</p><pre><code>    private static void testJoiner()&#123;        //使用 &#39;-&#39; 链接，遇到 null 值用 &#39;#&#39; 代替        Joiner joiner = Joiner.on(&quot;-&quot;).useForNull(&quot;#&quot;);        System.out.println(joiner.join(&quot;aaa&quot;,&quot;bbb&quot;,null,&quot;&quot;,&quot;ccc&quot;));        //忽略空值        joiner = Joiner.on(&quot;-&quot;).skipNulls();        //将拼接好的 String append 到 StringBuilder 之后        StringBuilder sb = Joiner.on(&quot;-&quot;).appendTo(new StringBuilder(&quot;sss&quot;), &quot;aaa&quot;,&quot;bbb&quot;);        System.out.println(sb.toString());    &#125;</code></pre><h3 id="7-2-Splitter"><a href="#7-2-Splitter" class="headerlink" title="7.2 Splitter"></a>7.2 Splitter</h3><p>非常友好的 String 拆分器。</p><pre><code>    private static void testSplitter()&#123;        //使用 ; 分隔，并且忽略结果集中的空字符串，移除结果中的开头和结尾的空白字符        Splitter splitter = Splitter.on(&#39;;&#39;).omitEmptyStrings().trimResults();        Iterable&lt;String&gt; arr = splitter.split(&quot;a;aa ;  a ;;;&quot;);        for (String str : arr) &#123;            System.out.print(str+&quot;,&quot;);        &#125;        System.out.println();        //按照固定长度拆分        arr = Splitter.fixedLength(3).split(&quot;aaabbbcccdd&quot;);        for (String str : arr) &#123;            System.out.print(str+&quot;,&quot;);        &#125;        System.out.println();    &#125;</code></pre><h3 id="7-3-CharMatcher"><a href="#7-3-CharMatcher" class="headerlink" title="7.3 CharMatcher"></a>7.3 CharMatcher</h3><p>CharMatcher 实例代表着某一类字符，如数字或空白字符。使用 CharMatcher 的好处更在于它提供了一系列方法，让你对字符作特定类型的操作：修剪[trim]、折叠[collapse]、移除[remove]、保留[retain]等等。</p><pre><code>    private static void testCharMatcher()&#123;        //去掉控制字符（回车、换行、tab等）        String noControl = CharMatcher.javaIsoControl().removeFrom(&quot;aa\tbb\ncc\\d\\.&quot;);        System.out.println(noControl);        String theDigits = CharMatcher.inRange(&#39;0&#39;, &#39;9&#39;).retainFrom(&quot;1a2b3c4d&quot;);        System.out.println(theDigits);        //去除两端的空格，并把中间的连续空格替换成 &#39;-&#39;        String spaced = CharMatcher.whitespace().trimAndCollapseFrom(&quot;aaaa   bbb cc  &quot;, &#39;-&#39;);        System.out.println(spaced);        //用*号替换所有数字        String noDigits = CharMatcher.inRange(&#39;0&#39;, &#39;9&#39;).replaceFrom(&quot;1a2b3c4d&quot;, &quot;*&quot;);        System.out.println(noDigits);        String lowerAndDigit = CharMatcher.inRange(&#39;0&#39;, &#39;9&#39;).or(CharMatcher.javaLowerCase()).retainFrom(&quot;1Aa2Bb3Cc&quot;);        System.out.println(lowerAndDigit);    &#125;</code></pre><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h2><ul><li><a href="http://wiki.jikexueyuan.com/project/google-guava-official-tutorial/">Google Guava 官方教程</a></li><li><a href="https://github.com/google/guava/wiki">Guava wiki</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift 学习笔记</title>
      <link href="20190821.html"/>
      <url>20190821.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Thrift-简介"><a href="#1-Thrift-简介" class="headerlink" title="1. Thrift 简介"></a>1. Thrift 简介</h2><p>Thrift 是有 Facebook 开源的一套 RPC 框架， 支持多种语言，它是通过自身的 中间语言（IDL），并借助代码生成引擎来生成各种主流语言的代码模板</p><h2 id="2-IDL-语言"><a href="#2-IDL-语言" class="headerlink" title="2. IDL 语言"></a>2. IDL 语言</h2><p>Thrift 采用IDL（Interface Definition Language）来定义通用的服务接口，然后通过Thrift提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这个方式来实现跨语言的功能。</p><p>IDL 中有基本类型、结构体类型、容器类型、枚举类型、异常类型、服务类型等六种类型。熟悉了这些常用类型后基本上可以应付日常开发。</p><h3 id="2-1-基本类型："><a href="#2-1-基本类型：" class="headerlink" title="2.1 基本类型："></a>2.1 基本类型：</h3><ul><li>bool: 布尔值</li><li>byte: 8位有符号整数</li><li>i16: 16位有符号整数</li><li>i32: 32位有符号整数</li><li>i64: 64位有符号整数</li><li>double: 64位浮点数</li><li>string: UTF-8编码的字符串</li><li>binary: 二进制串</li></ul><h3 id="2-2-struct（结构体）："><a href="#2-2-struct（结构体）：" class="headerlink" title="2.2 struct（结构体）："></a>2.2 struct（结构体）：</h3><p>类似于 C 语言中的结构体。在 Java 中就是 POJO，struct 类型有以下几个要求：</p><ol><li>struct不能继承，但是可以嵌套，不能嵌套自己。</li><li>其成员都是有明确类型</li><li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。</li><li>成员分割符可以是逗号（,）或是分号（;），而且可以混用</li><li>字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。</li><li>每个字段可以设置默认值</li><li>同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。</li></ol><p>例如：</p><pre><code>struct User&#123;  1: required string name, //改字段必须填写  2: optional i32 age = 0; //默认值  3: bool gender //默认字段类型为optional&#125;</code></pre><h3 id="2-3-Container-容器"><a href="#2-3-Container-容器" class="headerlink" title="2.3 Container (容器)"></a>2.3 Container (容器)</h3><ul><li>list<t>: 元素类型为t的有序表，容许元素重复。对应 Java 的 ArrayList</li><li>set<t>: 元素类型为t的无序表，不容许元素重复。对应 Java 的 HashSet</li><li>map&lt;t, t&gt;: 键类型为t，值类型为t的kv对，键不容许重复。对应 Java 的 HashMap</li></ul><p>例如：</p><pre><code>struct Test &#123;  1: map&lt;string, User&gt; usermap,  2: set&lt;i32&gt; intset,  3: list&lt;double&gt; doublelist&#125;</code></pre><h3 id="2-4-enum-枚举"><a href="#2-4-enum-枚举" class="headerlink" title="2.4 enum (枚举):"></a>2.4 enum (枚举):</h3><p>Thrift不支持枚举类嵌套，枚举常量必须是32位的正整数。</p><p>例如：</p><pre><code>enum HttpStatus &#123;  OK = 200,  NOTFOUND=404&#125;</code></pre><h3 id="2-5-Exception-异常"><a href="#2-5-Exception-异常" class="headerlink" title="2.5 Exception (异常):"></a>2.5 Exception (异常):</h3><p>异常在语法和功能上类似于结构体，不过使用的关键字是 exception。对应 Java 的 Exception</p><p>例如：</p><pre><code>exception MyException &#123;    1: i32 errorCode,    2: string message&#125;</code></pre><h3 id="2-6-Service-服务定义类型"><a href="#2-6-Service-服务定义类型" class="headerlink" title="2.6 Service (服务定义类型):"></a>2.6 Service (服务定义类型):</h3><p>即我们需要提供的服务接口。</p><p>例如：</p><pre><code>service HelloService &#123;    i32 sayInt(1:i32 param)    string sayString(1:string param)    bool sayBoolean(1:bool param)    void sayVoid()&#125;</code></pre><h3 id="2-7-常量类型"><a href="#2-7-常量类型" class="headerlink" title="2.7 常量类型"></a>2.7 常量类型</h3><p>在 Java 中我们可能还会经常用到常量类型，在 IDL 中 常亮类型可以使用 const 关键字。</p><p>例如：</p><pre><code>const i32 const_int = 1;</code></pre><h3 id="2-8-Namespace-名字空间"><a href="#2-8-Namespace-名字空间" class="headerlink" title="2.8 Namespace (名字空间)"></a>2.8 Namespace (名字空间)</h3><p>IDL 中的命名空间即是 Java 中的包名</p><p>例如：</p><pre><code>namespace java com.example.test会被转换成：package com.example.test</code></pre><h3 id="2-9-注释"><a href="#2-9-注释" class="headerlink" title="2.9 注释"></a>2.9 注释</h3><p>IDL 支持 单行注释和多行注释</p><pre><code>/**  * 这里是多行注释 *  */// 这里是单行注释</code></pre><h3 id="2-10-Include（导入）"><a href="#2-10-Include（导入）" class="headerlink" title="2.10 Include（导入）"></a>2.10 Include（导入）</h3><p>类似于 Java 中的 import 在本文件中引入其他文件中定义的内容。</p><p><strong>注意：</strong>thrift文件名要用双引号包含，末尾没有逗号或者分号。</p><p>例如：</p><pre><code>include &quot;test.thrift&quot;   ...struct HelloTest &#123;    1: in32 uid;     ...&#125;</code></pre><h2 id="3-Java-版的-Hello-World"><a href="#3-Java-版的-Hello-World" class="headerlink" title="3. Java 版的 Hello World"></a>3. Java 版的 Hello World</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>由于 Thrift 需要使用代码生成引擎来将 Thrift 代码转换成其他语言（Java）的代码，所以需要在本地安装一下 Thrift</p><p><strong>注意：本地安装的 Thrift 版本最好和生产环境保持一致。不然很可能会出现一些问题</strong></p><p>使用以下命令安装：</p><pre><code>brew install thrift</code></pre><p>本人使用的是 Mac OS ，你和可以去 <a href="http://thrift.apache.org/docs/install/">Thrift 官网</a>，下载对应的安装包进行安装。</p><p>最终，如果你在命令行下执行下面的命令，出现 Thrift 版本号，就说明安装成功了。</p><pre><code>&gt; thrift -versionThrift version 0.12.0</code></pre><p>IDEA 默认是不支持 Thrift 所以需要安装 <code>Thrift Support</code> 插件。</p><h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h3><p>安装好插件，重启后就能在 <code>File -&gt; new -&gt; Project...</code> 菜单下 看到 Thrift 工程了。</p><p><img src="/images/thrift-001.png" alt="创建项目"></p><p>创建完成 Thrift 项目后，还需要配置一下 Thrift 代码生成引擎相关的东西。</p><p>打开菜单 <code>File - &gt; Project Structure... -&gt; Project Settings -&gt; Facets</code>,选择 Thrift</p><p><img src="/images/thrift-002.png" alt="配置 thrift 代码生成引擎"></p><p>然后会让你代码输出的位置。</p><p><img src="/images/thrift-003.png" alt="代码输出位置"></p><h3 id="3-3-创建-Thrift-文件"><a href="#3-3-创建-Thrift-文件" class="headerlink" title="3.3 创建 Thrift 文件"></a>3.3 创建 Thrift 文件</h3><p>新建 <code>HelloService.thrift</code>,在菜单中可能找不到创建 thrift 文件的菜单，直接新建 File 然后以 thrift 作为文件后缀就可以。</p><p>内容如下：</p><pre><code>namespace java com.zdran.test.thriftservice ThriftHelloService&#123;    string sayHello(1:string userName)&#125;</code></pre><p>在这个接口文件中我们定义了一个 sayHello 的接口，它接收一个 String 类型的参数，并返回一个 String 类型的值。</p><p>现在我需要编译该 thrift 文件，然后就会自动生成我们需要的代码。</p><p>我们可以直接在控制台执行以下命令。</p><pre><code>thrift -gen java HelloService.thrift</code></pre><p>然后就能在<code>gen-java</code>目录中看到生成后的 java 文件了。</p><p>还有一种办法，就是将 thrift 编译器添加到右键菜单里，直接在 IDEA 里编译。</p><p>打开 <code>Preferences...</code> 菜单，设置好你的 Thrift 的安装目录，然后勾选上下面的这个选项，就可以在 IDEA 里直接编译 thrift 文件了。</p><p><img src="/images/trhift-005.png" alt=""></p><p><strong>注意：thrift 文件 必须要在 src 目录下，或者手动设置的 source 目录（IDEA显示蓝色的文件夹）下才会有 Recompile 菜单</strong></p><p>PS: 搞了半天，最后可以编译了，结果报错：</p><pre><code>Error:Internal error: (java.util.concurrent.ExecutionException) com.intellij.util.xmlb.XmlSerializationException: Cannot deserialize class com.intellij.plugins.thrift.config.ThriftCompilerOptionsjava.util.concurrent.ExecutionException: com.intellij.util.xmlb.XmlSerializationException: Cannot deserialize class com.intellij.plugins.thrift.config.ThriftCompilerOptions    ... ... </code></pre><p>也不知道是 IDEA 的问题，还是插件的问题，网上搜了一下啊，貌似没有遇到这个问题的，有时间再研究吧，直接在控制台编译好，然后我们再新建一个 Maven 项目。并添加 thrift 依赖</p><pre><code>    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;            &lt;artifactId&gt;libthrift&lt;/artifactId&gt;            &lt;version&gt;0.12.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>然后把上面生成的 java 文件复制到 对应的包下面。</p><p>然后我再创建一个实现类<code>ThriftHelloServiceImpl.java</code>，来实现我们定义好的接口。内容如下：</p><pre><code>package com.test.thrift;import org.apache.thrift.TException;public class ThriftHelloServiceImpl implements ThriftHelloService.Iface &#123;    @Override    public String sayHello(String userName) throws TException &#123;        return &quot;hello &quot;+ userName;    &#125;&#125;</code></pre><h3 id="3-4-创建服务端和客户端类"><a href="#3-4-创建服务端和客户端类" class="headerlink" title="3.4 创建服务端和客户端类"></a>3.4 创建服务端和客户端类</h3><p>我们这里采用 Main 方法的形式来进行客户端与服务端的通信，即启动两个 Main 方法，分别表示服务端与客户端。</p><p>首先创建服务端的 Main 方法，代码如下：</p><pre><code>public class ServiceMain &#123;    public static void main(String[] args) throws Exception &#123;        ServerSocket serverSocket = new ServerSocket(9090);        TServerSocket serverTransport = new TServerSocket(serverSocket);        ThriftHelloService.Processor processor =                new ThriftHelloService.Processor&lt;ThriftHelloService.Iface&gt;(new ThriftHelloServiceImpl());        TBinaryProtocol.Factory protocolFactory = new TBinaryProtocol.Factory();        TSimpleServer.Args tArgs = new TSimpleServer.Args(serverTransport);        tArgs.processor(processor);        tArgs.protocolFactory(protocolFactory);        TServer tServer = new TSimpleServer(tArgs);        System.out.println(&quot;启动 Thrift 服务端&quot;);        tServer.serve();    &#125;&#125;</code></pre><p>然后再创建客户端的 Main 方法,代码如下：</p><pre><code>public class ClientMain &#123;    public static void main(String[] args) &#123;        TTransport transport = null;        try &#123;            transport = new TSocket(&quot;127.0.0.1&quot;, 9090, 6000);            TProtocol protocol = new TBinaryProtocol(transport);            ThriftHelloService.Client client = new ThriftHelloService.Client(protocol);            transport.open();            String result = client.sayHello(&quot;thrift-1&quot;);            System.out.println(result);        &#125; catch (TException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (null != transport) &#123;                transport.close();            &#125;        &#125;    &#125;&#125;</code></pre><p>然后启动服务端的 Main 方法，再启动客户端的 Main 方法，会看到 hello thrift-1，说明 RPC 通信成功了。</p><h2 id="4-关于-Thrift-生成好的-Java-代码"><a href="#4-关于-Thrift-生成好的-Java-代码" class="headerlink" title="4. 关于 Thrift 生成好的 Java 代码"></a>4. 关于 Thrift 生成好的 Java 代码</h2><p>可能你会很奇怪，我们仅仅在 .thrift 文件中定义了一个接口，但是在生成后的 .java 文件中，却生成了大量的代码。</p><p>其实我们没必要太过关注生成后的代码，主要关注下面几个东西就可以了。</p><p>服务端关注以下两个接口类：</p><ul><li>ThriftHelloService.Iface</li></ul><p>这个是服务端提供同步调用的接口。就是说，你实现的这个接口下面的方法，都会采用同步的方式调用。</p><ul><li>ThriftHelloService.AsyncIface</li></ul><p>同样，如果客户端和服务端需要采用异步的方式通信，服务端就需要实现 AsyncIface 下的接口。</p><p>同样，消费端也有两个 Client 一个是同步调用的，一个是异步调用的。</p><ul><li><p>ThriftHelloService.Client<br>执行同步调用。</p></li><li><p>ThriftHelloService.AsyncClient<br>执行异步调用。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
            <tag> Thrift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式（Singleton Pattern）</title>
      <link href="20190818.html"/>
      <url>20190818.html</url>
      
        <content type="html"><![CDATA[<p><strong>注意：阅读本文时，强烈建议先阅读下 OneMall 项目的概要设计</strong></p><ul><li><a href="https://github.com/zdRan/OneMall">设计模式-OneMall 项目概要设计</a></li><li><a href="https://zdran.com/20190509.html">设计模式-六大设计原则</a></li><li><a href="https://zdran.com/20190818.html">设计模式-单例模式</a></li></ul><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h2><p>由于我们需要对接各大商城的 API，所以我们需要在 <strong>Supplier</strong> 模块实现各大商城的 API client，提供一个 client 供其他模块来调用。每个商城的 API client 只需要一个就可以了。这个 client 就可以使用<strong>单例模式</strong>。</p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><p>代码实现：</p><pre><code>public class JdApiSingleton &#123;    private static final JdApiSingleton self = new JdApiSingleton();    private JdApiSingleton() &#123;    &#125;    public static JdApiSingleton getJdApi() &#123;        return self;    &#125;    /**     * 获取商品信息     *     * @param url   地址     * @param param 参数     * @return 商品实体     */    public static GoodsDTO getGoodsInfo(String url, Map&lt;String, Object&gt; param) &#123;        String result = HttpClientUtil.get(url, param);        return JSONObject.parseObject(result, GoodsDTO.class);    &#125;    /**     * 提交订单     *     * @param url   地址     * @param param 参数     * @return 订单信息     */    public static OrderDTO submitOrder(String url, Map&lt;String, Object&gt; param) &#123;        String result = HttpClientUtil.post(url, param);        return JSONObject.parseObject(result, OrderDTO.class);    &#125;&#125;</code></pre><p><strong>单例模式</strong>比较简单，这里使用了”饿汉式”的设计，私有化构造方法，确保应用中只有一个实例，然后还有提供了其他各种 API，用于实现业务逻辑。</p><h2 id="3-类图"><a href="#3-类图" class="headerlink" title="3. 类图"></a>3. 类图</h2><p><img src="/images/3_1_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" alt="单例模式"></p><p>单例模式的类图比较简单，只需要一个 Singleton 就可以实现单例模式。单例模式不仅仅只有一种实现方式，上面这种“饿汉式”式最简单的实现。有兴趣的可以说搜一下其他的实现方式，由于本文讨论的是设计模式，这里不再详细讨论别的实现方式。</p><h2 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4. 扩展"></a>4. 扩展</h2><p>在内存中产生一个实例很简单，但是，在有些情况下我们可能需要固定数量的实例，用来提高应用的性能。比如在多线程的情况下，我们可能需要为每个线程分配一个实例。这个时候我们就可以在内存中生成固定数量的实例，数量与线程池的大小保持一致。</p><p>代码实现：</p><pre><code>public class JdApiSingletonPool &#123;    //实例最大个数    private static final int MAX_NUM = 4;    private static final List&lt;JdApiSingletonPool&gt; pool = new ArrayList&lt;&gt;(MAX_NUM);    private JdApiSingletonPool() &#123;    &#125;    //初始化单例池    static &#123;        for (int i = 0; i &lt; MAX_NUM; i++) &#123;            pool.add(new JdApiSingletonPool());        &#125;    &#125;    /**     * 获取实例     *     * @param index 下标     * @return 如果下标越界返回 null     */    public static JdApiSingletonPool getJdApiSingleton(int index) &#123;        if (index &lt; 0 || index &gt;= MAX_NUM) &#123;            return null;        &#125;        return pool.get(index);    &#125;    // other api ...&#125;</code></pre><p>我们通过初始化一个单例的集合来存储所有的单例。这样就能够保证内存中有固定数量的单例实例。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p><strong>单例模式(Singleton Pattern)：</strong> 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>这个定义有 3 个含义：</p><ol><li>只能有一个实例（私有化构造方法）</li><li>自行实例化(自动初始化)</li><li>向整个系统提供这个实例（提供 get 方法获取自动初始化的实例）</li></ol><p>单例模式的优点：</p><ol><li>只有一个实例，节省了内存开销。减少了对象的创建和销毁的时间。</li><li>避免了对资源的多重占用。由于只有一个实例，在程序运行期间，只能有一个进程来操作这个实例。</li><li>全局访问。单例模式要求向整个系统提供这个实例，所以可以用来共享某些资源。</li></ol><p>单例模式的缺点：</p><ol><li>没有接口，不易扩展。如果需要新增一些 API 就需要对单例模式进行修改</li><li>与<strong>单一职责原则</strong>冲突。一个单例实例一般不会只实现一种业务逻辑。</li></ol><h2 id="6-使用实例"><a href="#6-使用实例" class="headerlink" title="6. 使用实例"></a>6. 使用实例</h2><ol><li>Spring 容器中的 Java Bean 就是采用的单例模式。每个 Bean 都是单例的。</li><li>Java 中的 JDBC 连接对象 也是采用的单例模式。每个 JDBC 连接 都是单例的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DesignPattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结-Java-2年</title>
      <link href="20190813.html"/>
      <url>20190813.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-背景介绍"><a href="#0-背景介绍" class="headerlink" title="0. 背景介绍"></a>0. 背景介绍</h2><p>主语言 Java，框架 Spring Boot，对微服务有简单的了解和应用。2年工作经验。</p><p>2019 年 8 月，开始着手看新工作机会，可能这个时间段并不是一个很好的时间，机会并不是很多，但是还是收到了一些大厂小厂的面试邀请。面试了大概3个周左右，包括小米、京东、滴滴、新浪、摩拜、猫眼等一些公司，还包括其他一些上市的、没上市的、不需要融资的公司，以及一些国企、央企等。总之有大厂，有小厂，可以说是很全面了。最后进了猫眼娱乐。通过这次面试也充分认识到了自己的一些不足。下面对这些做一个总结。</p><h2 id="1-公司划分"><a href="#1-公司划分" class="headerlink" title="1. 公司划分"></a>1. 公司划分</h2><p>我对面试的这些公司做了一个简单的划分，大概分了 3 个梯队。</p><h3 id="第一梯队"><a href="#第一梯队" class="headerlink" title="第一梯队"></a>第一梯队</h3><p>一线大厂。比如 BAT、华为、小米、京东、滴滴。</p><p>大厂的面试看中的主要是算法、JVM、源码等，感觉看中的更加是你的内功，对你做过的项目<strong>相对而言</strong>不是特别重视。所以面试这些公司的时候一定要准备些算法的知识。<strong>手写算法！！</strong></p><h3 id="第二梯队"><a href="#第二梯队" class="headerlink" title="第二梯队"></a>第二梯队</h3><p>上市公司或者融资情况比较好的 C 轮、D 轮的公司。比如猫眼、新浪等。</p><p>这些公司面试主要看中的一个是对常用框架的的理解，比如 Spring 全家桶，另一个比较看中的是高并发、多线程的问题。所以如果面试这些公司的时候，数据库的事务，索引、锁、以及 Java 的多线程、锁、concurrent 包一定要有所准备。</p><h3 id="第三梯队"><a href="#第三梯队" class="headerlink" title="第三梯队"></a>第三梯队</h3><p>国企、央企、以及非互联网行业的大规模的公司。比如一些中xx院xx所、一些教育行业的公司等。国企公司十有八九是猎头给你推的(PS:如果你在猎聘网上有简历的话)。</p><p>由于是国企的性质，所以笔试题一定要刷，特别是一些 Java 基础中细节的问题，比如 String 的不可变属性，Integer 的缓存、final 与 finally的区别、finally 中的 return执行顺序等等等等，各种语法上的细节一定要有所准备。另一个方面是 SQL 语句，笔试题里一定少不了写SQL。最好网上找几套面试题做做。<strong>相对而言</strong>，面试就不是特别重要了。</p><h3 id="第四梯队"><a href="#第四梯队" class="headerlink" title="第四梯队"></a>第四梯队</h3><p>天使轮、A轮、B轮等部分创业公司。</p><p>这部分公司内容就比较杂了，面试的范围主要看面试官的水平。差一点的可能会让你先做笔试题（参考第三梯队），好点的会问一些 JDK 源码、问一些 MySQL 的事务隔离级别。再好一点的，可能会问一些 Servlet、Spring、Spring Boot源码的东西。甚至会让你手写 SQL。这部分公司，怎么说呢，随缘吧，感觉你怎么准备都应付不全。只能说兵来将挡，水来土掩。</p><h2 id="面试题目细节"><a href="#面试题目细节" class="headerlink" title="面试题目细节"></a>面试题目细节</h2><p>面试题目细节分几个方面，由于每次面试结束后也没有做总结(PS:缺点！！)，现在只能靠回忆，所以部分内容可能不是特别全面。</p><h3 id="1-JDK-相关"><a href="#1-JDK-相关" class="headerlink" title="1. JDK 相关"></a>1. JDK 相关</h3><p><strong>关键字:String、Integer、HashMap、HashTable、ConCurrentHashMap</strong></p><p>比如:</p><pre><code>String a = &quot;hello&quot;;String b = &quot;world&quot;;String c = a + b;String d = &quot;helloworld&quot;;String a1 = new String(&quot;hello&quot;)String b1 = new String(&quot;world&quot;)String c1 = a1 + b1;String d1 = new String(&quot;helloworld&quot;)</code></pre><p>哪个跟哪个相等？为什么？在内存中的存储方式有是什么样的？基本上是一套组合拳。</p><p>再比如，</p><p>HashMap、HashTable的区别是什么？你可能会说一个线程安全，一个线程不安全，<br>然后会问你 HashMap 为什么不安全？ HashTable 与 ConCurrentHashMap 有什么区别？又是一套组合拳。</p><p>这里推荐一篇美团技术团队的博客 <a href="https://tech.meituan.com/2018/11/15/java-lock.html">Java 8系列之重新认识HashMap</a></p><h3 id="2-JVM-相关"><a href="#2-JVM-相关" class="headerlink" title="2. JVM 相关"></a>2. JVM 相关</h3><p><strong>关键字:Java 运行时内存划分、Java 内存模型（JMM）、垃圾回收（GC、CMS）、Java类加载过程</strong></p><p>推荐一本书吧，经典的 《深入理解 Java 虚拟机 第二版》 周志明的。不用从头看完，拔苗助长下，重点看这几章，先把面试过了再说。</p><p>PS:给自己的博客打个广告 </p><ul><li><a href="https://zdran.com/20190322.html">JVM 读书笔记(一) 内存划分</a></li></ul><h3 id="3-Thread-相关"><a href="#3-Thread-相关" class="headerlink" title="3. Thread 相关"></a>3. Thread 相关</h3><p><strong>关键字: 线程池、ThreadLocal、volatile、sleep、wait、各种锁（自旋锁、偏向锁、轻量锁）</strong></p><p>推荐一篇美团技术团队的博客 <a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a>，详细说明了 Java 中的各种锁，质量没的说！</p><p>线程池和 ThreadLocal 是最常被问到的，多看看博客，即便是生产环境没用过，到时候被问到也要有话可说。</p><h3 id="4-算法-相关"><a href="#4-算法-相关" class="headerlink" title="4. 算法 相关"></a>4. 算法 相关</h3><p><strong>关键字: 链表（双指针法）、树（二叉查找树、B树、B+树、红黑树）、字符串相关（匹配子串，split实现）</strong></p><p>比如：</p><ol><li>链表翻转</li><li>获取单链表的第 N 个元素</li><li>获取单链表的倒数第 N 个元素</li><li>在一个二叉查找树中查询某个元素的前一个元素</li><li>求一棵二叉树的高度。</li><li>判断一个数组是否符合二叉查找树的中序遍历结果</li><li>给你一个 List 构造一个树形结构</li><li>字符串的 split 方法的实现</li><li>字符串子串匹配算法</li><li>以及各种常见的排序、查找算法</li></ol><p><strong>手写！！！ 大厂必考题！！</strong></p><h3 id="5-MySQL-相关"><a href="#5-MySQL-相关" class="headerlink" title="5. MySQL 相关"></a>5. MySQL 相关</h3><p><strong>关键字: 索引存储结构、聚簇索引、事务隔离级别、以及使用索引的场景，创建索引时需要考虑的条件</strong>。</p><p>推荐一篇美团技术团队的博客 <a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系</a> ，深入浅出的讲解了事物的隔离级别，个人感觉质量非常高。</p><h3 id="6-Spring-相关"><a href="#6-Spring-相关" class="headerlink" title="6. Spring 相关"></a>6. Spring 相关</h3><p><strong>关键字: IoC、AOP、SpringBoot启动过程、Spring处理 HTTP 请求的过程、Spring Boot 与 Spring MVC 的区别</strong>。</p><p>面试的时候可能会先让你说一下 IoC、AOP然后，有关 IoC 的可能会问 Autowired、 Resource 注解的区别、依赖注入的方式，依赖冲突的解决办法等。AOP 可能会问实现方式，以及实现原理，基本上会问到 <strong>动态代理</strong> 的内容</p><p>Spring 相关的，可能会问到 Spring Boot 的启动过程、处理 Http 请求的过程（甚至包括 DNS 解析的部分）比如，会问，我从浏览器发起一个 http 请求到接收到响应，中间发生了什么？</p><p>再深入一点会问到，Spring 是怎么把 Http 的数据流绑定到具体的 Java bean 上的？</p><h3 id="7-SQL-相关"><a href="#7-SQL-相关" class="headerlink" title="7. SQL 相关"></a>7. SQL 相关</h3><p>面试的套路基本上都是给你一个或者两个表结构，然后让写个查询语句。</p><p>基本的CURD就不说了，重点关注 group by、order by 以及关联查询、组合查询、分页。面试的时候一定会遇到 SQL 题的。</p><p>PS:给自己的博客打个广告 </p><ul><li><a href="https://zdran.com/20190417.html">SQL 性能优化的几条建议</a></li><li><a href="https://zdran.com/20180529.html">MySQL 学习笔记</a></li></ul><h3 id="开放题"><a href="#开放题" class="headerlink" title="开放题"></a>开放题</h3><p>开放题大部分都集中在大数据量的问题上，比如:</p><ol><li><p>我有一个文件，文件里面有几百万甚至上千万的有序记录（总之，内存一次是加载不全的），你要如何快速的查询到某个具体的记录?</p></li><li><p>当你的订单量超过百万级别甚至是千万级别，你如何存到数据库里? 这时候你可能会说，分库分表，然后下一个问题就是如何分，分完之后如何查。</p></li><li><p>我开了 10 个线程来处理数据库里的订单信息，如何保证同一个订单只能被处理一次？如果在处理途中又有新的订单进来，怎么保证新的订单也会被处理？</p></li></ol><p>这些题的答案基本上都不是唯一的，每个人都有每个人的理解，因为技术栈的不一样，所以想到的解决方案也不一样。感觉主要还是看面试者解决问题的思路。</p><p>这部分其实我也没有什么特别好的办法准备，不过也不要担心，当问到这个问题时，你可能没有最好的思路，但是你至少可以保证有一个能解决问题的思路，先不要关心数据量的问题，先说出来一个解决方案，然后再一点点思考怎么优化，面试官也可能会引导你去优化。</p><p>个人感觉，这类题的解答套路无非是时间不够，空间来凑，线程来凑。</p><p>时间不够，那就考虑下把某些数据存起来，节省查询时间。或者开多个线程来处理。往这个方向上思考，思路一般不会错。</p><h3 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h3><p>项目整体框架图，或者叫架构图，一般大点的公司都会要求你说一下，或者画一下，画的时候会要求你简单说一下，某个功能的调用关系，某个模块做了什么，你负责了哪个模块，哪个功能，怎么做的？</p><p>所以面试前最好准备下项目架构图，自己先画一下，调整下模块的布局，尽量画的清楚（是清楚，不是美观！）些，一般架构图大致分三层，上层是入口，中层是业务逻辑层，下层是数据层，两侧可能还会有管理模块，定时模块，监控模块，数据分析模块等。一边画一边介绍每个模块的作用，功能。最后再说一下某个具体的功能是怎么调用的</p><p>所以这部分面试的准备就是再次熟悉下自己做过的项目，不要去研究代码细节，从大局入手，整体架构，模块，技术栈，依赖关系，调用关系。然后再仔细的熟悉下自己做的功能，最好自己跟自己讲几遍。</p><h2 id="为什么离职？"><a href="#为什么离职？" class="headerlink" title="为什么离职？"></a>为什么离职？</h2><p>这是每个公司面试都少不了的问题，所以面试之前一定要根据具体的公司，岗位的工作内容来回答。</p><p>比如：小公司到大公司。</p><p>现在的公司业务量少，所以想到大公司接触一些流量比较大的项目</p><p>比如：A行业到B行业</p><p>我对现在的工作内容不是特别感兴趣，一直在做xxx，所以想换一个我喜欢的行业。我对 B 行业比较感兴趣，刚好看到 xx 公司的招聘信息，就投了简历来试试。</p><p>PS：<strong>一定要简单了解下 B 行业，因为，下一个问题有可能是，谈谈你对 B 行业的了解 :)</strong></p><p>比如：大公司到小公司</p><p>我在现在的公司一直在负责 xxx 的 A 模块，但是对 xxx 的整体架构，业务逻辑都没有机会了解，所以想换个工作机会能够接触到 xxx 的完整的业务逻辑。</p><p>总之一句话，见机行事！哪怕你仅仅是因为薪资不满意离职的，也要尽量想一个靠谱点的离职原因。</p><h2 id="为什么选择我们公司的这个职位？"><a href="#为什么选择我们公司的这个职位？" class="headerlink" title="为什么选择我们公司的这个职位？"></a>为什么选择我们公司的这个职位？</h2><p>这个问题一般是 HR 来问的，如果能面试到这里，说明已经成功了一大半了。</p><p>回答这个问题，一般从 3 个方面吧，行业、公司、技术匹配程度</p><p>我对这个行业比较感兴趣，而且贵公司在这个行业比较领先的。</p><p>如果这个公司是小公司，那就从技术匹配程度上说。我看了贵公司的招聘信息，觉得自己的技术方向与招聘的技术要求比较匹配，而且对贵公司(或者这个行业)比较感兴趣，所以就投了一下简历。</p><p>PS:<strong>面试前一定要了解下要面试的公司，行业。知己知彼嘛</strong></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>大厂面试败在了手写算法上，对 Spring 全家桶的源码也不够了解。很是遗憾。争取在这两年内把这方面的技术提升上来。最后决定入职猫眼娱乐，估计以后能省点看电影的钱，哈哈~~</p><p>最后，祝大家都能找到满意的工作！！</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-六大设计原则</title>
      <link href="20190509.html"/>
      <url>20190509.html</url>
      
        <content type="html"><![CDATA[<p><strong>注意：阅读本文时，强烈建议先阅读下 OneMall 项目的概要设计</strong></p><ul><li><a href="https://github.com/zdRan/OneMall">设计模式-OneMall 项目概要设计</a></li><li><a href="https://zdran.com/20190509.html">设计模式-六大设计原则</a></li><li><a href="https://zdran.com/20190818.html">设计模式-单例模式</a></li></ul><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>谈及设计模式，就不能不提六大设计原则，这六大设计原则就像六颗无限宝石一样强大。所有的设计模式都是为了尽量的实现某个或者某些设计原则。</p><p>通俗一点，设计原则是接口，而设计模式就是具体的实现类。所以我们先看一下这个接口里到底有哪些方法。</p><h2 id="1-单一职责原则-SRP：Single-responsibility-principle"><a href="#1-单一职责原则-SRP：Single-responsibility-principle" class="headerlink" title="1. 单一职责原则(SRP：Single responsibility principle)"></a>1. 单一职责原则(SRP：Single responsibility principle)</h2><p>以我们的 OneMall 商城为例。商城首先得有用户吧，用户要有用户名、密码、余额，这些信息，而且也要有修改用户名、密码、充值、支付这些操作吧。我们看一下用户这个类的设计。</p><p><img src="./images/2_1_userInfo%E7%B1%BB%E5%9B%BE.png" alt="UserInfo 类图"></p><p>我相信稍微懂点设计的人都能看出这个类的设计有问题，因为把用户的属性和用户的行为放到了个类里面。应该把用户的属性和用户的行为分开，重新设计一下这个类。</p><p><img src="./images/2_2_userInfo%E7%B1%BB%E5%9B%BE.png" alt="UserInfo 类图2"></p><p>上面这种把一个类拆分成了两个类就是遵循了 <strong>单一职责原则</strong> 。</p><p>单一职责原则的定义是：</p><p><strong>SRP:There should never be more than one reason for a class to change</strong></p><p><strong>引起一个类的变化原因绝对不能超过一个</strong></p><p>就像上面的例子一样，修改用户属性会引起类的变化，处理业务逻辑（充值、支付）也会引起类的变化，依据单一职责原则，所以我们把类拆成了两个。</p><p>我们在设计类或者是接口的时候尽量做到职责单一，这样才能使每个类的职责更加清晰。</p><h2 id="2-里式替换原则-Liskov-Substitution-Principle-LSP"><a href="#2-里式替换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="2. 里式替换原则(Liskov Substitution Principle LSP)"></a>2. 里式替换原则(Liskov Substitution Principle LSP)</h2><p>因为我们对接了不同的商城，每个商城，都有每个商城自己的下单逻辑，但是我们对外提供的下单逻辑只能有一套，所以需要封装一下，这里就遵守出了 <strong>里式替换原则</strong>。</p><p>在一般的 MVC 架构中，我们一般有 Controller、Service层。而 Service 层一般是接口和对应的实现类，类图如下</p><p><img src="./images/2_3_order%E7%B1%BB%E5%9B%BE.png" alt="Order 类图"></p><p>我们在下单的时候可以使用接口中的 submitOrder，具体的实现逻辑放在不同的子类里，比如我们可以有 JDSubmitOrderServiceImpl、 TMSubmitOrderServiceImpl 等。</p><p>里式替换原则：</p><pre><code>If for each object o1 of type S there is an object o2 of type T such that forall programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。</code></pre><p>这是一种标准定义。还有一种通俗的定义：</p><pre><code>Functions that use pointers or references to base classes must be able to useobjects of derived classes without knowing it.所有引用基类的地方必须能透明地使用其子类的对象。</code></pre><p>再换句话说，就是 <strong>任何基类可以出现的地方，子类一定可以出现</strong>。</p><p>里式替换原则是在告诉我们，继承关系应该遵循哪些原则? 或者说，如果你要使用继承，那么你就应该遵守里式替换原则。</p><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原则是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><p>里式替换原则有四层含义，或者说，当你实现继承的时候，应该遵守这四个规则。</p><ul><li>子类必须完全实现父类的方法</li></ul><p>如果子类不能够完全实现父类的方法，那么建议断绝继承关系，使用组合、依赖等代替继承关系。</p><p>比如我们的例子中，如果有一个类 XXXOrderServiceImpl 继承了 SubmitOrderService，但是没有实现 Service 中的接口，那么就应该断绝继承关系。</p><p>PS:其实这个原则应该没有说完，还有下句。<strong>子类必须完全实现父类的方法。但不得重写（覆盖）父类的非抽象（已实现）方法</strong></p><p>就是说子类不能改变父类已经实现好的方法，不能改变父类方法的逻辑。</p><ul><li>子类可以有自己的个性</li></ul><p>或者说，子类可以有自己独有的方法、属性。但是这里需要注意：如果你在子类中定义了方法，那么你在使用这个类的时候就不能使用多肽了。</p><p>子类不仅可以继承父类中的方法和属性，还可以定义自己的方法和属性。但是这样做之后，就不能使用多肽了，比如，当我们在使用下单逻辑的时候，一般会这么定义：</p><pre><code>SubmitOrderService orderService = new JDSubmitOrderServiceImpl();orderService.submitOrder();</code></pre><p>但是，如果我们在 JDSubmitOrderServiceImpl 中定义了一个自己的方法 xxxOrder()，如果想要使用该方法，就不能使用上面这种定义方式。</p><pre><code>JDSubmitOrderServiceImpl orderService = new JDSubmitOrderServiceImpl();orderService.xxxOrder();</code></pre><p>只能使用 JDSubmitOrderServiceImpl 作为对象的类型。</p><ul><li>覆盖或实现父类的方法时输入参数(方法的参数)可以被放大</li></ul><p>比如，我们在实现 SubmitOrderService 的时候，重写 submitOrder 方法的时候，可以将方法的参数定义成 Order 或者是 Order 的父类。 </p><p>比如我们 SubmitOrderService 有个方法<code>xxxOrder(ArrayList list)</code> 参数是一个 <code>ArrayList</code>,在实现这个方法的时候可以传入 ArrayList 的父类，可以这么定义<code>xxxOrder(List list)</code></p><p>PS: 这里说的是参数可以被放大，是当你有不得不放大参数的时候，可以放大，而不是只要实现就去放大参数，一般在实现的时候尽量不要放大，而且，一般父类的方法参数都是某个类的父类，很少使用子类的，所以很少遇到放大参数的情况。</p><p>注意: 这里说的是方法定义的时候可以被放大。在实际调用的时候可以传入一个参数的子类。比如：</p><pre><code>SubmitOrderService orderService = new JDSubmitOrderServiceImpl();orderService.submitOrder(new JDOrder());</code></pre><p>这里我们传入的参数是 Order 的子类。而不是父类。</p><ul><li>覆写或实现父类的方法时输出结果（方法的返回值）可以被缩小</li></ul><p>跟第 3 条对应，这里说的是方法的返回值可以被缩小，比如父类方法的返回值是 List ,那么子类的返回值可以是 List 或者是 List 的子类。比如 ArrayList。</p><h2 id="3-依赖倒置原则-Dependence-Inversion-Principle-DIP"><a href="#3-依赖倒置原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="3. 依赖倒置原则(Dependence Inversion Principle DIP)"></a>3. 依赖倒置原则(Dependence Inversion Principle DIP)</h2><p>还是以上面的 Order 类图为例，我们在定义 SubmitOrderService 的方法的时候依赖了 Order 类，在设计的时候我们使用的是 Order 类，而不是 JDOrder 这个子类，这里的设计就遵守了 <strong>依赖倒置原则</strong>。</p><p>依赖倒置原则的定义：</p><pre><code>High level modules should not depend upon low level modules,Both should depend upon abstractions.高层模块不应该依赖低层模块，两者都应该依赖抽象Abstractions should not depend upon details.抽象不应该依赖细节Details should depend upon abstracts.细节应该依赖抽象</code></pre><p>高层模块一般是抽象层，低层模块是具体的实现层，在上面的例子中 SubmitOrderService 就是高层模块，JDSubmitOrderServiceImpl、 JDOrder 就是低层模块。</p><p>在这个例子中，可以将依赖倒置原则翻译成 SubmitOrderService 不应该依赖 JDOrder， 而应该依赖 JDOrder 的抽象层 Order。 JDSubmitOrderServiceImpl 应该依赖 Order。</p><p>这么做是为了方便后期扩展，提高程序的可扩展性，想象一下，我们再增加一个 TMSubmitOrderServiceImpl，如果接口中定义的是 JDOrder，那么我们定义的 TMSubmitOrderServiceImpl 就没办法实现了。 而使用 Order 作为参数，就完全可以正常实现。在调用的时候我们可以传入一个 TMOrder 作为参数。</p><p>依赖倒置原则是告诉我们如何设计类的依赖关系，目的是降低类与类之间的耦合，提高系统的稳定性和可扩展性。</p><h2 id="4-接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#4-接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="4. 接口隔离原则(Interface Segregation Principle ISP)"></a>4. 接口隔离原则(Interface Segregation Principle ISP)</h2><p>假如我们需要设计一个订单相关的接口， OrderService 这个服务可能会提供一些增删改查的接口，提供给管理模块使用，还有一些订单相关的接口，比如下单接口，订单撤销接口，这些接口不应该放到 OrderService 中。而是写在另外一个 Service 中，比如我们上文中的 SubmitOrderService 中。这里就遵守了 <strong>接口隔离原则</strong></p><p><img src="./images/2_4_order%E7%B1%BB%E5%9B%BE.png" alt="Order 类图"></p><p>OrderManager 不应该依赖下单，相关的接口，所以需要将下单相关的接口”隔离”出来。</p><p>接口隔离原则有两种定义：</p><ul><li><p>Clients should not be forced to depend upon interfaces that they don’t use.（客户端不应该依赖它不需要的接口。）</p></li><li><p>The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）</p></li></ul><p>针对我们上面的例子</p><ul><li>客户端(OrderManager) 不应该依赖它不需要的接口(下单接口)。</li><li>OrderManager 与 OrderService 的依赖关系应该建立在最小的接口上。</li></ul><p>接口隔离原则是在告诉我们，应该以什么规则将接口组合到一起，应该以什么规则将接口拆分到不同的类中。</p><p>PS: 接口隔离原则中的”接口”，是指的 Java 中 interface 里某个具体的方法。而不是 Java 中使用 interface 声明的某个 class 文件</p><h2 id="5-迪米特法则-Least-Knowledge-Principle-LKP"><a href="#5-迪米特法则-Least-Knowledge-Principle-LKP" class="headerlink" title="5. 迪米特法则(Least Knowledge Principle LKP)"></a>5. 迪米特法则(Least Knowledge Principle LKP)</h2><p>以商城为例，假如我们的分销商城 AMall 需要获取一个商品信息，一种做法是，我们提供 2 个接口，JDGoodsService 用于提供 JD 商城的商品信息，一个 TMGoodsService 用于提供 TM 商城的商品信息，AMall 分别调用不同的接口获取商品信息。 </p><p>上面这种设计就违反了 <strong>迪米特法则</strong>, 注意，是 <strong>违反</strong> 了迪米特法则。</p><p>迪米特法则又叫最小知识原则，标准的定义是:</p><p>Only talk to your immediate friends（只与直接的朋友通信）</p><p>根据我们上面的这个例子,AMall 需要获取商品信息，不应该直接与 JD、TM 等接口通信，而是 OneMall 提供统一的接口，用于获取商品信息，至于具体是获取 JD 的商品还是 TM 的商品，那应该是 OneMall 该操心的事情，上面的例子中我们的 AMall 跨过了 OneMall 直接与具体的商城接口通信，就是违反了迪米特法则。</p><p>迪米特法则是在告诉我们如何处理接口与接口之间的依赖关系。遵守迪米特法则，可以让代码更加容易扩展，比如，将来我们增加一个 TB 的商城接口，对 AMall 来说是不需要做修改的。</p><h2 id="6-开闭原则-Open-Close-Principle-OCP"><a href="#6-开闭原则-Open-Close-Principle-OCP" class="headerlink" title="6. 开闭原则(Open Close Principle OCP)"></a>6. 开闭原则(Open Close Principle OCP)</h2><p>还是以我们的 OneMall 商城为例，现在我对接了 JD 商城、TM 商城、TB 商城、如果我们后期要对接其他的商城，我们的 OneMall 商城应该通过扩展(增加)类接口的方式来实现功能，而不是通过修改接口和类来实现。</p><p>如果能够通过扩展来实现，说明我们的项目设计就是遵守了 <strong>开闭原则</strong>。</p><p>开闭原则的定义：</p><p>Software entities like classes,modules and functions should be open for extension but closed for<br>modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）</p><p>代码设计如果遵守了开闭原则，可以使代码更容易扩展。</p><p>开闭原则是之前五大设计原则的更高层的抽象，或者说，之前的五大设计原则是开闭原则的具体体现。</p><p>可能有点绕，可以这么理解，我们在设计代码的时候，终极目标就是希望代码符合或者遵守开闭原则，而具体应该怎么设计才能够符合开闭原则呢，就是尽量遵守其他五大设计原则！</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul><li>Single Responsibility Principle：单一职责原则</li><li>Open Closed Principle：开闭原则</li><li>Liskov Substitution Principle：里氏替换原则</li><li>Law of Demeter：迪米特法则</li><li>Interface Segregation Principle：接口隔离原则</li><li>Dependence Inversion Principle：依赖倒置原则</li></ul><p>将这六个原则的首字母组合起来就是 SOLID(solid 稳定的)，代表的含义是这六个原则组合使用起来可以建立稳定的、灵活的、可靠地项目。</p>]]></content>
      
      
      <categories>
          
          <category> DesignPattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 爬虫实战(一) 爬取自如网租房信息</title>
      <link href="20190420.html"/>
      <url>20190420.html</url>
      
        <content type="html"><![CDATA[<h2 id="免责声明：本文仅供学习交流，如出现任何法律问题本人概不负责！"><a href="#免责声明：本文仅供学习交流，如出现任何法律问题本人概不负责！" class="headerlink" title="免责声明：本文仅供学习交流，如出现任何法律问题本人概不负责！"></a><strong>免责声明：本文仅供学习交流，如出现任何法律问题本人概不负责！</strong></h2><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>与自如网奋战了 2 个周，终于有点结果了。</p><h2 id="1-隐藏的价格信息"><a href="#1-隐藏的价格信息" class="headerlink" title="1. 隐藏的价格信息"></a>1. 隐藏的价格信息</h2><p>打开自如网（<code>http://www.ziroom.com/z/nl/z2.html?qwd=</code>），直接 F12 看了一下房屋列表的源码：</p><pre><code>  &lt;div class=&quot;priceDetail&quot;&gt;    &lt;p value=&quot;&quot; class=&quot;price&quot;&gt;    &lt;span class=&quot;gray-6&quot;&gt; (每月) &lt;span class=&quot;hui_icon&quot;&gt;&lt;img width=&quot;60&quot; height=&quot;18&quot;     src=&quot;//static8.ziroom.com/phoenix/pc/images/201810/img_label5.png&quot; /&gt;&lt;/span&gt; &lt;/span&gt; &lt;/p&gt;    &lt;p class=&quot;more&quot;&gt;    &lt;a href=&quot;//www.ziroom.com/z/vr/62035032.html&quot; target=&quot;_blank&quot;&gt;查看更多&lt;/a&gt;&lt;/p&gt;   &lt;/div&gt;</code></pre><p>找到了房屋详情的地址(<code>www.ziroom.com/z/vr/62035032.html</code>)，但是价格信息没有找到，没办法，到详情里找一下，发现价格信息的源码如下：</p><pre><code>  &lt;span class=&quot;price&quot;&gt; &lt;b&gt;&lt;/b&gt;   &lt;span class=&quot;room_price&quot; id=&quot;room_price&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;gray-6&quot;&gt;/月(季付)&lt;/span&gt; &lt;/span&gt; </code></pre><p>源码里竟然没有价格信息，然后在审查元素，发现价格信息应该是动态加载的。而且用的还是背景图数字。</p><p><img src="/images/20190420-1.jpg" alt=""></p><p>打开这个图片的连接看一下(<code>http://static8.ziroom.com/phoenix/pc/images/price/81c4fe87c108f9515c4ee4bafff68529s.png</code>)</p><p><img src="/images/20190420-2.jpg" alt=""></p><p>不错，已经找到了价格的初始信息，下面打算提取图片中的数字，然后根据 html 里的偏移量计算出真正的价格。</p><h2 id="2-图片反-OCR-识别"><a href="#2-图片反-OCR-识别" class="headerlink" title="2. 图片反 OCR 识别"></a>2. 图片反 OCR 识别</h2><p>图片信息提取，首先想到的 就是 OCR 识别，而且都是很标准的数字，本来以为难度级别属于 hello world 级别的，但是万万没想到低估了自如网的反爬虫工作</p><p>使用 OCR 识别，一顿操作猛如虎，发现竟然识别不了，直到我把图片转换成纯黑白的，然后才发现了问题。</p><pre><code>    url = &#39;http://static8.ziroom.com/phoenix/pc/images/price/9bbd4bf71c11e7c8149485d9f1ec5adbs.png&#39;    response = requests.get(url)    im = Image.open(io.BytesIO(response.content))    im = im.convert(&#39;1&#39;)    im.show()</code></pre><p>发现图片竟然是下面这种镂空的，难怪 OCR 识别不出来</p><p><img src="/images/20190420-3.jpg" alt=""></p><p>这就有点尴尬了，看到这种图片首先想到的就是 TensorFlow 搞一波图像识别，不过，一个小小的爬虫而已不至于用这么先进的武器吧（其实是我不会而已！^_-），然后又找了几张这种数字图片，对比之下发现，所有的图片，只要数字相同，镂空的规律是一样的，换句话说，所有图片中的数字 1 都是一种镂空的规律！！！ 这就有点意思了，首先想到的就是把图片转成矩阵，然后把矩阵和具体的数字做好映射，持久化下来，之后再次请求到图片，拿图片里的矩阵与持久化后的矩阵做对比，这样就能够解析出图片里的数字了。</p><pre><code>def analyze_img():    url = &#39;http://static8.ziroom.com/phoenix/pc/images/price/9bbd4bf71c11e7c8149485d9f1ec5adbs.png&#39;    response = requests.get(url)    im = Image.open(io.BytesIO(response.content))    im = im.convert(&#39;1&#39;)    im.show()    num = [0,1,4,8,9,3,6,2,7,5]    num_dict = &#123;&#125;    for i in range(10):        data = im.crop((i*30,0,(i+1)*30,30)).getdata()        data = np.matrix(data,dtype=&#39;int&#39;)/255        num_dict[num[i]] =data    fp = open(&#39;num_dict.num&#39;, &#39;wb&#39;)    pickle.dump(num_dict, fp, protocol=-1)    fp.close()    return num_dict</code></pre><p>嗯，买迈进了一小步。不太明白为什么这个图片在镂空的时候没有加一些随机的元素。如果说是由于随机之后出现极端的情况导致不容易被人眼识别，但是可以随机出一个或者两个具体的位置，随机的镂空，这样既不会出现不容易被人眼识别的情况，也能很好的防止上面这种爬虫的出现。</p><p>总之，不管自如网是出于什么考虑，背景图片的数字提取是解决了。下面，就需要找一下这张图片是怎么跟房屋信息绑定的。</p><h2 id="3-动态加载的图片"><a href="#3-动态加载的图片" class="headerlink" title="3. 动态加载的图片"></a>3. 动态加载的图片</h2><p>在 F12 的 网络请求里确实找到了这张图片的请求信息，但是发现，图片的名称是随机串。而且同一个房屋信息，每次请求时的图片名称都不一样，这说明，后台是随机生成的这张图片，没有跟房屋绑定。</p><p><img src="/images/20190420-4.jpg" alt=""></p><p>所以需要找一下，这张图片的请求是从什么地方发起的，请求的 URL 又是从什么地方获取的。</p><p>在 F12 里找到了这张图片的请求位置，但是对比 html 源码发现，并没有这个请求，这说明这个元素是通过 js 动态加载的。</p><p><img src="/images/20190420-5.jpg" alt=""></p><p><img src="/images/20190420-6.jpg" alt=""></p><p>下面就需要找一下，到底是哪个 js 加载的这些信息。重新看了一下，房屋详情页面的源码，发现源码底部，有这样一段 js 的引用。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;   var ZRCONFIG = &#123;    &quot;URL_GET_LOGIN_STATE&quot;:&quot;/user/check-login?url=&quot;,    &quot;URL_GET_LOGIN_STATE&quot;:&quot;/user/check-login?url=&quot;,    &quot;URL_GET_DETAIL_STEWARD&quot;:&quot;/detail/steward?resblock_id=&quot;,    &quot;URL_GET_DETAIL_INFO&quot;:&quot;/detail/info?&quot;,    &quot;PAGE&quot;:&quot;detail&quot;  &#125;;&lt;/script&gt;      &lt;script  type=&quot;text/javascript&quot; src=&quot;//static8.ziroom.com/fecommon/library/jquery/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;//static9.ziroom.com/phoenix/pc/js/2017/common.min.js?1555741850&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;//static8.ziroom.com/phoenix/pc/js/detail.min.js?1555741850&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/api?v=2.0&amp;ak=CB9b776692623d30a148b5c5dc2b75a6&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//static8.ziroom.com/phoenix/pc/js/mappage.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre><p>看命名也可以猜到 ‘datail.min.js’ 里应该有玄机。请求下这个 js 的源码看一下。终于找到了。</p><pre><code>$.ajax(&#123;    type: &quot;GET&quot;,    url: ZRCONFIG.URL_GET_DETAIL_INFO     + &quot;id=&quot; + $(&quot;#room_id&quot;).val()     + &quot;&amp;house_id=&quot; + $(&quot;#house_id&quot;).val(),    success: function(data) &#123;        if (data.code == &quot;200&quot;) &#123;            var dataObj = data.data;            var priceTableList = dataObj.payment;            var listArr = [];            var trClass = &quot;&quot;;            var listStr = &quot;&quot;;            var priceStyle = &quot;&lt;style&gt;.room_price i.num&#123;background-image:url(&quot; + dataObj.price[0] + &quot;);&#125;&quot;             + &quot;body.ratio2 .price i.num&#123;background-image:url(&quot; + dataObj.price[1]             + &quot;);&#125;.pay_price i.num,.text_r i.num&#123;background-image:url(&quot; + priceTableList[0].rent[0] + &quot;);&#125;&quot;             + &quot;body.ratio2 .pay_price i.num,body.ratio2 .text_r i.num&#123;background-image:url(&quot;             + priceTableList[0].rent[1] + &quot;);background-size:auto 14px;&#125;&lt;style&gt;&quot;;            $(&quot;head&quot;).append(priceStyle);            var priceListHtml = &quot;&quot;;            for (var j = 0; j &lt; dataObj.price[2].length; j++) &#123;                priceListHtml += &#39;&lt;i class=&quot;num&quot; style=&quot;background-position:-&#39;                 + (dataObj.price[2][j] * offset_unit)                 + &#39;px&quot;&gt;&lt;/i&gt;&#39;            &#125;... ... (省略其他代码)</code></pre><p>发现这个 js 发起了一个 ajax 请求，请求成功后，不仅设置了图片背景，而且还设置了切图的偏移量。</p><p>终于看到希望了，我们可以直接请求这个 ajax 的地址，不仅能拿到图片，还能拿到价格信息对应图片上的数字的位置。</p><p>ajax 的请求地址是 <code>url: ZRCONFIG.URL_GET_DETAIL_INFO + &quot;id=&quot; + $(&quot;#room_id&quot;).val() + &quot;&amp;house_id=&quot; + $(&quot;#house_id&quot;).val()</code></p><p>其中 ZRCONFIG.URL_GET_DETAIL_INF 值在 房屋详情里的 js 里定义的 ，值为 <code>/detail/info?</code></p><p>room_id 和 house_id 在房屋详情的页面里也能找到:</p><pre><code>&lt;input type=&quot;hidden&quot; value=&quot;7e9285535a7687bf2e71be617cd07466&quot; id=&quot;hide_key&quot; /&gt;&lt;input type=&quot;hidden&quot; value=&quot;&quot; id=&quot;user_sex&quot; /&gt;&lt;input type=&quot;hidden&quot; value=&quot;&quot; id=&quot;user_uid&quot; /&gt;&lt;input type=&quot;hidden&quot; value=&quot;62035032&quot; id=&quot;room_id&quot; /&gt;&lt;input type=&quot;hidden&quot; value=&quot;60321330&quot; id=&quot;house_id&quot; /&gt;&lt;input type=&quot;hidden&quot; value=&quot;110000&quot; id=&quot;current_city_code&quot; /&gt;&lt;input type=&quot;hidden&quot; value=&quot;&quot; id=&quot;ly_name&quot; /&gt;&lt;input type=&quot;hidden&quot; value=&quot;&quot; id=&quot;ly_phone&quot; /&gt;&lt;input type=&quot;hidden&quot; value=&quot;1&quot; id=&quot;house_type&quot; /&gt;&lt;input type=&quot;hidden&quot; id=&quot;resblock_id&quot; value=&quot;1111027374437&quot;/&gt;</code></pre><p>拼接后的最终的 URL 地址是 <code>/detail/info?id=62035032&amp;house_id=60321330</code></p><p>然后拼接上自如网的前缀，就是最终的请求地址，<code>http://www.ziroom.com/detail/info?id=62035032&amp;house_id=60321330</code></p><p>请求一下，终于解决了，价格信息的问题。</p><p><img src="/images/20190420-7.jpg" alt=""></p><h2 id="4-完整思路及代码"><a href="#4-完整思路及代码" class="headerlink" title="4. 完整思路及代码"></a>4. 完整思路及代码</h2><p>下面的问题就简单了，循环分页，筛选出每页里的房屋详情 URL ，然后根据详情里的信息去请求价格信息，最后可以把房屋信息写到 Excel里。就结束了</p><p><a href="https://github.com/zdRan/learning/blob/master/python/ziroom/ziroom.py">完整代码在这里</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(十三) 整合 AOP</title>
      <link href="20190418.html"/>
      <url>20190418.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>AOP 全称 Aspect Oriented Programming ，即面向切面编程。通俗来说，我们可以在一个方法执行之前做一些操作，比如修改一下参数，在一个方法之后做一些操作，比如修改一下返回值。我们可以把这些要做的操作，放到一个类，或者是方法中，这个类或者方法，可以称作一个切面。</p><p>面向切面编程:即我们需要针对这些切面编程。编程的关注点不在于方法的逻辑而在于方法的执行前，执行后的逻辑。</p><p>一个切面大体包括两个部分，切点和在切点处要做的操作（官方叫：通知。一直没有理解这个叫法的含义 ^_^）。</p><p>切点可以以是一个或者一些具体的方法。</p><p>在切点处的操作又分为下面几种情况：</p><ul><li>方法执行前的操作(前置通知)</li><li>方法执行后的操作（后置通知）</li><li>方法抛出异常后 catche 块中的操作（异常通知）</li><li>方法抛出异常后 finally 块中的操作（后置最终通知）</li><li>完全控制方法的操作（环绕通知）</li></ul><h2 id="1-创建一个传统的-Service-服务"><a href="#1-创建一个传统的-Service-服务" class="headerlink" title="1. 创建一个传统的 Service 服务"></a>1. 创建一个传统的 Service 服务</h2><p>创建一个 AopService 接口,实现类的接口如下：</p><pre><code>@Servicepublic class AopServiceImpl implements AopService &#123;    @Override    public AccountInfo aopHello(AccountInfo accountInfo) &#123;        accountInfo.setPwd(&quot;123&quot;);        return accountInfo;    &#125;&#125;</code></pre><p>为了方便测试，我们为这个 Service 创建一个 Controller，代码如下：</p><pre><code>@RestControllerpublic class AopController &#123;    private static Logger logger = LoggerFactory.getLogger(AopController.class);    @Autowired    private AopService aopService;    @GetMapping(&quot;/helloAop/&#123;name&#125;&quot;)    public AccountInfo helloAop(@PathVariable(&quot;name&quot;) String name) &#123;        logger.info(&quot;AOP 接口入参：&#123;&#125;&quot;, name);        AccountInfo accountInfo = new AccountInfo();        accountInfo.setName(name);        accountInfo = aopService.aopHello(accountInfo);        logger.info(&quot;AOP 接口出参：&#123;&#125;&quot;, accountInfo);        return accountInfo;    &#125;&#125;</code></pre><p>下面我们会为 aopHello 这个方法添加切面。对方法的执行前，执行后做一些处理。</p><h2 id="2-创建一个切面"><a href="#2-创建一个切面" class="headerlink" title="2. 创建一个切面"></a>2. 创建一个切面</h2><p>首先需要添加 AOP 的依赖：</p><pre><code>&lt;!-- 引入 aop 支持 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>然后创建一个切面。新建 AopAspect 类，代码如下：</p><pre><code>import org.aspectj.lang.annotation.*;@Aspect@Componentpublic class AopAspect &#123;    private static Logger logger = LoggerFactory.getLogger(AopAspect.class);&#125;</code></pre><p>好了，这个切面是创建好了，现在我们还没有为其指定具体的切点以及切点处的操作</p><h2 id="3-指定切点"><a href="#3-指定切点" class="headerlink" title="3. 指定切点"></a>3. 指定切点</h2><p>我们把这个切点指定到上面创建的 AopServiceImpl 的 aopHello 方法上：</p><pre><code>    /**     * 类 AopServiceImpl 下的 aopHello 方法为切入点     */    @Pointcut(&quot;execution(public * com.zdran.springboot.service.impl.AopServiceImpl.aopHello(..))&quot;)    public void pointCut() &#123;&#125;</code></pre><p>切点表达式。切点表达式可以清晰的表示一个或者一些方法。</p><p>格式: execution([可见性] 返回类型 [声明类型].方法名(参数) [异常])</p><p>支持以下通配符：</p><ul><li>‘*’ 匹配任意字符</li><li>‘+’ 匹配一个或多个字符。一般用于表示某个类的所有子类</li><li>‘..’：一般用于匹配多个包，多个参数</li></ul><p>现在我们为这个切面指定了切点。下面我们定义一些在这个切点处的操作。</p><h2 id="4-前置通知"><a href="#4-前置通知" class="headerlink" title="4. 前置通知"></a>4. 前置通知</h2><p>我们在这个方法执行前做一些操作，国际惯例，先打印个 hello aop</p><pre><code>    /**     * 在方法执行之前执行     *     * @param joinPoint     */    @Before(value = &quot;pointCut()&quot;)    public void doBefore(JoinPoint joinPoint) &#123;        logger.info(&quot;doBefore run: hello aop&quot;);    &#125;</code></pre><p>你也可以将 Before 注解里的 value 值换成 execution 表达式。 意思是这个操作指定在某个切点上。</p><p>代码里的这种做法是把切点抽出来了，你可以理解为把这个切点定义成了一个变量，而不是每次使用的时候直接使用字符串了。</p><p>下面我们对请求参数进行修改。</p><pre><code>    /**     * 在方法执行之前执行     *     * @param joinPoint     */    @Before(value = &quot;pointCut()&quot;)    public void doBefore(JoinPoint joinPoint) &#123;        logger.info(&quot;doBefore run&quot;);        AccountInfo accountInfo = (AccountInfo) joinPoint.getArgs()[0];        logger.info(&quot;AOP:&#123;&#125;&quot;, accountInfo.toString());        accountInfo.setName(&quot;aop&quot;);    &#125;</code></pre><p>joinPoint.getArgs() 返回的是一个数组，我们取第一个参数，强转成 AccountInfo 类型，并且修改参数值。</p><p>可以访问我们之前写的 Controller 测试一下。</p><h2 id="5-后置通知"><a href="#5-后置通知" class="headerlink" title="5. 后置通知"></a>5. 后置通知</h2><p>后置通知是指在方法执行后做的一些操作，代码如下：</p><pre><code>    /**     * 在方法之后执行，可以对方法返回值进行修改     *     * @param point     * @param returnValue     */    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;returnValue&quot;)    public void doAfterReturning(JoinPoint point, AccountInfo returnValue) &#123;        logger.info(&quot;doAfterReturning:&#123;&#125;&quot;, returnValue);        returnValue.setPwd(&quot;doAfterReturning&quot;);    &#125;</code></pre><p>AfterReturning 注解的 returning 属性不是必须的，如果你不需要对方法的返回值进行操作，的话，可以不要这个属性。</p><p>同样的，方法签名里的第二个参数也不是必须的。但是，方法签名里的第二个参数，是与 returning 属性绑定的，所以属性的值和参数名称必须保持一致。</p><p>方法中的第二个参数就是返回值，我们可以直接修改。</p><h2 id="6-后置最终通知"><a href="#6-后置最终通知" class="headerlink" title="6. 后置最终通知"></a>6. 后置最终通知</h2><p>这个通知是在 <strong>方法之外</strong> 的 finally 块中的操作，所以这个操作的执行顺序是在 AfterReturning 之后执行的。</p><pre><code>    /**     * 在方法执行之后执行     *     * @param joinPoint     */    @After(value = &quot;pointCut()&quot;)    public void doAfter(JoinPoint joinPoint) &#123;        logger.info(&quot;doAfter run&quot;);    &#125;</code></pre><p>与 AfterReturning 的最大区别可能就是这个通知不能修改返回值。</p><h2 id="6-异常通知"><a href="#6-异常通知" class="headerlink" title="6. 异常通知"></a>6. 异常通知</h2><p>异常通知，是指当在执行方法时，抛出异常后的操作，或者说是 <strong>方法之外</strong> 的 catche 块中的操作。代码如下：</p><pre><code>    /**     * 在方法抛出异常时执行,执行顺序在 After 之后     *     * @param ex     */    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;ex&quot;)    public void doAfterThrowing(Throwable ex) &#123;        logger.info(&quot;doAfterThrowing run&quot;);        logger.error(&quot;doAfterThrowing:&quot;, ex);    &#125;</code></pre><p>需要注意的是，这个注解的方法是在 After 之后执行的。异常通知不能对返回值做任何操作。</p><p>##7. 环绕通知</p><p>环绕通知相比于上面几个通知是最强大的一个通知。它不仅可以修改参数，修改返回值，还可以决定要不要调用切点处的方法。</p><p>需要注意的是，这个环绕通知是在 前置通知之前执行的。</p><pre><code>    /**     * 环绕通知     *     * @param joinPoint     */    @Around(value = &quot;pointCut()&quot;)    public AccountInfo doAround(ProceedingJoinPoint joinPoint) &#123;        logger.info(&quot;doAround run&quot;);        AccountInfo accountInfo = (AccountInfo) joinPoint.getArgs()[0];        //在方法被执行前，修改参数        accountInfo.setBalance(123);        try &#123;            //执行的实际方法            joinPoint.proceed();        &#125; catch (Throwable throwable) &#123;            return null;        &#125;        //在方法执行后修改返回值        accountInfo.setName(&quot;around&quot;);        return accountInfo;    &#125;</code></pre><p>joinPoint.proceed(); 是实际要执行的方法，即我们 AopServiceImpl.aopHello() 方法，如果你不调用 proceed() 方法就不会执行 aopHello(),这样我们就可以控制到底要不要执行切点处的方法。甚至，我们可以在切点处执行别的方法。</p><h2 id="8-执行顺序"><a href="#8-执行顺序" class="headerlink" title="8. 执行顺序"></a>8. 执行顺序</h2><p>通过上面的一些实例我们可以简单的整理一下这些通知的执行顺序:</p><pre><code>        //@Around        try &#123;            try &#123;                //@Before                method.invoke(..);            &#125; finally &#123;                //@After            &#125;            //@AfterReturning        &#125; catch (Exception e) &#123;            //@AfterThrowing        &#125;</code></pre><p>完整代码见： <a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> AOP </tag>
            
            <tag> Aspect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 性能优化的几条建议</title>
      <link href="20190417.html"/>
      <url>20190417.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-避免使用外键"><a href="#1-避免使用外键" class="headerlink" title="1. 避免使用外键"></a>1. 避免使用外键</h3><p>使用外键时会使锁升级，并行度下降。例如，不使用外键的时候，只需要锁一张表，当使用外键后，需要锁两张表。</p><h3 id="2-将-DISTINCT-值较高的字段设置为索引"><a href="#2-将-DISTINCT-值较高的字段设置为索引" class="headerlink" title="2. 将 DISTINCT 值较高的字段设置为索引"></a>2. 将 DISTINCT 值较高的字段设置为索引</h3><p>DISTINCT 值是指去重后的数量，这个数量越大，说明字段的值重复率越低，索引效果就越好。</p><h3 id="3-将表关联时被关联的字段设置为索引"><a href="#3-将表关联时被关联的字段设置为索引" class="headerlink" title="3. 将表关联时被关联的字段设置为索引"></a>3. 将表关联时被关联的字段设置为索引</h3><p>将被关联的字段设置为索引，可以提高关联表的效率</p><h3 id="4-调整复合索引的字段顺序"><a href="#4-调整复合索引的字段顺序" class="headerlink" title="4. 调整复合索引的字段顺序"></a>4. 调整复合索引的字段顺序</h3><ul><li>将 DISTINCT 值较高的字段设置为前导字段。</li><li>如果 DISTINCT 值相近，将频繁查询的字段往前调。</li><li>如果查询频率相近，将排序字段往前调。</li></ul><p><strong>避免出现 索引跳跃式扫描（index skip sacn）</strong></p><p>例如：我们有一张订单表，我们对订单号、订单状态做了复合索引。但是，索引创建的时候是订单状态列在前，订单号在后。如果我们要根据一个订单号查询时，Oracle 会先在状态 A 中的订单里查该订单，然后在状态 B 中查该订单，以此类推，当在所有的状态中查询结束后合并结果，就是最终的结果，这种情况就是 索引跳跃式扫描。</p><h3 id="5-索引字段尽量避免-NULL-值"><a href="#5-索引字段尽量避免-NULL-值" class="headerlink" title="5. 索引字段尽量避免 NULL 值"></a>5. 索引字段尽量避免 NULL 值</h3><ul><li>在 Oracle 中索引里含有 NULL 值会导致索引失效</li><li>在 MySQL 中索引里含有 NULL 会导致额外的存储开销</li></ul><h3 id="6-尽量避免大事务，超出-UNDO-表空间"><a href="#6-尽量避免大事务，超出-UNDO-表空间" class="headerlink" title="6. 尽量避免大事务，超出 UNDO 表空间"></a>6. 尽量避免大事务，超出 UNDO 表空间</h3><p>UNDO 表空间：在执行事务时，会将参与事务的数据备份到 UNDO 表空间，解决读一致问题。</p><p>如果事务操作的数据量过大，会可能撑爆 UNDO 表空间</p><h3 id="7-SELECT、INSERT-语句要写清楚列名"><a href="#7-SELECT、INSERT-语句要写清楚列名" class="headerlink" title="7. SELECT、INSERT 语句要写清楚列名"></a>7. SELECT、INSERT 语句要写清楚列名</h3><p>如果不写清楚列名，数据库会先查询一次列名。影响 SQL 的执行时间</p><h3 id="8-用-EXISTS-代替-IN"><a href="#8-用-EXISTS-代替-IN" class="headerlink" title="8. 用 EXISTS 代替 IN"></a>8. 用 EXISTS 代替 IN</h3><p>IN 是把外表和内表作hash join，而 EXISTS 是对外表做 loop，每次 loop 再对内表进行查询。</p><h3 id="9-LIKE-使用前端匹配"><a href="#9-LIKE-使用前端匹配" class="headerlink" title="9. LIKE 使用前端匹配"></a>9. LIKE 使用前端匹配</h3><p>使用 LIKE ‘%xxx’,尽量避免使用 LIKE ‘%xxx%’,这种会导致索引失效</p><h3 id="10-尽可能用-UNION-ALL-代替-UNION"><a href="#10-尽可能用-UNION-ALL-代替-UNION" class="headerlink" title="10. 尽可能用 UNION ALL 代替 UNION"></a>10. 尽可能用 UNION ALL 代替 UNION</h3><p>UNION 会对结果进行去重，影响查询效率</p><h3 id="11-左外连接时，尽可能限制左表的数据量"><a href="#11-左外连接时，尽可能限制左表的数据量" class="headerlink" title="11. 左外连接时，尽可能限制左表的数据量"></a>11. 左外连接时，尽可能限制左表的数据量</h3><p>左表的数据量越小，查询结果就越小。</p><p><strong>尽量避免笛卡尔积的情况出现</strong></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 读书笔记(一) 内存划分</title>
      <link href="20190322.html"/>
      <url>20190322.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://zdran.com/20190322.html" target="_blank" rel="noopener">JVM 读书笔记(一) 内存划分</a></li><li><a href="https://zdran.com/20190912.html" target="_blank" rel="noopener">JVM 读书笔记(二) 垃圾收集</a></li></ul><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h2><p>Java 在运行时会将内存划分为若干个区域，粗略的可以将内存划分为堆区和栈区，堆区主要存储 Java 对象。栈区主要记录对象的引用地址。</p><p>其实还有更详细的划分。如下图所示：</p><p><img src="/images/20190321-1.jpg" alt=""></p><h2 id="1-Java-虚拟机栈"><a href="#1-Java-虚拟机栈" class="headerlink" title="1. Java 虚拟机栈"></a>1. Java 虚拟机栈</h2><p>Java 虚拟机栈就是我们之前将内存分为堆区和栈区，这里的栈区就是指的 Java 虚拟机栈。</p><p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链表、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。主要用来存储局部变量表。</p><p>在这个区域会抛出两个异常，如果请求的栈的深度超过了虚拟机允许的最大深度，会抛出 StackOverflowError ,如果无法申请到足够的内存会抛出 OutOfMemoryError 异常。</p><h2 id="2-本地方法栈"><a href="#2-本地方法栈" class="headerlink" title="2. 本地方法栈"></a>2. 本地方法栈</h2><p>与 Java 虚拟机栈类似，本地方法栈是服务于 Native 方法的。为本地方法提供内存，同样也会抛出 StackOverflowError、OutOfMemoryError 异常。</p><h2 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3. 程序计数器"></a>3. 程序计数器</h2><p>程序计数器可以看做当前线程所执行的字节码的行号计数器。字节码的解释器需要通过改变这个值来选取下一条需要执行的字节码指令。程序中的分支、循环，跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><h2 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4. 方法区"></a>4. 方法区</h2><p>方法区是用来存放 JVM 装载的 class 的类信息，包括：类的方法、静态变量、类型信息(接口/父类)，我们使用反射，所需的信息就是从这里获取的。同样的，当方法区无法满足内存需要的时候会抛出 OutOfMemoryError 。</p><h2 id="4-1-运行时常量池"><a href="#4-1-运行时常量池" class="headerlink" title="4.1 运行时常量池"></a>4.1 运行时常量池</h2><p>常量池是方法区的一部分，用于记录编译期生成的各种字面量和符号引用。在 Java 类中使用 final 标识的字段都会放到常量池里。常量池在运行时不是一成不变的。常见的场景是 String 类的 intern 方法。当调用该方法时，JVM 会判断常量池里是否有该对象，有的话直接返回，没有的话，需要把该字符串放入常量池然后再返回。</p><h2 id="5-Java-堆"><a href="#5-Java-堆" class="headerlink" title="5. Java 堆"></a>5. Java 堆</h2><p>右边橙色部分的区域都是 Java 堆。这部分内存是 Java 虚拟机里最大的内存区域。我们之前将内存粗略的划分为堆区和栈区，其中栈区指的是 Java 虚拟机栈，而堆区说的就是 Java 堆。所有的 Java 对象都是在这个区域分配的内存，虚拟机的 GC 动作 大部分都是在这个区域进行的。 </p><p>再细分一下可以将 Java 堆分为新生代和老年代。新生代又可以分为 From Survivor 区、To Survivor 区、Eden 区。</p><p>新生代的 Eden 区、From Survivor 区、To Survivor 区的比值是 8:1:1。</p><p>对象在第一次创建的时候会在新生代分配内存。准确的说是在 Eden 区分配内存。 经过一次 GC 后，没有被回收的对象年龄加 1 并且会从 Eden 区、From Survivor 区转移到 To Survivor 区。 To Survivor 区会成为新的 From Survivor 区。 同样 From Survivor 区会成为新的 To Survivor 区。</p><p><img src="/images/20190321-2.jpg" alt=""></p><p>当年龄超过一定的值后（默认15）会将该对象转移到老年代。</p><p><strong>PS:并不是所有对象在第一次创建的时候都会在新生代分配内存，有些对象大到超过新生代的内存时，会直接在老年代分配内存</strong></p><h2 id="6-一个对象的诞生"><a href="#6-一个对象的诞生" class="headerlink" title="6. 一个对象的诞生"></a>6. 一个对象的诞生</h2><p>当 JVM 通过程序计数器的行号读取到一条 new 指令的时候，首先会去方法区寻找这个类是否被加载、解析、初始化过，如果没有的话需要先进行类的加载。</p><p>类被加载之后需要在 Java 堆中分配内存，如果 Java 堆中的内存是非常规整的，记录着使用和未使用区域的分界线，那么内存分配仅仅是将分界线向没有使用的内存方向移动一段距离就可以了。这种方式称为”指针碰撞”。如果内存并不是规整的，那么虚拟机就需要单独维护一个列表，用来记录哪些内存是可用的。在分配的时候通过这个列表找到足够大的一块内存分配给该对象。这种方式称为”空闲列表”。</p><p>这里还需要注意一个并发的问题。如果 A 对象正在分配内存，指针位置还没有来得及修改，B 对象又从原来的位置开始分配内存。</p><p>为了解决这个问题，有两种方案。一种是将内存分配进行同步处理。保证内存分配的原子性。另外一种解决方式是根据线程的不同，将分配内存的动作划分到不同的区域。每个线程都在自己的内存区域申请内存。这个区域称为本地线程分配缓冲(TLAB)。当这部分区域的内存不够时再进行同步申请新的区域。</p><p>内存分配完成后，虚拟机将内存初始化为 0 值，一些属性的默认值都是在这一步赋值的。比如 int 类型、boolean 类型的默认值等。</p><p>然后需要对对象进行必要的设置。比如说对象的年龄、对象的哈希值、对象的类的信息等。这部分数据保存在对象头中</p><h2 id="7-对象的访问"><a href="#7-对象的访问" class="headerlink" title="7. 对象的访问"></a>7. 对象的访问</h2><p>对象创建结束后，有两种方式来访问我们创建的对象。使用句柄和直接指针。</p><h3 id="7-1-使用句柄访问。"><a href="#7-1-使用句柄访问。" class="headerlink" title="7.1 使用句柄访问。"></a>7.1 使用句柄访问。</h3><p>如果使用句柄访问的话虚拟机会多划出一块内存用来做句柄池。Java 虚拟机栈中记录的就是对象的句柄地址。如下图所示：</p><p><img src="/images/20190321-3.jpg" alt=""></p><h3 id="7-2-直接指针访问"><a href="#7-2-直接指针访问" class="headerlink" title="7.2 直接指针访问"></a>7.2 直接指针访问</h3><p>使用直接指针访问时，Java 虚拟机的栈中记录的是对象在 Java 堆中的直接地址。如下图所示：</p><p><img src="/images/20190321-4.jpg" alt=""></p><p>这两种方式各有优点，使用句柄访问时在对象移动的时候（GC时）只需要改变句柄的值就可以了，而 Java 栈中的引用地址可以不用改变。</p><p>直接指针方式最大的好处就是速度快，它减少了一次指针定位的时间开销。</p><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h2><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">深入理解Java虚拟机（第2版）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>37. Sudoku Solver</title>
      <link href="20190321.html"/>
      <url>20190321.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/leetcode">刷题仓库地址</a></li><li><a href="https://zdran.com/20180327.html">4. Median of Two Sorted Arrays</a></li><li><a href="https://zdran.com/20180328.html">10. Regular Expression Matching</a></li><li><a href="https://zdran.com/20180329.html">23. Merge k Sorted Lists</a></li><li><a href="https://zdran.com/20180330.html">25. Reverse Nodes in k-Group</a></li><li><a href="https://zdran.com/20180331.html">30. Substring with Concatenation of All Words</a></li><li><a href="https://zdran.com/20180401.html">32. Longest Valid Parentheses</a></li><li><a href="https://zdran.com/20190321.html">37. Sudoku Solver</a></li></ul><hr><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>Empty cells are indicated by the character ‘.’.</p><p>You may assume that there will be only one unique solution.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="$xslt"></code></pre><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>编写一个程序，通过填充空单元格来解决数独谜题。 空单元格由字符’。’表示。 </p><p>数独只有一个解</p><h2 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h2><p>使用3个二维数组，分别记录 每一行、每一列、每个小九宫格里已经出现的数字。下标代表数字，值代表是否出现过</p><p>然后使用 DSF。对每个需要填充的单元格进行递归。递归时根据之前统计的3个二维数组来判断应该填哪个数字</p><h2 id="Accept-Code"><a href="#Accept-Code" class="headerlink" title="Accept Code"></a>Accept Code</h2><pre><code>    public static boolean filling(char[][] board, int[][] row, int[][] col, int[][] square) &#123;        for (int i = 0; i &lt; 9; i++) &#123;            for (int j = 0; j &lt; 9; j++) &#123;                if (board[i][j] == &#39;.&#39;) &#123;                    for (int k = 0; k &lt; 9; k++) &#123;                        int sIndex = i / 3 * 3 + j / 3;                        if (row[i][k] == 0 &amp;&amp; col[j][k] == 0 &amp;&amp; square[sIndex][k] == 0) &#123;                            board[i][j] = ((k + 1) + &quot;&quot;).charAt(0);                            row[i][k] = col[j][k] = square[sIndex][k] = 1;                            if (filling(board, row, col, square)) &#123;                                return true;                            &#125; else &#123;                                board[i][j] = &#39;.&#39;;                                row[i][k] = col[j][k] = square[sIndex][k] = 0;                            &#125;                        &#125;                    &#125;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;    public static void solveSudoku(char[][] board) &#123;        int[][] row = new int[9][9];        int[][] col = new int[9][9];        int[][] square = new int[9][9];        //init array        for (int i = 0; i &lt; 9; i++) &#123;            for (int j = 0; j &lt; 9; j++) &#123;                if (board[i][j] != &#39;.&#39;) &#123;                    int num = board[i][j] - &#39;0&#39; - 1;                    //根据 i、j 计算属于第几个九宫格                    int sIndex = i / 3 * 3 + j / 3;                    row[i][num] = col[j][num] = square[sIndex][num] = 1;                &#125;            &#125;        &#125;        filling(board, row, col, square);    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂方法模式</title>
      <link href="20190222.html"/>
      <url>20190222.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h2><p>假如我们有一个商城的项目，这个项目里的商品不是我们自己维护的，后端需要对接京东、淘宝、天猫等供应商。考虑了一下，这种情况可以使用简单工厂模式来实现。</p><h2 id="2-设计"><a href="#2-设计" class="headerlink" title="2. 设计"></a>2. 设计</h2><p>类设计图入下图：</p><p><img src="/images/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="简单工厂模式结构图"></p><p>每一个供应商都是一个 具体的产品，抽象产品是 Mall 类，具体的产品是 JDMall、TBMall。</p><p>工厂类是 MallFactory, 根据传过来的不同供应商的渠道产生具体的 Mall。</p><h2 id="3-代码结构"><a href="#3-代码结构" class="headerlink" title="3. 代码结构"></a>3. 代码结构</h2><p>平台入口Controller代码:</p><pre><code>public class MallController &#123;    public Goods getGoodsInfo(String sku, String channel) &#123;        Mall mall = MallFactory.getMall(channel);        if (mall == null) &#123;            return null;        &#125;        return mall.getGoodsInfo(sku);    &#125;    public Order submitOrder(List&lt;Goods&gt; goods) &#123;        Mall mall = MallFactory.getMall(channel);        if (mall == null) &#123;            return null;        &#125;        return mall.submitOrder(goods);    &#125;    //其他接口&#125;</code></pre><p>工厂类 MallFactory 代码：</p><pre><code>public class MallFactory &#123;    public static Mall getMall(String name) &#123;        if (&quot;JD&quot;.equals(name)) &#123;            return new JDMall();        &#125;        if (&quot;TM&quot;.equals(name)) &#123;            return new TBMall();        &#125;        return null;    &#125;&#125;</code></pre><p>具体的产品 ，京东API 接口：</p><pre><code>public class JDMall implements Mall &#123;    @Override    public Goods getGoodsInfo(String sku) &#123;        //获取对应供应商需要的参数        Map&lt;String, String&gt; extend = new HashMap&lt;&gt;();        String result = HttpClientUtil.getMethod(&quot;jd/url/getGoodsInfo&quot;, extend);        return this.getGoodsByResult(result);    &#125;    @Override    public Order submitOrder(List&lt;Goods&gt; goods) &#123;        //获取对应供应商需要的参数        Map&lt;String, String&gt; extend = new HashMap&lt;&gt;();        String result = HttpClientUtil.getMethod(&quot;jd/url/submitOrder&quot;, extend);        return this.getOrderByResult(result);    &#125;    //格式化返回值，适配本地模型    private Goods getGoodsByResult(String result) &#123;        return new Goods();    &#125;    //格式化返回值，适配本地模型    private Order getOrderByResult(String result) &#123;        return new Order();    &#125;&#125;</code></pre><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4. 完整代码"></a>4. 完整代码</h2><p><a href="https://github.com/zdRan/learning/tree/master/SimpleFactoryPattern">完整代码在这里</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 学习笔记(二) Container 组件</title>
      <link href="20190215.html"/>
      <url>20190215.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Flutter 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180625.html">Flutter 学习笔记(零) 搭建 Flutter 环境</a></li><li><a href="https://zdran.com/20190214.html">Flutter 学习笔记(一) Text 组件</a></li><li><a href="https://zdran.com/20190215.html">Flutter 学习笔记(二) Container 组件</a></li></ul><h2 id="1-Container-组件简介"><a href="#1-Container-组件简介" class="headerlink" title="1. Container 组件简介"></a>1. Container 组件简介</h2><pre><code>一个拥有绘制、定位、调整大小的 widget。是一个容器组件，内部可以包含其他的 widget</code></pre><h2 id="2-Container-属性"><a href="#2-Container-属性" class="headerlink" title="2. Container 属性"></a>2. Container 属性</h2><h3 id="2-1-alignment-属性"><a href="#2-1-alignment-属性" class="headerlink" title="2.1 alignment 属性"></a>2.1 alignment 属性</h3><pre><code>容器内的组件在容器内的对齐方式。可选值有：</code></pre><ul><li><p>Alignment.topLeft、 Alignment.topCenter、 Alignment.topRight</p><p>  顶部左对齐，居中，右对齐</p></li><li><p>Alignment.centerLeft、 Alignment.center Alignment.centerRight</p><p>  中部左对齐，居中，右对齐</p></li><li><p>Alignment.bottomLeft、 Alignment.bottomCenter、 Alignment.bottomRight</p><p>  底部左对齐，居中，右对齐</p></li></ul><h3 id="2-2-constraints-属性"><a href="#2-2-constraints-属性" class="headerlink" title="2.2 constraints 属性"></a>2.2 constraints 属性</h3><pre><code>限制子节点的宽高。属性是一个 BoxConstraints 对象</code></pre><h3 id="2-3-color-属性"><a href="#2-3-color-属性" class="headerlink" title="2.3 color 属性"></a>2.3 color 属性</h3><pre><code>设置容器的背景色</code></pre><h3 id="2-4-decoration"><a href="#2-4-decoration" class="headerlink" title="2.4 decoration"></a>2.4 decoration</h3><pre><code>在子节点下方装饰。可以设置边框。设置背景色当设置边框后,子节点会自动调整位置。属性是一个 Decoration 对象.</code></pre><p><strong>PS:这个属性跟 color 值冲突,必须有一个值为空</strong></p><h3 id="2-5-foregroundDecoration"><a href="#2-5-foregroundDecoration" class="headerlink" title="2.5 foregroundDecoration"></a>2.5 foregroundDecoration</h3><pre><code>在子节点上方设置装饰,比如边框,背景色。当设置边框后,子节点不会调整位置,有可能会被边框覆盖。</code></pre><h3 id="2-6-padding-与-margin"><a href="#2-6-padding-与-margin" class="headerlink" title="2.6 padding 与 margin"></a>2.6 padding 与 margin</h3><pre><code>内边距和外边距,参见 HTML 的盒子模型属性是一个 EdgeInsetsGeometry 对象</code></pre><h2 id="3-Decoration"><a href="#3-Decoration" class="headerlink" title="3 Decoration"></a>3 Decoration</h2><pre><code>设置容器组件的装饰.因为这是一个抽象类,不能直接使用,可以使用它的子类 BoxDecoration</code></pre><h3 id="3-1-color"><a href="#3-1-color" class="headerlink" title="3.1 color"></a>3.1 color</h3><pre><code>设置容器的背景色。所以这个属性与 Container 组件的 color 属性冲突.</code></pre><h3 id="3-2-image"><a href="#3-2-image" class="headerlink" title="3.2 image"></a>3.2 image</h3><pre><code>设置字体颜设置背景图片</code></pre><h3 id="3-3-border"><a href="#3-3-border" class="headerlink" title="3.3 border"></a>3.3 border</h3><pre><code>设置边框。属性是一个 Border 对象,可以设置上下左右四个方向的边框的宽度和颜色.</code></pre><h3 id="3-4-gradient"><a href="#3-4-gradient" class="headerlink" title="3.4 gradient"></a>3.4 gradient</h3><pre><code>填充背景色时使用的渐变方式。有三个取值</code></pre><ul><li><p>LinearGradient</p><p>  线性渐变,设置起始位置和渐变色集合</p></li><li><p>RadialGradient</p><p>  放射见便,以中心为原点向外发散渐变,可以设置发散的半径</p></li><li><p>SweepGradient</p><p> 扫描渐变,以水平x轴正向方向为起点,扫描到指定的角度。</p><p> 可以设置起始角度,结束角度,中心点。</p></li></ul><p><strong>PS: 角度的单位是弧度,不是度</strong><br><strong>PS: 这里有个小问题,设置的起始角度有可能不生效!!</strong><br><a href="https://github.com/flutter/flutter/issues/23648">参考 GitHub 上的 issues</a></p><h2 id="4-TextDemo-源码"><a href="#4-TextDemo-源码" class="headerlink" title="4 TextDemo 源码"></a>4 TextDemo 源码</h2><pre><code>import &#39;package:flutter/material.dart&#39;;import &#39;ContainerDemo.dart&#39;;void main() =&gt; runApp(ContainerDemo());class ContainerDemo extends StatelessWidget &#123;  @override  Widget build(BuildContext context) &#123;    var boxConstraints = BoxConstraints.expand(height: 311,width: 311);    var background = Paint();    background.color = Colors.green;    var edgeInset =EdgeInsets.only(left: 110,right: 100,bottom: 100,top: 200);    var gradColorList =List&lt;Color&gt;();    gradColorList.add(Colors.blueAccent);    gradColorList.add(Colors.orange);    gradColorList.add(Colors.white);    gradColorList.add(Colors.white);    var linear =LinearGradient(        colors: gradColorList,        begin: Alignment.bottomRight    );    var radial = RadialGradient(      colors: gradColorList,      radius: 2,    );    var sweep = SweepGradient(      colors: gradColorList,      //startAngle:,      endAngle:7,      center: Alignment.center    );    var decoraion = BoxDecoration(      color: Colors.pinkAccent,      border: Border(        top: BorderSide(width: 50,color: Colors.lightGreen),        right: BorderSide(width: 20,color: Colors.pink),        left: BorderSide(width: 30,color: Colors.teal),        bottom:BorderSide(width: 30,color: Colors.lightGreen),      ),      gradient: sweep      );      return MaterialApp(        title: &#39;Container Demo&#39;,        home: Scaffold(          body: Center(            child: Container(              child: Text(&#39;hello Container&#39;,style: TextStyle(                fontSize: 22,                background: background                )),              constraints:boxConstraints,              //color: Colors.blueGrey,              //在子节点下方绘制,子节点会调整位置              decoration: decoraion,              //在子节点上方绘制,子节点不动,可能会被覆盖              //foregroundDecoration :decoraion,              padding: edgeInset,              //margin: edgeInset,              alignment: Alignment.bottomCenter,            ),          ),        ),      );  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Container </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 学习笔记(一) Text 组件</title>
      <link href="20190214.html"/>
      <url>20190214.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Flutter 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180625.html">Flutter 学习笔记(零) 搭建 Flutter 环境</a></li><li><a href="https://zdran.com/20190214.html">Flutter 学习笔记(一) Text 组件</a></li><li><a href="https://zdran.com/20190215.html">Flutter 学习笔记(二) Container 组件</a></li></ul><h2 id="1-Text-组件简介"><a href="#1-Text-组件简介" class="headerlink" title="1. Text 组件简介"></a>1. Text 组件简介</h2><pre><code>Text 组件显示单个样式的文本字符串。字符串可能会跨越多行，也可能全部显示在同一行上，具体取决于布局约束。</code></pre><h2 id="2-Text-属性"><a href="#2-Text-属性" class="headerlink" title="2. Text 属性"></a>2. Text 属性</h2><h3 id="2-1-data-属性"><a href="#2-1-data-属性" class="headerlink" title="2.1 data 属性"></a>2.1 data 属性</h3><pre><code>该 Text 要显示的文本。值为一串字符串。</code></pre><h3 id="2-2-textAlign-属性"><a href="#2-2-textAlign-属性" class="headerlink" title="2.2 textAlign 属性"></a>2.2 textAlign 属性</h3><pre><code>文本的对齐方式。可选值有：</code></pre><ul><li><p>TextAlign.start</p></li><li><p>TextAlign.end、</p><p>  这两个值与文本对齐的方向有关，如果方向是从左向右的，那么start就是左对齐，end就是右对齐。反之亦然</p></li><li><p>TextAlign.left</p></li><li><p>TextAlign.right</p><p>  这两个值跟文本方向无关，left 是左对齐，right是右对齐</p></li><li><p>TextAlign.center</p><p>  文本居中</p></li><li><p>TextAlign.justify</p><p>  文本两端对齐</p></li></ul><p>PS： 对齐方式可以参考 word 里的对齐方式</p><h3 id="2-3-textDirection"><a href="#2-3-textDirection" class="headerlink" title="2.3 textDirection"></a>2.3 textDirection</h3><pre><code>该文本的对齐方向。</code></pre><ul><li><p>TextDirection.ltr</p><p>  如果 textAlign 的属性是 start 则左对齐，end 是右对齐</p></li><li><p>TextDirection.rtl</p><p>  如果 textAlign 的属性是 start 则右对齐，end 是左对齐</p></li></ul><h3 id="2-4-maxLines"><a href="#2-4-maxLines" class="headerlink" title="2.4 maxLines"></a>2.4 maxLines</h3><pre><code>最大行。最多显示的行数</code></pre><h3 id="2-5-overflow"><a href="#2-5-overflow" class="headerlink" title="2.5 overflow"></a>2.5 overflow</h3><pre><code>处理溢出的文本方式</code></pre><ul><li><p>TextOverflow.ellipsis</p><p>  以 … 显示。 例如： xxx…</p></li><li><p>TextOverflow.clip</p><p>  直接剪切溢出的文本</p></li><li><p>TextOverflow.fade </p><p>  将溢出的文本淡化为透明</p></li></ul><h3 id="2-6-textScaleFactor"><a href="#2-6-textScaleFactor" class="headerlink" title="2.6 textScaleFactor"></a>2.6 textScaleFactor</h3><pre><code>每个逻辑像素的字体像素数</code></pre><h2 id="3-Text-Style"><a href="#3-Text-Style" class="headerlink" title="3 Text Style"></a>3 Text Style</h2><pre><code>Text 组件的样式</code></pre><h3 id="3-1-background"><a href="#3-1-background" class="headerlink" title="3.1 background"></a>3.1 background</h3><pre><code>设置 Text 的背景。值是一个 Paint 对象。可以设置 Paint 对象的 color属性来设置 Text 的背景色</code></pre><h3 id="3-2-color"><a href="#3-2-color" class="headerlink" title="3.2 color"></a>3.2 color</h3><pre><code>设置字体颜色</code></pre><h3 id="3-3-decoration"><a href="#3-3-decoration" class="headerlink" title="3.3 decoration"></a>3.3 decoration</h3><pre><code>设置文本装饰，上划线、下划线、中划线等。</code></pre><h3 id="3-4-decorationColor"><a href="#3-4-decorationColor" class="headerlink" title="3.4 decorationColor"></a>3.4 decorationColor</h3><pre><code>上划线、下划线、中划线等线条的颜色</code></pre><h3 id="3-5-decorationStyle"><a href="#3-5-decorationStyle" class="headerlink" title="3.5 decorationStyle"></a>3.5 decorationStyle</h3><pre><code>文本装饰的样式。虚线、短横线、波浪线等</code></pre><ul><li><p>TextDecorationStyle.dashed</p><p>  画一条虚线。例如 ————–</p></li><li><p>TextDecorationStyle.dotted</p><p>  画一条带点的虚线 例如 …………</p></li><li><p>TextDecorationStyle.solid </p><p>  画一条实线。例如 <code>_______________</code></p></li><li><p>TextDecorationStyle.double </p><p>  画两条实线。</p></li><li><p>TextDecorationStyle.wavy</p><p>  画两条波浪线</p></li></ul><h3 id="3-6-fontSize"><a href="#3-6-fontSize" class="headerlink" title="3.6 fontSize"></a>3.6 fontSize</h3><pre><code>字体大小</code></pre><h3 id="3-7-fontStyle"><a href="#3-7-fontStyle" class="headerlink" title="3.7 fontStyle"></a>3.7 fontStyle</h3><pre><code>字体样式。斜体和标准样式</code></pre><ul><li><p>FontStyle.italic</p><p>  斜体</p></li><li><p>FontStyle.normal</p><p>  标准字体</p></li></ul><h3 id="3-8-fontWeight"><a href="#3-8-fontWeight" class="headerlink" title="3.8 fontWeight"></a>3.8 fontWeight</h3><pre><code>字体粗细</code></pre><ul><li><p>FontWeight.w100 - w900</p><p>  FontWeight.w100 最细 FontWeight.w900 最粗</p></li></ul><h3 id="3-9-foreground"><a href="#3-9-foreground" class="headerlink" title="3.9 foreground"></a>3.9 foreground</h3><pre><code>Text 前景色，即字体颜色。值为一个 Paint 对象，类似于 background 属性</code></pre><p><strong>PS：这个属性与 color冲突，二者不能共存，必须有一个值为 null。</strong></p><h3 id="3-10-height"><a href="#3-10-height" class="headerlink" title="3.10 height"></a>3.10 height</h3><pre><code>类似于 word 里的行间距。这个值是 行高的倍数。如果 值是 1.5 则行间距是 1.5 倍的行高</code></pre><h3 id="3-11-letterSpacing"><a href="#3-11-letterSpacing" class="headerlink" title="3.11 letterSpacing"></a>3.11 letterSpacing</h3><pre><code>字母与字母之间的间距。单位是逻辑像素。 例如 h  e   l   l   o</code></pre><h3 id="3-12-wordSpacing"><a href="#3-12-wordSpacing" class="headerlink" title="3.12 wordSpacing"></a>3.12 wordSpacing</h3><pre><code>单词与单词之间的间距。单位是逻辑像素例如 hello      world</code></pre><h2 id="4-shadows"><a href="#4-shadows" class="headerlink" title="4 shadows"></a>4 shadows</h2><pre><code>文字阴影。PS：这个值的属性是 List&lt;Shadow&gt;。也就是说可以退添加多个阴影</code></pre><h3 id="4-1-color"><a href="#4-1-color" class="headerlink" title="4.1 color"></a>4.1 color</h3><pre><code>阴影颜色</code></pre><h3 id="4-2-offset"><a href="#4-2-offset" class="headerlink" title="4.2 offset"></a>4.2 offset</h3><pre><code>阴影在 x轴和y轴的偏移量</code></pre><h3 id="4-3-blurRadius"><a href="#4-3-blurRadius" class="headerlink" title="4.3 blurRadius"></a>4.3 blurRadius</h3><pre><code>阴影模糊度</code></pre><h2 id="5-TextDemo-源码"><a href="#5-TextDemo-源码" class="headerlink" title="5 TextDemo 源码"></a>5 TextDemo 源码</h2><pre><code>import &#39;package:flutter/material.dart&#39;;void main() =&gt; runApp(TextDemo());class TextDemo extends StatelessWidget&#123;  @override  Widget build(BuildContext context) &#123;    var background = Paint();    background.color = Color.fromARGB(111, 255, 1, 1);    var foreground = Paint();    foreground.color =  Color.fromARGB(255, 1, 122, 11);    var shadowsList = List&lt;Shadow&gt;();    shadowsList.add(Shadow(      color: Color.fromARGB(111, 255, 1, 1),      offset: Offset(1, 20),      blurRadius:1));    shadowsList.add(Shadow(      color: Color.fromARGB(255, 1, 122, 11),      offset: Offset(20, 1),      blurRadius:10));    return MaterialApp(      title: &#39;Text Demo&#39;,      home: Scaffold(        body: Center(          child: Text(            &#39;hello ,text,好好学习,天天向上!好好学习,天天向上!好好学习,天天向上!好好学习,天天向上!好好学习,天天向上&#39;,            textAlign: TextAlign.start,            textDirection: TextDirection.rtl,            maxLines: 2,            overflow: TextOverflow.fade ,            //textScaleFactor: 1,            style: TextStyle(              //background: background,              //color: Color.fromARGB(255, 1, 122, 11),              decoration: TextDecoration.underline,              decorationColor: Color.fromRGBO(255, 1, 1, 11),              decorationStyle: TextDecorationStyle.wavy ,              fontSize: 44,              fontStyle: FontStyle.normal,              fontWeight: FontWeight.w900,              //与color 值冲突              foreground: foreground,              height: 1.5,              letterSpacing: 11,              //shadows: shadowsList,              wordSpacing: 122              ),              ),        ),      ),    );  &#125;&#125; </code></pre>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo 学习笔记(三) Spring Boot 整合 Dubbo(官方版)</title>
      <link href="20190212.html"/>
      <url>20190212.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Dubbo 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20181102.html">Dubbo 学习笔记(零) 自己实现一个 RPC 框架</a></li><li><a href="https://zdran.com/20181113.html">Dubbo 学习笔记(一) Hello,Dubbo</a></li><li><a href="https://zdran.com/20181216.html">Dubbo 学习笔记(二) Spring Boot 整合 Dubbo</a></li><li><a href="https://zdran.com/20190212.html">Dubbo 学习笔记(三) Spring Boot 整合 Dubbo(官方版)</a></li></ul><hr><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>这次使用的是 Apache 推出的 Spring Boot 与 Dubbo 整合的依赖。</p><ul><li><a href="https://github.com/apache/incubator-dubbo-spring-boot-project">https://github.com/apache/incubator-dubbo-spring-boot-project</a></li><li>最新的版本是 0.2.1 </li><li>star:2383</li></ul><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.2.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>创建一个项目，三个模块分别是服务提供者、服务消费者、服务暴露的API。</p><p>项目结构：</p><pre><code>official    |-official-api    |-official-account-provider    |-official-web</code></pre><p>主 POM 的依赖：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.zdran.duboot&lt;/groupId&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;artifactId&gt;official&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;official&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;spring-boot.version&gt;2.1.1.RELEASE&lt;/spring-boot.version&gt;        &lt;dubbo.version&gt;2.6.5&lt;/dubbo.version&gt;    &lt;/properties&gt;    &lt;modules&gt;        &lt;module&gt;official-api&lt;/module&gt;        &lt;module&gt;official-account-provider&lt;/module&gt;        &lt;module&gt;official-web&lt;/module&gt;    &lt;/modules&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h2 id="2-配置服务提供者"><a href="#2-配置服务提供者" class="headerlink" title="2. 配置服务提供者"></a>2. 配置服务提供者</h2><p>添加依赖：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;com.zdran.duboot&lt;/groupId&gt;        &lt;artifactId&gt;official&lt;/artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.zdran.official&lt;/groupId&gt;    &lt;artifactId&gt;account-provider&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;account-provider&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring-boot.version&gt;2.1.1.RELEASE&lt;/spring-boot.version&gt;        &lt;dubbo.version&gt;2.6.5&lt;/dubbo.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.zdran.duboot&lt;/groupId&gt;            &lt;artifactId&gt;official-api&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Dubbo Spring Boot Starter --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;0.2.1.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.netty&lt;/groupId&gt;            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;            &lt;version&gt;2.11.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>更新 <code>application.yml</code> 的配置：</p><pre><code>server:  port: 8086dubbo:  application:    name: Provide  registry:    address: zookeeper://39.105.78.88:2181  protocol:    name: dubbo    port: 20880  scan:    base-packages: com.zdran.official.user.service </code></pre><p><strong>注意：配置项是 dubbo.xxx,不是 spring.dubbo.xxx</strong></p><p>实现 Service:</p><pre><code>package com.zdran.official.user.service;import com.alibaba.dubbo.config.annotation.Service;import com.zdran.duboot.official.api.OfficialHelloApi;/** * Create by ranzd on 2019/1/28 * * @author ranzd@chinaunicom.cn */@Service(version = &quot;1.0&quot;, timeout = 50000)public class OfficialHelloApiImpl implements OfficialHelloApi &#123;    @Override    public String sayHello(String name) &#123;        return &quot;helll, &quot; + name;    &#125;&#125;</code></pre><p><strong>接口定义在了official-api模块</strong></p><h2 id="3-实现消费者"><a href="#3-实现消费者" class="headerlink" title="3. 实现消费者"></a>3. 实现消费者</h2><p>添加依赖：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.zdran.official&lt;/groupId&gt;    &lt;artifactId&gt;web&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;web&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;dubbo.version&gt;2.6.5&lt;/dubbo.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.zdran.duboot&lt;/groupId&gt;            &lt;artifactId&gt;official-api&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- Dubbo Spring Boot Starter --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;0.2.1.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.netty&lt;/groupId&gt;            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;            &lt;version&gt;2.11.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>注意：curator-framework 这个依赖跟使用的zk版本有关系</strong></p><p>curator-framework 2.x.x 支持的zk版本为 3.4.x 和3.5.x<br>curator-framework 3.x.x 支持的zk版本为 3.5.x </p><p>更新 <code>application.yml</code> 的配置：</p><pre><code>server:  port: 8085dubbo:  application:    name: conusmer  registry:    address: zookeeper://39.105.78.88:2181  protocol:    name: dubbo    port: 20880  scan:    base-packages: com.zdran.official.web</code></pre><p>创建消费者的服务</p><pre><code>package com.zdran.official.web.controller;import com.alibaba.dubbo.config.annotation.Reference;import com.zdran.duboot.official.api.OfficialHelloApi;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;/** * Create by ranzd on 2019/1/29 * * @author ranzd@chinaunicom.cn */@RestControllerpublic class AccountController &#123;    @Reference(version = &quot;1.0&quot;)    private OfficialHelloApi officialHelloApi;    @GetMapping(&quot;/account/&#123;name&#125;&quot;)    public String sayHello(@PathVariable(name = &quot;name&quot;) String name) &#123;        return officialHelloApi.sayHello(name);    &#125;&#125;</code></pre><p>先启动生产者，再启动消费者，启动的时候如果看到 下面的日志说明启动成功了：</p><pre><code>2019-02-12 11:09:14.780  INFO 3428 --- [           main] a.b.d.c.e.WelcomeLogoApplicationListener :  :: Dubbo Spring Boot (v0.2.1.RELEASE) : https://github.com/apache/incubator-dubbo-spring-boot-project :: Dubbo (v2.6.5) : https://github.com/apache/incubator-dubbo :: Discuss group : dev@dubbo.apache.org2019-02-12 11:09:14.783  INFO 3428 --- [           main] e.OverrideDubboConfigApplicationListener : Dubbo Config was overridden by externalized configuration &#123;dubbo.application.name=Provide, dubbo.application.qos-enable=false, dubbo.config.multiple=true, dubbo.protocol.name=dubbo, dubbo.protocol.port=20880, dubbo.registry.address=zookeeper://39.105.78.88:2181, dubbo.scan.base-packages=com.zdran.official.user.service&#125;</code></pre><p>访问一下 <code>http://localhost:8085/account/dubbo</code> 试试。</p><h2 id="4-一个疑问"><a href="#4-一个疑问" class="headerlink" title="4. 一个疑问"></a>4. 一个疑问</h2><p>有个比较疑惑的地方一直没有搞明白。就是 curator-framework 这个依赖。</p><p>明明在 dubbo-spring-boot-starter 里是包含这个依赖的，不知道为什么还需要重新引入？</p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> ZooKeeper </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给 2018 画个句号</title>
      <link href="20190101.html"/>
      <url>20190101.html</url>
      
        <content type="html"><![CDATA[<p>转眼之间18年已经过去了。这一年里收获了很多东西。也认识了很多人。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>这一年我经历了从一个技术小白到入门的过程。是很充实的一年。</p><p>这一年里，我学会了如何用SVN、GIT管理项目代码，</p><p>如何用Maven管理项目的依赖，</p><p>如何使用Redis控制并发，</p><p>了解了RPC框架，了解了微服务，学会了如何用 Spring Boot 开发一个微服务的项目，</p><p>了解了是ELK框架，学会了如何用ES开发一个简单的搜索功能。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>这一年我开通了自己的 <a href="https://zdran.com/" target="_blank" rel="noopener">个人博客</a>，并申请了自己的域名。更新了 37 篇博客，同步的 <a href="https://juejin.im/user/5a55b34cf265da3e4d72973b" target="_blank" rel="noopener">个人掘金账号</a> 获得了 1125 个粉丝。</p><p>这一年里我学习了Python爬虫，并且喜欢上爬虫，可以用Python做一些简单的爬虫。</p><p>这一年里我读完了2本书。一本是技术类的《Effective Java中文版》。一本是一部悬疑小说《无人生还》。</p><p>这一年里我在 LeetCode 上刷了70+道题。</p><h2 id="2018-Bye。"><a href="#2018-Bye。" class="headerlink" title="2018,Bye。"></a>2018,Bye。</h2><p>如果要给这一年定义一个关键词的话，我觉得是 “充实”。</p><h2 id="Hello-2019"><a href="#Hello-2019" class="headerlink" title="Hello,2019"></a>Hello,2019</h2><p>2019年，一个新的开始。我要给自己定几个目标。</p><ol><li>练一手好字。</li><li>每天坚持学英语。</li><li>读完5本技术类的书籍。</li><li>读完3本小说。</li><li>每周坚持更新博客。</li><li>周末一定不要宅在家 * 3 (重要的事情说3遍)。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo 学习笔记(二) Spring Boot 整合 Dubbo</title>
      <link href="20181216.html"/>
      <url>20181216.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Dubbo 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20181102.html">Dubbo 学习笔记(零) 自己实现一个 RPC 框架</a></li><li><a href="https://zdran.com/20181113.html">Dubbo 学习笔记(一) Hello,Dubbo</a></li><li><a href="https://zdran.com/20181216.html">Dubbo 学习笔记(二) Spring Boot 整合 Dubbo</a></li><li><a href="https://zdran.com/20190212.html">Dubbo 学习笔记(三) Spring Boot 整合 Dubbo(官方版)</a></li></ul><hr><h2 id="0-槽点"><a href="#0-槽点" class="headerlink" title="0. 槽点"></a>0. 槽点</h2><p>Spring Boot 与 Dubbo 整合的依赖有3个版本。</p><p>第一个是 apache推出的依赖：</p><ul><li><a href="https://github.com/apache/incubator-dubbo-spring-boot-project">https://github.com/apache/incubator-dubbo-spring-boot-project</a></li><li>最新的版本是 0.2.0 </li><li>star:2383</li></ul><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>另一个是 alibaba 推出的</p><ul><li>地址： <a href="https://github.com/alibaba/dubbo-spring-boot-starter">https://github.com/alibaba/dubbo-spring-boot-starter</a></li><li>最新版本是：2.0.0 </li><li>star:1348</li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.0.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>还有一个是个人开发者推出的</p><ul><li>地址：<a href="https://github.com/teaey/spring-boot-starter-dubbo">https://github.com/teaey/spring-boot-starter-dubbo</a> </li><li>最新版本：1.0.0 </li><li>star：132</li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;io.dubbo.springboot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>这三个依赖的配置好像都不太一样，有些依赖还得添加额外的依赖。所以你在看博客的时候一定要看清楚依赖，尤其是第一个和第二个。</p><p>这篇文章使用的是个人开发者推出的依赖，如果你不想使用这个版本的依赖，就不用再往下看了。</p><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>还记得我们在第一篇文章中说的，RPC 调用主要有三个东西。服务提供者(生产者)、服务调用者(消费者)、服务注册中心。</p><p>创建一个名称为 duboot 的项目。然后在这个项目里创建三个 spring boot 模块。</p><p>整个项目的目录结构为：</p><pre><code>duboot    |-duboot-api    |-duboot-user-provider    |-duboot-web</code></pre><p>一个非常简单的 RPC 调用的项目框架。其中 duboot-api 定义需要发布的接口。或者叫需要发布的服务。duboot-user-provider 负责实现对应的服务。即服务提供者（生产者），duboot-web 使用服务，即服务的调用者（消费者）。</p><p><strong>注意：user与web模块都是 Spring Boot 项目</strong></p><h2 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2. 添加依赖"></a>2. 添加依赖</h2><p><strong>这里使用的依赖是个人推出的依赖包，而且user-provider模块和web模块的依赖是一样的。</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.zdran.duboot&lt;/groupId&gt;    &lt;artifactId&gt;user-provider&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;user-provider&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.zdran.duboot&lt;/groupId&gt;            &lt;artifactId&gt;api&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--dubbo-springBoot依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.dubbo.springboot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt;            &lt;version&gt;1.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--zookeeper依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;            &lt;version&gt;3.4.8&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>注意：这里依赖了 duboot-api模块，以及zookeeper相关的东西</strong></p><h2 id="3-添加配置"><a href="#3-添加配置" class="headerlink" title="3. 添加配置"></a>3. 添加配置</h2><p>在 application.yml 里添加相关的配置。</p><p><strong>注意： user-provider模块与web模块的配置基本一样，只需要修改一下 server.port、application.name、scan这几个值就可以了</strong></p><pre><code>server:  port: 8086spring:  dubbo:    #应用配置，用于配置当前应用信息，不管该应用是提供者还是消费者。    application:                  name: duboot-user-provider    #注册中心配置，用于配置连接注册中心相关信息。    registry:                      address: zookeeper://127.0.0.1:2181    #协议配置，用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受。    protocol:      name: dubbo      port: 20880    scan: com.zdran.duboot.user.provider  #服务暴露与发现消费所在的package</code></pre><p>注册中心可以使用我们上一篇文章中搭建好的 zookeeper 就可以了 。</p><h2 id="4-实现服务"><a href="#4-实现服务" class="headerlink" title="4. 实现服务"></a>4. 实现服务</h2><p>我们首先在 <strong>duboot-api模块</strong> 里创建一个接口，或者说定义一个服务：</p><pre><code>package com.zdran.duboot.api.service;/** * Create by ranzd on 2018/12/15 * * @author cm.zdran@gmail.com */public interface HelloDubbo &#123;    String sayHello(String name);&#125;</code></pre><p>然后在 <strong>duboot-user-provider模块</strong> 里实现这个接口，也叫实现服务</p><pre><code>package com.zdran.duboot.user.provider.service;import com.alibaba.dubbo.config.annotation.Service;import com.zdran.duboot.api.service.HelloDubbo;/** * Create by ranzd on 2018/12/15 * * @author ranzd@chinaunicom.cn */@Service(version = &quot;1.0&quot;, timeout = 50000)public class HelloDubboImpl implements HelloDubbo &#123;    @Override    public String sayHello(String name) &#123;        return &quot;Hello, &quot; + name;    &#125;&#125;</code></pre><p><strong>这里的 Service 注解是dubbo包里的，不是spring 包里的</strong></p><p>然后就可以在 <strong>web模块</strong> 发起调用了。我们在 <strong>web模块</strong> 实现一个controller，然后让这个controller去调用刚刚实现好的服务。</p><pre><code>package com.zdran.duboot.web.controller;import com.alibaba.dubbo.config.annotation.Reference;import com.zdran.duboot.api.service.HelloDubbo;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;/** * Create by ranzd on 2018/12/16 * * @author cm.zdran@gmail.com */@RestControllerpublic class HelloController &#123;    @Reference(version = &quot;1.0&quot;)    private HelloDubbo helloDubbo;    @GetMapping(&quot;/duboot/hello/&#123;name&#125;&quot;)    public String hello(@PathVariable(&quot;name&quot;) String name) &#123;        return helloDubbo.sayHello(name);    &#125;&#125;</code></pre><p>访问一下 <code>http://localhost:8085/duboot/hello/dubbo</code>试试看吧。</p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> ZooKeeper </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Sublime Text 编辑 Markdown</title>
      <link href="20181203.html"/>
      <url>20181203.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.sublimetext.com/3">Sublime Text 3 下载地址</a></li></ul><h2 id="1-安装包管理器"><a href="#1-安装包管理器" class="headerlink" title="1. 安装包管理器"></a>1. 安装包管理器</h2><p>通过 <code>Ctrl + `(波浪线)</code> 快捷键或者 View &gt; Show Console菜单打开控制台，复制粘贴回车如下代码即可</p><pre><code>import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</code></pre><h2 id="2-安装-Markdown-插件"><a href="#2-安装-Markdown-插件" class="headerlink" title="2. 安装 Markdown 插件"></a>2. 安装 Markdown 插件</h2><p>通过 <code>Ctrl + Shift + P</code> 快捷键打开包管理器，输入”package control” sd选择”Package Control:Install Paclage”,需要等待1-2秒钟，网络请求加载插件列表。可以看一下左下角，会有一个”=”一直在移动。</p><p>安装两个插件:</p><ul><li>MarkdownEditing</li><li>MarkdownPreview</li></ul><p>直接搜索插件点击安装就可以，安装结束后，按<code>Esc</code> 键就可以关闭 Package Control 面板了。一般不需要重启。</p><h2 id="3-MarkdownEditing-快捷键"><a href="#3-MarkdownEditing-快捷键" class="headerlink" title="3. MarkdownEditing 快捷键"></a>3. MarkdownEditing 快捷键</h2><ul><li>插入链接。输入 <code>mdl</code> 然后按下<code>Tab</code>键</li><li>插入图片链接。输入 <code>mdi</code> 然后按下<code>Tab</code>键</li><li>插入代码块。输入 <code>mdc</code> 然后按下<code>Tab</code>键</li><li>插入各级标题。 输入<code>mdh1、mdh2、mdh3</code>,分别对应一级标题、二级标题、三级标题。</li><li>更改标题级别。选中标题（包括’#’）,然后按下<code>Ctrl + Number</code>，Number 代表标题级别。</li></ul><h2 id="4-MarkdownPreview-使用"><a href="#4-MarkdownPreview-使用" class="headerlink" title="4. MarkdownPreview 使用"></a>4. MarkdownPreview 使用</h2><p>通过 <code>Ctrl + Shift + P</code> 快捷键打开包管理器，输入 “mp”,选择” Markdown Preview: Preview in Browser”,然后选择一种 markdown 的格式，就可以在浏览器里打开了。</p><p><strong>PS: 我使用的是Chrome浏览器，别的浏览器没有尝试过</strong></p><p>Chrome小技巧：</p><ul><li>编辑好md文件，保存后可以直接按 F5 刷新浏览器，查看最新的md文件。</li><li>在浏览器页面 按<code>Ctrl + P</code>,更改 <code>目标打印机</code> 为 <code>另存为PDF</code> 可以直接将md转成PDF 文件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> SublimeText </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo 学习笔记(一) Hello,Dubbo</title>
      <link href="20181113.html"/>
      <url>20181113.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Dubbo 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20181102.html">Dubbo 学习笔记(零) 自己实现一个 RPC 框架</a></li><li><a href="https://zdran.com/20181113.html">Dubbo 学习笔记(一) Hello,Dubbo</a></li><li><a href="https://zdran.com/20181216.html">Dubbo 学习笔记(二) Spring Boot 整合 Dubbo</a></li><li><a href="https://zdran.com/20190212.html">Dubbo 学习笔记(三) Spring Boot 整合 Dubbo(官方版)</a></li></ul><hr><h2 id="0-Dubbo-简介"><a href="#0-Dubbo-简介" class="headerlink" title="0. Dubbo 简介"></a>0. Dubbo 简介</h2><p>Dubbo是一个开源的RPC框架。详情见 <a href="http://dubbo.apache.org/zh-cn/">Dubbo官网</a></p><h2 id="1-安装注册中心"><a href="#1-安装注册中心" class="headerlink" title="1. 安装注册中心"></a>1. 安装注册中心</h2><p><a href="https://zookeeper.apache.org/">ZooKeeper</a> 是常用的注册中心之一。</p><p><a href="http://mirror.bit.edu.cn/apache/zookeeper/">下载地址</a></p><p>解压：</p><pre><code>sudo tar -zxvf zookeeper-3.4.10.tar.gz</code></pre><p>配置 ZooKeeper,将 <code>zookeeper-3.4.10/conf</code>下的 <code>zoo_sample.cfg</code> 复制一份，重命名为 <code>zoo.cfg</code></p><pre><code>cd zookeeper-3.4.10/confcp zoo_sample.cfg ./zoo.cfg</code></pre><p>配置采用默认的就可以。</p><p>配置环境变量</p><pre><code># ZooKeeper Envexport ZOOKEEPER_HOME=/xxx/xxx/zookeeper-3.4.8export PATH=$PATH:$ZOOKEEPER_HOME/bin</code></pre><p>生效环境变量：</p><pre><code>source .bashrc</code></pre><p>启动 ZooKeeper </p><pre><code>zkServer.sh startZooKeeper JMX enabled by defaultUsing config: /root/soft/zookeeper-3.4.10/bin/../conf/zoo.cfgStarting zookeeper ... STARTED</code></pre><p>说明启动成功了。</p><h2 id="2-创建生产者（dubbomall-user）"><a href="#2-创建生产者（dubbomall-user）" class="headerlink" title="2. 创建生产者（dubbomall-user）"></a>2. 创建生产者（dubbomall-user）</h2><p>新建一个空白的 maven 项目。添加下面的依赖：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;dubbomall&lt;/artifactId&gt;        &lt;groupId&gt;com.zdran&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;dubbomall-user&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt;        &lt;dubbo.version&gt;2.5.3&lt;/dubbo.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;!-- 排除传递spring依赖 --&gt;                    &lt;artifactId&gt;spring&lt;/artifactId&gt;                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;!-- 导入zookeeper依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;            &lt;version&gt;3.3.3&lt;/version&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;artifactId&gt;log4j&lt;/artifactId&gt;                    &lt;groupId&gt;log4j&lt;/groupId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;            &lt;version&gt;0.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>创建一个 Service：</p><pre><code>public interface UserService &#123;    /**     * 返回 hello 字符串     *     * @param name 姓名     * @return     */    String sayHello(String name);&#125;具体实现类：@Servicepublic class UserServiceImpl implements UserService &#123;    @Override    public String sayHello(String name) &#123;        return &quot;hello,&quot; + name;    &#125;&#125;</code></pre><p>在 <code>resources</code> 下创建一个 <code>dubbo-server.xml</code> dubbo的配置文件,内容如下：</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd       http://code.alibabatech.com/schema/dubbo       http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;    &lt;dubbo:application name=&quot;dubbomall-user&quot;/&gt;    &lt;!-- 这里使用的注册中心是zookeeper --&gt;    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; client=&quot;zkclient&quot;/&gt;    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;/&gt;    &lt;!-- 将该接口暴露到dubbo中 --&gt;    &lt;dubbo:service interface=&quot;com.zdran.dubbomall.user.service.UserService&quot; ref=&quot;userServiceImpl&quot;/&gt;    &lt;!-- 将具体的实现类加入到Spring容器中 --&gt;    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.zdran.dubbomall.user.service.impl.UserServiceImpl&quot;/&gt;&lt;/beans&gt;</code></pre><p>创建一个启动类：</p><pre><code>public class ApplicationMain &#123;    public static void main(String[] args) throws Exception &#123;        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]                &#123;&quot;dubbo-server.xml&quot;&#125;);        context.start();        System.in.read();    &#125;&#125;</code></pre><p><strong>注意：dubbo-server.xml 的路径是从 resources 下开始的</strong></p><p>启动这个 Main 方法。</p><h2 id="3-查看服务注册情况"><a href="#3-查看服务注册情况" class="headerlink" title="3. 查看服务注册情况"></a>3. 查看服务注册情况</h2><p>然后我们去 ZooKeeper 查看一下服务注册情况</p><p>连接 zookeeper </p><pre><code>zkCli.sh -server 127.0.0.1:2181WATCHER::WatchedEvent state:SyncConnected type:None path:null[zk: 127.0.0.1:2181(CONNECTED) 0]</code></pre><p>出现上面的情况说明连接成功了。</p><p>使用 <code>ls /</code>列出当前 zk上的所有 节点</p><pre><code>[zk: 127.0.0.1:2181(CONNECTED) 0] ls /[dubbo, zookeeper]</code></pre><p>我们看到有一个 dubbo 的节点。查看一下这个节点下面的服务</p><pre><code>[zk: 127.0.0.1:2181(CONNECTED) 1] ls /dubbo[com.zdran.dubbomall.user.service.UserService]</code></pre><p>这次我们看到了我们自己定义的 Service 的包路径，然后我们再看一下，这个节点下面的东西</p><pre><code>[zk: 127.0.0.1:2181(CONNECTED) 14] ls /dubbo/com.zdran.dubbomall.user.service.UserService[consumers, configurators, routers, providers]</code></pre><p>重点看一下 consumers(消费者)、providers(生产者) ,这两个下面的节点分别对应该服务的消费者和生产者。</p><p>我们现在只有生产者，所以先看一下生产者下面的节点</p><pre><code>[zk: 127.0.0.1:2181(CONNECTED) 15] ls /dubbo/com.zdran.dubbomall.user.service.UserService/providers[dubbo%3A%2F%2F192.168.56.1%3A20881%2Fcom.zdran.dubbomall.user.service.UserService%3Fanyhost%3Dtrue%26application%3Ddubbomall-user%26dubbo%3D2.5.3%26interface%3Dcom.zdran.dubbomall.user.service.UserService%26methods%3DsayHello%26pid%3D5740%26side%3Dprovider%26timestamp%3D1542032564897]</code></pre><p>现在不不需要关心这堆看似乱码的字符串，主要注意这里面的两个信息，一个是IP，如果不出意外的话，应该是你本地的IP地址，准确的说是，你启动Main方法的那台机器的IP，另一个是我们暴露的接口的包路径以及方法名。</p><p>如果你看过第一篇文章的话，我们当时实现的最简单的一个RPC框架，其中的注册中心是不是就是通过这两个信息来调用的远程服务。</p><p>消费者通过服务名，从注册中心获取对应的IP地址，然后来与远程服务通信。</p><p>下面我们实现一个消费者。</p><h2 id="4-创建消费者（dubbomall-web）"><a href="#4-创建消费者（dubbomall-web）" class="headerlink" title="4. 创建消费者（dubbomall-web）"></a>4. 创建消费者（dubbomall-web）</h2><p>重新创建一个项目。</p><p>添加生产者依赖。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;dubbomall&lt;/artifactId&gt;        &lt;groupId&gt;com.zdran&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;dubbomall-web&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.zdran&lt;/groupId&gt;            &lt;artifactId&gt;dubbomall-user&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>导入 dubbo 服务，在 resources 目录下创建<code>dubbo-server.xml</code>,内容如下：</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd       http://code.alibabatech.com/schema/dubbo       http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;    &lt;dubbo:application name=&quot;dubbo-web&quot;/&gt;    &lt;!-- 这里使用的注册中心是zookeeper --&gt;    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; client=&quot;zkclient&quot;/&gt;    &lt;!-- 从注册中心中查找服务 --&gt;    &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.zdran.dubbomall.user.service.UserService&quot;/&gt;&lt;/beans&gt;</code></pre><p>实现 RPC 调用,创建一个启动类，实现 main 方法，调用远程的 UserService 服务</p><pre><code>public class ApplicationMain &#123;    public static void main(String[] args) &#123;        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(                new String[]&#123;&quot;dubbo-server.xml&quot;&#125;);        context.start();        UserService demoService = (UserService) context.getBean(&quot;userService&quot;);        String hello = demoService.sayHello(&quot;dubbo&quot;);        System.out.println(hello);    &#125;&#125;</code></pre><p>运行一下这个 main 方法，由于机器性能、网络问题等原因，调用结果可能要等待10s左右，才能得到结果。</p><h2 id="5-查看注册中心的消费者"><a href="#5-查看注册中心的消费者" class="headerlink" title="5. 查看注册中心的消费者"></a>5. 查看注册中心的消费者</h2><p>我们去注册中心看一下消费者的情况。</p><p><strong>注意：你要先运行消费者的main方法，然后运行期间不断的查看注册中心的消费者节点，才能看到。因为消费者一旦执行结束后，该节点就会自动被注册中心删除掉了</strong></p><pre><code>[zk: 127.0.0.1:2181(CONNECTED) 22] ls /dubbo/com.zdran.dubbomall.user.service.UserService/consumers[][zk: 127.0.0.1:2181(CONNECTED) 23] ls /dubbo/com.zdran.dubbomall.user.service.UserService/consumers[][zk: 127.0.0.1:2181(CONNECTED) 24] ls /dubbo/com.zdran.dubbomall.user.service.UserService/consumers[][zk: 127.0.0.1:2181(CONNECTED) 25] ls /dubbo/com.zdran.dubbomall.user.service.UserService/consumers[][zk: 127.0.0.1:2181(CONNECTED) 26] ls /dubbo/com.zdran.dubbomall.user.service.UserService/consumers[consumer%3A%2F%2F192.168.56.1%2Fcom.zdran.dubbomall.user.service.UserService%3Fapplication%3Ddubbo-web%26category%3Dconsumers%26check%3Dfalse%26dubbo%3D2.5.3%26interface%3Dcom.zdran.dubbomall.user.service.UserService%26methods%3DsayHello%26pid%3D4092%26side%3Dconsumer%26timestamp%3D1542034195230]</code></pre><p>还是看其中的两个重要信息，第一个是IP，这个IP是消费者的IP，准确的说是，消费者的那个 main方法执行的机器IP。因为我是在同一个机器上启动的消费者和生产者，所以这个IP是一样的。<br>第二个就是接口的全路径以及方法名。有这两个信息，消费者就能从注册中心获取对应服务的IP，发起调用了。</p><p><strong>PS：消费者不应该直接依赖生产者。正确的做法是抽出一个API模块，由生产者来实现API的接口，然后消费者依赖API。</strong></p><p>就像我们在写代码时不会直接使用 UserServiceImpl ，而是使用 UserService，一样的道理。</p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 上传文件路径错误解决</title>
      <link href="20181112.html"/>
      <url>20181112.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>正常运行一个多月的项目今天上传文件的时候突然出了个下面的异常：</p><pre><code>org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request; nested exception is java.io.IOException: The temporary upload location [/tmp/xxxx/work/Tomcat/localhost/ROOT] is not valid</code></pre><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>检查发现服务器上的 <code>/tmp</code>文件夹确实是空的，网上查了一下原因：说是 tmp目录会被系统自动清理。所以才导致找不到路径的问题。</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>解决方法有三种：</p><ol><li>重启应用</li></ol><p>临时性的的解决方法是重启下应用就可以了，不过问题是，后期还会出现这个问题，指标不治之本。</p><ol start="2"><li>修改启动器：</li></ol><p>在启动类里注入一个Bean：</p><pre><code>@BeanMultipartConfig() &#123;    MultipartConfigFactory factory =new MultipartConfigFactory();     factory.setLocation(&quot;/xxx/xxx&quot;);     return factory.createMultipartConfig();&#125;</code></pre><ol start="3"><li>修改配置文件：</li></ol><p>也可以修改配置文件。添加下面的配置：</p><pre><code>server:  tomcat:    basedir: /xxx/xxx</code></pre>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo 学习笔记(零) 自己实现一个 RPC 框架</title>
      <link href="20181102.html"/>
      <url>20181102.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Dubbo 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20181102.html">Dubbo 学习笔记(零) 自己实现一个 RPC 框架</a></li><li><a href="https://zdran.com/20181113.html">Dubbo 学习笔记(一) Hello,Dubbo</a></li><li><a href="https://zdran.com/20181216.html">Dubbo 学习笔记(二) Spring Boot 整合 Dubbo</a></li><li><a href="https://zdran.com/20190212.html">Dubbo 学习笔记(三) Spring Boot 整合 Dubbo(官方版)</a></li></ul><hr><h2 id="0-什么是-RPC-框架"><a href="#0-什么是-RPC-框架" class="headerlink" title="0. 什么是 RPC 框架"></a>0. 什么是 RPC 框架</h2><p>RPC(Remote Procedure Call) 是一种进程间的通信方式。允许像调用本地服务一样调用远程服务。</p><p>简单点说，它是一种通信方式，它的功能就是让你像调用本地服务（函数、方法）一样，调用远程服务（函数，方法）。</p><p>比如说，我在服务端有一个接口 （MyService.sayHello()）。传统的调用方式是，我们暴露一个 Controller 并绑定到对应的 url地址上，然后通过 http 请求，将参数发送给远程服务器，服务器执行结束后，将结果响应给客户端。</p><p>而 RPC 调用方式是，我在客户端导入 MyService 的接口，直接用 MyService.sayHello() 去调用。注意：客户端并没有直接的创建该接口的具体实现对象。而是通过 RPC 的通信方式去来与服务端交互。</p><h2 id="1-RPC-框架的基本原理"><a href="#1-RPC-框架的基本原理" class="headerlink" title="1. RPC 框架的基本原理"></a>1. RPC 框架的基本原理</h2><p>RPC 框架的基本原理是通过 Socket 和对象序列化来实现的。</p><p>首先，客户端和服务端通过 Socket 来建立通信，客户端将需要调用的接口 序列化后发送给服务端。</p><p>服务端收到数据后将接口反序列化，通过反射的方式执行该接口。然后将执行结果序列化后发送给客户端。</p><p>客户端收到数据后，将结果反序列化，得到接口的执行结果。</p><p>下面实现了一个最简单、最基础的 RPC 框架</p><h2 id="2-定义服务"><a href="#2-定义服务" class="headerlink" title="2. 定义服务"></a>2. 定义服务</h2><p>我们先定义一个服务端的 Service，</p><pre><code>public interface MyService &#123;    String sayHello(String name);&#125;实现类：public class MyServiceImpl implements MyService &#123;    @Override    public String sayHello(String name) &#123;        return &quot;hello,&quot; + name;    &#125;&#125;</code></pre><p>这个接口就是我们服务端提供的服务。</p><h2 id="3-RPC-框架的服务端实现"><a href="#3-RPC-框架的服务端实现" class="headerlink" title="3. RPC 框架的服务端实现"></a>3. RPC 框架的服务端实现</h2><p>先在服务端实现 Socket 持续监听客户端发来的数据，收到数据后让 ProducerAgent 去处理。</p><pre><code>public class RpcProducer &#123;    private static Executor executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());    public static void produce(String host, int port) throws Exception &#123;        ServerSocket serverSocket = new ServerSocket();        serverSocket.bind(new InetSocketAddress(host, port));        try &#123;            while (true) &#123;                executor.execute(new ProducerAgent(serverSocket.accept()));            &#125;        &#125; finally &#123;            serverSocket.close();        &#125;    &#125;&#125;</code></pre><p>ProducerAgent 的实现：</p><pre><code>public class ProducerAgent implements Runnable &#123;    Socket client = null;    public ProducerAgent(Socket accept) &#123;        client = accept;    &#125;    @Override    public void run() &#123;        ObjectInputStream inputStream = null;        ObjectOutputStream outputStream = null;        try &#123;            inputStream = new ObjectInputStream(client.getInputStream());            String interfaceName = inputStream.readUTF();            Class&lt;?&gt; service = Class.forName(interfaceName);            String methodName = inputStream.readUTF();            Class&lt;?&gt;[] paramTypes = (Class&lt;?&gt;[]) inputStream.readObject();            Object[] args = (Object[]) inputStream.readObject();            Method method = service.getMethod(methodName, paramTypes);            Object result = method.invoke(service.newInstance(), args);            outputStream = new ObjectOutputStream(client.getOutputStream());            outputStream.writeObject(result);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;finally &#123;            //省略部分代码        &#125;    &#125;&#125;</code></pre><p>我们依次读取接口的名称、方法名称、参数类型、参数。然后通过反射的机制执行方法，最后将结果序列化后写入到客户端。</p><h2 id="4-RPC-框架的客户端实现"><a href="#4-RPC-框架的客户端实现" class="headerlink" title="4. RPC 框架的客户端实现"></a>4. RPC 框架的客户端实现</h2><pre><code>public class LocalAgent&lt;T&gt; &#123;    public T importer(final Class&lt;?&gt; serviceClass, final InetSocketAddress addr) &#123;        return (T) Proxy.newProxyInstance(serviceClass.getClassLoader(),                new Class&lt;?&gt;[]&#123;serviceClass.getInterfaces()[0]&#125;,                new InvocationHandler() &#123;                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        ObjectOutputStream outputStream = null;                        ObjectInputStream inputStream = null;                        Socket socket = null;                        try &#123;                            socket = new Socket();                            socket.connect(addr);                            outputStream = new ObjectOutputStream(socket.getOutputStream());                            outputStream.writeUTF(serviceClass.getName());                            outputStream.writeUTF(method.getName());                            outputStream.writeObject(method.getParameterTypes());                            outputStream.writeObject(args);                            inputStream = new ObjectInputStream(socket.getInputStream());                            return inputStream.readObject();                        &#125; finally &#123;                            //省略部分代码                        &#125;                    &#125;                &#125;);    &#125;&#125;</code></pre><p>客户端做的事情是与服务端建立 Socket 通信，然后依次写入 接口名、方法名、参数类型、参数。注意：<strong>写入顺序一定要与服务端的读取顺序一致</strong>。</p><p>然后接收服务端的执行结果，反序列化为实际类型。</p><h2 id="5-使用-RPC-框架"><a href="#5-使用-RPC-框架" class="headerlink" title="5. 使用 RPC 框架"></a>5. 使用 RPC 框架</h2><p>RPC 框架的客户端和服务端的基本功能已经实现，下面我们使用刚刚实现的 RPC 框架 来调用一下 <code>MyService.sayHello(String name)</code> 这个接口</p><p>首先我们使用一个线程来启动服务端：</p><pre><code>    private static void startProduct() &#123;        //通过一个线程启动服务端        String host = &quot;localhost&quot;;        int port = 8878;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    System.out.println(&quot;服务端启动........&quot;);                    RpcProducer.produce(host, port);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;).start();    &#125;</code></pre><p>下面我们使用 刚刚实现的 RPC 框架来调用服务端的接口</p><pre><code>    private static void client() &#123;        LocalAgent&lt;MyService&gt; serviceLocalAgent = new LocalAgent&lt;&gt;();        MyService myService = serviceLocalAgent.importer(MyServiceImpl.class,                new InetSocketAddress(&quot;localhost&quot;,8878));        System.out.println(myService.sayHello(&quot;RPC&quot;));    &#125;</code></pre><p>在客户端，我们传了一个服务端实现类的类型、一个服务端的地址，然后就可以调用服务端的接口了。注意：<strong>我们并没有在客户端创建 接口的具体实现对象</strong>，而仅仅是把需要调用的 Class 通过 Socket 发送给了服务端。</p><h2 id="6-添加注册中心"><a href="#6-添加注册中心" class="headerlink" title="6. 添加注册中心"></a>6. 添加注册中心</h2><p>考虑一下上面的代码，我们服务端的地址是写死在客户端和服务端的代码里的，如果服务比较多，而且每个服务的地址都不一样，直接写死是很难维护的，所以我们需要一个注册中心来管理每个服务的地址。</p><p>下面是一个最简单的注册中心：</p><pre><code>public class RegistrationCenter &#123;    private Map&lt;String, InetSocketAddress&gt; serviceMap = new HashMap&lt;&gt;();    public void register(String serviceName, String host, int port) &#123;        serviceMap.put(serviceName, new InetSocketAddress(host, port));    &#125;    public InetSocketAddress getService(String serviceName) &#123;        return serviceMap.get(serviceName);    &#125;&#125;</code></pre><p>注册中心维护服务名称与服务地址的映射。</p><p>我们修改一下服务端的启动代码，当服务启动之后，向注册中心注册服务。</p><pre><code>    private static void startProduct(RegistrationCenter center) &#123;        //通过一个线程启动服务端        String host = &quot;localhost&quot;;        int port = 8878;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    System.out.println(&quot;服务端启动........&quot;);                    RpcProducer.produce(host, port);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;).start();        //向注册中心注册服务        center.register(&quot;MyService.sayHello&quot;, host, port);    &#125;</code></pre><p>修改一下客户端的调用方式,调用服务时，根据服务名从注册中心获取服务地址。：</p><pre><code>    private static void client(RegistrationCenter center) &#123;        LocalAgent&lt;MyService&gt; serviceLocalAgent = new LocalAgent&lt;&gt;();        MyService myService = serviceLocalAgent.importer(MyServiceImpl.class,                center.getService(&quot;MyService.sayHello&quot;));        System.out.println(myService.sayHello(&quot;RPC&quot;));    &#125;</code></pre><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>这就是 RPC 框架的基本原理，通过 Socket 建立通信，通过序列化与反序列实现数据传输，使用反射执行具体的服务。</p><p>假设你对 RPC 还是没有什么概念，也没关系，但是你需要记住下面三个概念：</p><ol><li><p>生产者：或者说是服务端，更具体点就是上面的<code>ProducerAgent</code>类，</p><p> 负责解析消费者发送的参数，通过反射调用对应的服务，将结果序列化后发送给消费者。</p></li><li><p>消费者：就是我们的客户端，对应<code>LocalAgent</code>类</p><p> 负责将需要调用的服务信息发送给生产者，将结果反序列化后获得实际的执行结果。</p></li><li><p>注册中心：提供服务的注册和发现的功能。对应<code>RegistrationCenter</code>类</p><p> 责管理服务与地址的映射。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(十二) 整合 定时任务</title>
      <link href="20181016.html"/>
      <url>20181016.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="1-启动配置"><a href="#1-启动配置" class="headerlink" title="1. 启动配置"></a>1. 启动配置</h2><p>在启动类上添加<code>EnableScheduling</code>注解，启用定时任务</p><pre><code>@SpringBootApplication@EnableSwagger2@ComponentScan(&#123;&quot;com.zdran.springboot&quot;&#125;)@EnableSchedulingpublic class SpringbootApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootApplication.class, args);    &#125;    ... ...&#125;</code></pre><h2 id="2-创建定时任务"><a href="#2-创建定时任务" class="headerlink" title="2. 创建定时任务"></a>2. 创建定时任务</h2><p>创建一个简单的定时任务</p><pre><code>@Componentpublic class HelloTask &#123;    private static int count = 1;    private Logger logger = LoggerFactory.getLogger(HelloTask.class);    @Scheduled(fixedRate = 5000)    public void printHello() &#123;        logger.info(&quot;Hello 定时任务开始。&quot;);        logger.info(&quot;Hello Task! count = &#123;&#125;&quot;, count++);        logger.info(&quot;Hello 定时任务结束。&quot;);    &#125;&#125;</code></pre><p>启动项目会看到每隔5000毫秒会执行一下这个方法。</p><h2 id="3-Scheduled注解"><a href="#3-Scheduled注解" class="headerlink" title="3. Scheduled注解"></a>3. Scheduled注解</h2><ul><li>@Scheduled(fixedRate = 5000) ：上一次开始执行时间点之后5秒再执行</li><li>@Scheduled(fixedDelay = 5000) ：上一次执行完毕时间点之后5秒再执行</li><li>@Scheduled(initialDelay=1000, fixedRate=5000) ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次</li></ul><h2 id="4-cron-表达式"><a href="#4-cron-表达式" class="headerlink" title="4. cron 表达式"></a>4. cron 表达式</h2><p>还可以通过 cron表达式指定执行时间。类似于 @Scheduled(cron=”*/5 * * * * *”) </p><p>Cron表达式由7个部分组成，各部分用空格隔开，每个部分的含义如下：</p><pre><code>Seconds Minutes Hours Day-of-Month Month Day-of-Week Year</code></pre><ul><li>Seconds<br>秒：数字0－59</li><li>Minutes<br>分：数字0－59</li><li>Hours<br>时：数字0-23</li><li>Day-of-Month<br>月中的几号：可以用数字1-31，但要注意一些特别的月份</li><li>Month<br>月：可以用0-11 或用字符串 “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示</li><li>Day-of-Week<br>周：数字1-7（1 ＝ 星期日），或用字符串“SUN, MON, TUE, WED, THU, FRI and SAT”</li></ul><p>cron中有一些特殊符号：</p><ul><li>“*” ：代表整个时间段.</li><li>“/“ ：表示每多长时间执行一次</li><li>“0/15” :表示每隔15分钟执行一次,“0”表示为从“0”分开始；</li><li>“3/20” :表示每隔20分钟执行一次，“3”表示从第3分钟开始执行</li><li>“?”：表示每月的某一天，或第几周的某一天</li></ul><h2 id="5-趟过的坑"><a href="#5-趟过的坑" class="headerlink" title="5. 趟过的坑"></a>5. 趟过的坑</h2><p>cron表达式中有一组组比较特殊的字段 <code>Day-of-Month 和 Day-of-Week</code>，</p><p>如果你要求每月的几号执行，那么 <code>Day-of-Week</code> 就要用 “?”,</p><p>如果你要求每周的周几执行，那么 <code>Day-of-Month</code> 就要用 “?”,</p><p>具体是什么原因我也不知道。举个例子：有一个定时，希望每个月的 1号凌晨1点执行，那么cron表达式为<code>0 0 1 1 * * ?</code></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Scheduled </tag>
            
            <tag> cron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(十一) 整合 Redis</title>
      <link href="20180911.html"/>
      <url>20180911.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="2-添加-Redis-配置"><a href="#2-添加-Redis-配置" class="headerlink" title="2. 添加 Redis 配置"></a>2. 添加 Redis 配置</h2><pre><code>spring:  redis:    cluster:      nodes: 127.0.0.1:9001,127.0.0.1:9002,127.0.0.1:9003    password: ******    timeout: 10000ms    database: 0    jedis:      pool:        max-idle: 8        min-idle: 1        max-active: 8        max-wait: 6000ms</code></pre><p>这里我们使用了 jedis 连接池。</p><h2 id="3-创建操作-Redis-的-Service"><a href="#3-创建操作-Redis-的-Service" class="headerlink" title="3. 创建操作 Redis 的 Service"></a>3. 创建操作 Redis 的 Service</h2><pre><code>@Servicepublic class RedisServiceImpl implements RedisService &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    private Logger logger = LoggerFactory.getLogger(RedisServiceImpl.class);    @Override    public void setStr(String key, String value) &#123;        logger.info(&quot;插入 Redis 数据。入参：key：&#123;&#125;，value：&#123;&#125;&quot;, key, value);        ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue();        operations.set(key, value);    &#125;    @Override    public String getStr(String key) &#123;        logger.info(&quot;获取 Redis 数据。入参：key：&#123;&#125;&quot;, key);        ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue();        String value = operations.get(key);        logger.info(&quot;获取 Redis 数据。出参：value：&#123;&#125;&quot;, value);        return value;    &#125;    @Override    public void delStr(String key) &#123;        logger.info(&quot;删除 Redis 数据。入参：key：&#123;&#125;&quot;, key);        ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue();        operations.getOperations().delete(key);    &#125;</code></pre><p>操作 Redis 的主要类是 <code>stringRedisTemplate</code>,这个类可以获取不同类型的 Redis操作对象。</p><pre><code>Stirng 类型：stringRedisTemplate.opsForValue()List 类型：stringRedisTemplate.opsForList()Set 类型：stringRedisTemplate.opsForSet()Hash 类型：stringRedisTemplate.opsForHash()</code></pre><p>可以看到，opsForXXX() 不能删除 Redis 中的key，这个时候可以使用下面的方法，获取<code>RedisOperations</code> 对象。通过该对象进行一些 Redis 的操作。</p><pre><code>opsForHash().getOperations().delete(key);</code></pre><h2 id="4-单元测试"><a href="#4-单元测试" class="headerlink" title="4. 单元测试"></a>4. 单元测试</h2><p>我们针对这个 Service 写个单元测试，测试一下</p><pre><code>@RunWith(SpringRunner.class)@SpringBootTest()public class RedisServiceImplTest &#123;    @Autowired    private RedisService redisService;    @Test    public void setStr() throws Exception &#123;        redisService.setStr(&quot;TEST&quot;,&quot;1234&quot;);    &#125;    @Test    public void getStr() throws Exception &#123;        System.out.println(redisService.getStr(&quot;TEST&quot;));    &#125;    @Test    public void delStr() throws Exception &#123;        redisService.delStr(&quot;TEST&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(十) Redis集群搭建</title>
      <link href="20180904.html"/>
      <url>20180904.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="0-环境说明"><a href="#0-环境说明" class="headerlink" title="0. 环境说明"></a>0. 环境说明</h2><ul><li>服务器 centos 7 64bit</li><li>redis 4.0.11</li></ul><h2 id="1-Redis-源码安装"><a href="#1-Redis-源码安装" class="headerlink" title="1.Redis 源码安装"></a>1.Redis 源码安装</h2><p>创建一个redis源码目录,并转到该目录</p><pre><code>mkidr rediscd redis</code></pre><p>下载源码并编译。</p><pre><code>wget http://download.redis.io/releases/redis-4.0.11.tar.gztar xzf redis-4.0.11.tar.gzcd redis-4.0.11make</code></pre><p>PS:如果出现下面的结果：</p><pre><code>make[2]: Entering directory `/root/redis/redis-4.0.11/deps/hiredis&#39;gcc -std=c99 -pedantic -c -O3 -fPIC  -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb  net.cmake[2]: gcc: Command not foundmake[2]: *** [net.o] Error 127make[2]: Leaving directory `/root/redis/redis-4.0.11/deps/hiredis&#39;make[1]: *** [hiredis] Error 2make[1]: Leaving directory `/root/redis/redis-4.0.11/deps&#39;make: [persist-settings] Error 2 (ignored)</code></pre><p>说明没有安装 gcc 编译器。需要安装一下。</p><pre><code>yum install gcc</code></pre><p><strong>安装gcc后需要重新解压一份新的Redis。再执行 make</strong></p><p>编译成功的话会显示:</p><pre><code>Hint: It&#39;s a good idea to run &#39;make test&#39; ;)make[1]: Leaving directory `/root/redis/redis-4.0.11/src&#39;</code></pre><p>至此，我们已经获取到了Redis的安装包。src目录下就是一个完整可用的Redis了。</p><h2 id="2-Redis单机部署"><a href="#2-Redis单机部署" class="headerlink" title="2. Redis单机部署"></a>2. Redis单机部署</h2><p>现在开始搭建一个单机的redis集群。主备模式（三主三从）。</p><p>以端口号为名称创建6个文件夹:</p><pre><code>mkdir redis-clustercd redis-clustermkdir -p 9001/data 9002/data 9003/data 9004/data 9005/data 9006/data</code></pre><p>把我们之前编译好的redis拷贝一份到 9001 中，并修改 <code>redis.config</code> 文件中的配置信息</p><pre><code>cd 9001vim redis.config</code></pre><p>主要修改下面几个配置：</p><pre><code>port 9001（每个节点的端口号）daemonize yes（开启守护线程）bind 192.168.119.131（绑定当前机器 IP,需要注释掉，否则外网无法访问）dir ./data（数据文件存放位置）pidfile /var/run/redis_9001.pid（pid 9001和port要对应）cluster-enabled yes（默认是注释掉的，需要开启启动集群模式）cluster-config-file nodes9001.conf（默认是注释掉的，9001和port要对应）cluster-node-timeout 15000（默认是注释掉的，超时时间）appendonly yes （redis数据持久化）</code></pre><p>然后把 9001 下的 redis 依次拷贝到其他5个端口的文件夹下。</p><pre><code>cp -r ./* ./../9001/cp -r ./* ./../9002/cp -r ./* ./../9003/cp -r ./* ./../9004/cp -r ./* ./../9005/cp -r ./* ./../9006/</code></pre><p>依次修改每个端口下的<code>redis.config</code>,把端口改成与文件夹一致。到这一步，我们相当于在本地主机上部署了6个Redis，依次启动每个端口的redis</p><pre><code>cd 9001./src/redis-server redis.conf ... ...(启动其他端口的redis)</code></pre><h2 id="3-安装Redis集群所需的工具"><a href="#3-安装Redis集群所需的工具" class="headerlink" title="3. 安装Redis集群所需的工具"></a>3. 安装Redis集群所需的工具</h2><p>由于 Redis 集群需要使用 ruby 命令，所以我们需要安装 ruby 和相关接口。</p><pre><code>yum install rubyyum install rubygemsgem install redis </code></pre><p>在执行 <code>gem install redis</code>的时候出现了下面的错误</p><pre><code>ERROR:  Error installing redis:    redis requires Ruby version &gt;= 2.2.2.</code></pre><p>意思是我们的 Ruby版本太低了，要升级一下Ruby。</p><p>执行一下：</p><pre><code> curl -L get.rvm.io | bash -s stable</code></pre><p>会获取到一个密钥：</p><pre><code>    gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</code></pre><p>让这个密钥生效一下</p><pre><code> gpg --keyserver hkp://keys.gnupg.net --recv-keys xxx（上一步得到的key） curl -sSL https://get.rvm.io | bash -s stable</code></pre><p>source环境，让rvm可用：</p><pre><code>source /etc/profile.d/rvm.shsource /usr/local/rvm/scripts/rvm</code></pre><p>安装 Ruby 2.3.0</p><pre><code>rvm install 2.3.0</code></pre><p>安装Redis接口</p><pre><code> gem install redis </code></pre><p>构建Redis集群</p><pre><code>cd 9001[root@localhost 9006]# ./src/redis-trib.rb create --replicas 1 127.0.0.1:9001 127.0.0.1:9002 127.0.0.1:9003 127.0.0.1:9004 127.0.0.1:9005 127.0.0.1:9006&gt;&gt;&gt; Creating cluster&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:127.0.0.1:9001127.0.0.1:9002127.0.0.1:9003Adding replica 127.0.0.1:9005 to 127.0.0.1:9001Adding replica 127.0.0.1:9006 to 127.0.0.1:9002Adding replica 127.0.0.1:9004 to 127.0.0.1:9003... ...(省略部分显示结果)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.</code></pre><p>这个时候我们的集群已经搭建好了。找一台redis连接上看一下</p><pre><code>./src/redis-cli -c -p 9001127.0.0.1:9001&gt; cluster info127.0.0.1:9001&gt; cluster nodes</code></pre><h2 id="4-外网访问"><a href="#4-外网访问" class="headerlink" title="4. 外网访问"></a>4. 外网访问</h2><p>现在集群是搭建好了，在服务器上测试一下是可以的，如果你要在别的机器上连接发现会发现一直连接失败。这是因为我们的redis集群没有设置密码，而且是保护模式。现在我们对这个集群设置一个密码。</p><p>集群的密码需要单独对每个机器设置，这里以 9001 为例</p><pre><code>cd 9001src/redis-cli -c -p 9001 shutdownvim redis.conf</code></pre><p>修改 requirepass 选项</p><pre><code>requirepass ****** </code></pre><p>重启 redis</p><pre><code>src/redis-server redis.conf</code></pre><p>依次修改完其他的端口，外网就能通过密码访问了。</p><p>PS:如果还是不能访问，请检查一下端口是否开放。</p><pre><code>linux 下的开放端口命令。下面的命令会开放 8080端口/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</code></pre><h2 id="5-redis-trib-无法连接"><a href="#5-redis-trib-无法连接" class="headerlink" title="5. redis-trib 无法连接"></a>5. redis-trib 无法连接</h2><p>这个时候如果你在服务器上会发现 <code>redis-trib.sh</code>这个脚本好像没办法连接连接上redis了</p><pre><code>cd 9001./src/redis-trib.rb check 127.0.0.1:9001[ERR] Sorry, can&#39;t connect to node 127.0.0.1:9001</code></pre><p>这个是因为我们的Redis集群配置信息没有更新密码配置，需要手动修改。</p><pre><code>cd /usr/local/rvm/gems/ruby-2.3.0/gems/redis-4.0.2/lib/redisvim client.rb</code></pre><p>PS: 如果找不到 <code>client.rb</code> 可以用<code>find / -name &#39;client.rb&#39;命令</code>查找一下<br>修改 passord 配置:</p><pre><code>    DEFAULTS = &#123;      :url =&gt; lambda &#123; ENV[&quot;REDIS_URL&quot;] &#125;,      :scheme =&gt; &quot;redis&quot;,      :host =&gt; &quot;127.0.0.1&quot;,      :port =&gt; 6379,      :path =&gt; nil,      :timeout =&gt; 5.0,      :password =&gt; &quot;******&quot;,      :db =&gt; 0,      :driver =&gt; nil,      :id =&gt; nil,      :tcp_keepalive =&gt; 0,      :reconnect_attempts =&gt; 1,      :inherit_socket =&gt; false    &#125;</code></pre><p>再试一下：</p><pre><code>./redis-trib.rb check 127.0.0.1:9001</code></pre><p>应该能看到 redis集群的一些信息了</p><h2 id="6-IDEA-的-Iedis-插件无法连接"><a href="#6-IDEA-的-Iedis-插件无法连接" class="headerlink" title="6. IDEA 的 Iedis 插件无法连接"></a>6. IDEA 的 Iedis 插件无法连接</h2><p>最后，遇到了一个问题，我用IDEA 的 Iedis 连接别的redis集群能正常连接，但是连接刚刚搭建的集群就是连接不上。不知道为什么，一直没有解决。</p><p>不过 用 Redis Desktop Manager 是可以连接上的。</p><p>PS:为了安装一个redis 我已经重装了10多次系统了。。。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(九) 整合 多环境配置</title>
      <link href="20180830.html"/>
      <url>20180830.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>由于在开发过程中会有多个不同的环境，比如会分成开发环境、测试环境、生产环境等。而每个环境的配置也各不相同，<br>所以需要针对不同的环境进行打包部署。</p><h2 id="1-创建多环境配置文件"><a href="#1-创建多环境配置文件" class="headerlink" title="1. 创建多环境配置文件"></a>1. 创建多环境配置文件</h2><p>spring boot 的多环境配置很简单，创建多个配置文件就可以了。</p><p>首先创建一个主的配置文件名称为<code>application.yml</code>，注意：<strong>名称不能更改</strong> 。用来指定默认启动某个环境下的配置文件。</p><pre><code># 主配置文件spring:  profiles:      # 默认启动开发环境配置    active: dev</code></pre><p>创建开发环境的配置文件，名称为<code>application-dev.yml</code></p><pre><code>#开发环境配置server:  port: 9090  servlet:    context-path: /learning# 省略其他配置 ... ...</code></pre><p>注意：<strong>名称格式为 application-xxx.yml</strong></p><p>同样，创建生产环境配置 名称为 <code>application-pro.yml</code> </p><pre><code>#生产环境配置server:  port: 7070  servlet:    context-path: /learning# 省略其他配置 ... ...</code></pre><p>注意：<strong>名称格式为 application-xxx.yml</strong></p><h2 id="2-分环境启动"><a href="#2-分环境启动" class="headerlink" title="2. 分环境启动"></a>2. 分环境启动</h2><p>本地调试的时候，可以修改主配置文件中<code>active</code>的参数，来启用不同环境的配置。</p><p>打成jar包后，可以根据传参的不同来启用不同环境的配置。启动命令：</p><pre><code>生产环境：java -jar xxx.jar --spring.profiles.active=pro测试环境：java -jar xxx.jar --spring.profiles.active=pro</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(八) 整合 Filter</title>
      <link href="20180809.html"/>
      <url>20180809.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h1 id="Spring-Boot-学习笔记-八-整合-Filter"><a href="#Spring-Boot-学习笔记-八-整合-Filter" class="headerlink" title="Spring Boot 学习笔记(八) 整合 Filter"></a>Spring Boot 学习笔记(八) 整合 Filter</h1><h2 id="1-创建自定义的-Filter"><a href="#1-创建自定义的-Filter" class="headerlink" title="1. 创建自定义的 Filter"></a>1. 创建自定义的 Filter</h2><p>创建一个 <code>DemoFilter</code></p><pre><code>package com.zdran.springboot.filter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.*;import java.io.IOException;/** * Create by ranzd on 2018/8/9 * * @author cm.zdran@gmail.com */public class DemoFilter implements Filter&#123;    private Logger logger = LoggerFactory.getLogger(DemoFilter.class);    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        logger.info(&quot;初始化 DemoFilter &quot;);    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)            throws IOException, ServletException &#123;        logger.info(&quot;拦截到参数：&#123;&#125;&quot;, servletRequest.getParameterMap());        if (true) &#123;            filterChain.doFilter(servletRequest,servletResponse);        &#125;        logger.info(&quot;拦截到参数。请求被拦截&quot;);    &#125;    @Override    public void destroy() &#123;        logger.info(&quot;销毁 DemoFilter &quot;);    &#125;&#125;</code></pre><p>核心的方法是 <code>doFilter</code>,可以在这个方法内对参数进行校验，通过<code>servletRequest</code>可以获取到请求中的参数。根据参数进行拦截。</p><pre><code>filterChain.doFilter(servletRequest,servletResponse);</code></pre><p>如果调用了这行代码说明不拦截这次请求，如果没有调用这行代码，这次请求请求将被拦截。</p><h2 id="2-初始化-Filter"><a href="#2-初始化-Filter" class="headerlink" title="2. 初始化 Filter"></a>2. 初始化 Filter</h2><p>将这个Filter注入到容器中，创建 FilterConfig 类</p><pre><code>@Configurationpublic class FilterConfig &#123;    private Logger logger = LoggerFactory.getLogger(FilterConfig.class);    @Bean    public FilterRegistrationBean xssFilterRegistrationBean() &#123;        logger.info(&quot;初始化 DemoFilter 过滤器 Bean&quot;);        FilterRegistrationBean&lt;Filter&gt; initXssFilterBean = new FilterRegistrationBean&lt;&gt;();        initXssFilterBean.setFilter(new DemoFilter());        initXssFilterBean.setOrder(1);        initXssFilterBean.setEnabled(true);        initXssFilterBean.addUrlPatterns(&quot;/*&quot;);        initXssFilterBean.setDispatcherTypes(DispatcherType.REQUEST);        return initXssFilterBean;    &#125;&#125;</code></pre><p>setOrder方法可以对这个 Filter 设置一个优先级，这个值越小，越先被执行。尽量不要与其他的 Filter 冲突</p><h2 id="3-HttpServletRequestWrapper-修改参数"><a href="#3-HttpServletRequestWrapper-修改参数" class="headerlink" title="3. HttpServletRequestWrapper 修改参数"></a>3. HttpServletRequestWrapper 修改参数</h2><p>有些时候我们可能需要对参数进行修改，比如XSS过滤，防SQL注入等。这个时候我们可以通过<code>HttpServletRequestWrapper</code> 来对参数进行修改。 创建 <code>DemoHttpServletRequestWrapper</code>。通过重写这个类的一些方法来对参数进行修改。</p><pre><code>package com.zdran.springboot.filter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpSession;import java.io.*;import java.util.Map;/** * Create by ranzd on 2018/8/9 * * @author cm.zdran@gmail.com */public class DemoHttpServletRequestWrapper extends HttpServletRequestWrapper &#123;    private Logger logger = LoggerFactory.getLogger(DemoHttpServletRequestWrapper.class);    public DemoHttpServletRequestWrapper(HttpServletRequest request) &#123;        super(request);    &#125;    @Override    public String getHeader(String name) &#123;        String value = super.getHeader(name);        logger.info(&quot;获取 Header 中的参数：&#123;&#125;&quot;, value);        return value;    &#125;    @Override    public String getParameter(String name) &#123;        String value = super.getParameter(name);        logger.info(&quot;获取 getParameter 中的参数：&#123;&#125;&quot;, value);        return value;    &#125;    @Override    public Map&lt;String, String[]&gt; getParameterMap() &#123;        Map&lt;String, String[]&gt; map = super.getParameterMap();        logger.info(&quot;获取 getParameterMap 中的参数：&#123;&#125;&quot;, map);        return map;    &#125;    @Override    public HttpSession getSession() &#123;        HttpSession session = super.getSession();        logger.info(&quot;获取 getCookies 中的cookie：&#123;&#125;&quot;, session);        return session;    &#125;    @Override    public Object getAttribute(String name) &#123;        Object obj = super.getAttribute(name);        logger.info(&quot;获取 getCookies 中的cookie：&#123;&#125;&quot;, obj);        return obj;    &#125;    @Override    public String[] getParameterValues(String name) &#123;        String[] value = super.getParameterValues(name);        logger.info(&quot;获取 getParameter 中的参数：&#123;&#125;&quot;, value);        return value;    &#125;    @Override    public ServletInputStream getInputStream() throws IOException &#123;        BufferedReader br = new BufferedReader(new InputStreamReader(super.getInputStream()));        StringBuilder resultBuilder = new StringBuilder();        String line;        while ((line = br.readLine()) != null) &#123;            resultBuilder.append(line);        &#125;        String result = resultBuilder.toString();        logger.info(&quot;获取 getInputStream 中的参数：&#123;&#125;&quot;, result);        return new WrappedServletInputStream(new ByteArrayInputStream(result.getBytes()));    &#125;    /**     * 读取 RequestBody 中的参数时需要重新再次写入到流中，     * 否则在 Controller 中会读取不到参数。     */    private class WrappedServletInputStream extends ServletInputStream &#123;        public void setStream(InputStream stream) &#123;            this.stream = stream;        &#125;        private InputStream stream;        public WrappedServletInputStream(InputStream stream) &#123;            this.stream = stream;        &#125;        @Override        public int read() throws IOException &#123;            return stream.read();        &#125;        @Override        public boolean isFinished() &#123;            return true;        &#125;        @Override        public boolean isReady() &#123;            return true;        &#125;        @Override        public void setReadListener(ReadListener readListener) &#123;        &#125;    &#125;&#125;</code></pre><p><strong>注意：</strong> 在读取 RequestBody中的参数的时候需要用 <code>getInputStream</code> 方法，而且读取结束后，必须再次向该流中写入，否则Controller将读取不到参数。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(七) 整合 Swagger2</title>
      <link href="20180730.html"/>
      <url>20180730.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h2><p>Swagger2 可以自动的根据代码生成接口文档。</p><p>添加依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- swagger api 管理工具 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>注意需要添加：spring boot web 依赖</strong></p><h2 id="2-添加Swagger配置"><a href="#2-添加Swagger配置" class="headerlink" title="2. 添加Swagger配置"></a>2. 添加Swagger配置</h2><p>修改 SpringbootApplication 启动类</p><pre><code>@SpringBootApplication@EnableSwagger2@ComponentScan(&#123;&quot;com.zdran.springboot&quot;&#125;)public class SpringbootApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootApplication.class, args);    &#125;    @Bean    public Docket createRestApi() &#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.zdran.springboot.controller&quot;))                .paths(PathSelectors.any())                .build();    &#125;    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;个人学习Spring Boot 的项目 APIs&quot;)                .description(&quot;学习Spring Boot 中的 restful APIs&quot;)                .termsOfServiceUrl(&quot;https://github.com/zdRan/learning&quot;)                .contact(new Contact(&quot;个人开源项目组&quot;,                                     &quot;https://github.com/zdRan/learning&quot;,                                     &quot;cm.zdran@gmail.com&quot;))                .version(&quot;1.0&quot;)                .build();    &#125;</code></pre><p>默认访问地址是： <code>http://localhost:9090/learning/swagger-ui.html</code></p><h2 id="3-Swagger-注解"><a href="#3-Swagger-注解" class="headerlink" title="3. Swagger 注解"></a>3. Swagger 注解</h2><p>Swagger 有很多自定义的注解可以很方便的对接口进行描述</p><h3 id="3-1-Api"><a href="#3-1-Api" class="headerlink" title="3.1 @Api"></a>3.1 @Api</h3><p>用在一个Controller上，swagger会将这个controller下的接口归为一组展示。<br>常用属性：</p><ol><li>tags: 分组标签</li><li>value: 如果tags没有定义，value将作为tags使用</li><li>description： API的详细描述</li></ol><p>个人建议的写法：</p><pre><code>@Api(tags = &quot;AccountController&quot;,description = &quot;账户信息相关接口&quot;)public class AccountController &#123;    //... ...&#125;</code></pre><h3 id="3-2-ApiOperation"><a href="#3-2-ApiOperation" class="headerlink" title="3.2 @ApiOperation"></a>3.2 @ApiOperation</h3><p>用在方法上。对该方法的描述信息</p><p>常用属性：</p><ol><li>value: 对方法的简单描述，长度为120个字母，60个汉字。</li><li>notes: 对操作的详细说明。</li><li>httpMethod: 请求方式，可选值有”GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH”。</li><li>code http 状态码，默认为200</li></ol><p>个人建议的写法：</p><pre><code>@ApiOperation(value = &quot;获取账号信息&quot;,        notes = &quot;根据传入的参数 name 查询账号信息。&quot;,        httpMethod= &quot;GET&quot;)@GetMapping(&quot;/get/&#123;name&#125;&quot;)public AccountInfo getAccountByName(@PathVariable String name)&#123;    //... ...&#125;</code></pre><h3 id="3-3-ApiImplicitParams-与-ApiImplicitParam"><a href="#3-3-ApiImplicitParams-与-ApiImplicitParam" class="headerlink" title="3.3 @ApiImplicitParams 与 @ApiImplicitParam"></a>3.3 @ApiImplicitParams 与 @ApiImplicitParam</h3><p>用在方法上。对参数列表的说明，这两个注解时连用的。ApiImplicitParams 内部有多个 ApiImplicitParam，每个 ApiImplicitParam 对应一个参数，常用属性：</p><ol><li>name: 参数名称</li><li>value: 参数描述</li><li>paramType: 参数的传入（请求）类型，可选的值有path, query, body, header or form</li><li>dataType: 参数类型。可以为类名，也可以为基本类型（String，int、boolean等）</li><li>required: 是否是必填字段。</li></ol><p>个人建议的写法：</p><pre><code>    @ApiImplicitParams(&#123;            @ApiImplicitParam(                    name = &quot;name&quot;,                    value = &quot;用户名&quot;,                    paramType = &quot;path&quot;,                    dataType = &quot;String&quot;,                    required = true            )    &#125;)    @GetMapping(&quot;/get/&#123;name&#125;&quot;)    public AccountInfo getAccountByName(@PathVariable String name)&#123;        //... ...    &#125;</code></pre><h3 id="3-4-ApiResponses-与-ApiResponse"><a href="#3-4-ApiResponses-与-ApiResponse" class="headerlink" title="3.4 @ApiResponses 与 ApiResponse"></a>3.4 @ApiResponses 与 ApiResponse</h3><p>用在方法上，对方法的返回值（响应结果）进行说明。ApiResponses内部有多个ApiResponse。<br>ApiResponse 常用属性：</p><ol><li>code:http状态码</li><li>message：对应状态码的描述</li><li>response：返回值。如果是类名的话，需要类的全路径</li><li>responseContainer：如果返回类型为容器类型，可以设置相应的值。有效值为 “List”, “Set” or “Map”</li></ol><p>个人建议的写法：</p><pre><code>    @ApiResponses(&#123;            @ApiResponse(                    code = 200,                    message = &quot;成功&quot;,                    response = com.zdran.springboot.dao.AccountInfo.class            ),            @ApiResponse(                    code = 404,                    message = &quot;网络异常&quot;,                    response = Exception.class            )    &#125;)    @GetMapping(&quot;/get/&#123;name&#125;&quot;)    public AccountInfo getAccountByName(@PathVariable String name)&#123;        //... ...    &#125;</code></pre><p>一般 404 的 response 值应该是自定义的异常返回对象。</p><h3 id="3-4-ApiModel-与-ApiModelProperty"><a href="#3-4-ApiModel-与-ApiModelProperty" class="headerlink" title="3.4 @ApiModel 与 @ApiModelProperty"></a>3.4 @ApiModel 与 @ApiModelProperty</h3><p>这两个注解是用在实体类上面的，对实体类和参数进行说明。</p><p>ApiModel: 用在类上面，对类进行说明，有两个属性</p><ol><li>value: 类的别名，默认是类名</li><li>description： 类的详细描述</li></ol><p>ApiModelProperty: 用在类的属性上，对属性进行说明。 常用属性：</p><ol><li>value: 属性的描述</li><li>example: 属性的示例值</li></ol><p>个人建议的写法：</p><pre><code>@ApiModel(        value = &quot;AccountInfo&quot;,        description = &quot;用户信息实体类&quot;)public class AccountInfo &#123;    @ApiModelProperty(            value = &quot;账户id&quot;,            example = &quot;123455&quot;,            dataType = &quot;Integer&quot;    )    private Integer accountId;    @ApiModelProperty(            value = &quot;用户名&quot;,            example = &quot;zdran&quot;,            dataType = &quot;String&quot;    )    private String name;</code></pre><p>配置这些基本上就可以了，再多的话，代码入侵就有点多了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Swagger2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(六) 整合 RESTful 参数传递</title>
      <link href="20180725.html"/>
      <url>20180725.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>前后端菜单参数传递一直是初学时的痛点，不知道参数类型与注解到底怎么样去配合。</p><p>其实整理一下就会发现。前后端参数传递大概有这么几种情况：</p><p>常见参数数据类型：</p><ul><li>基本类型（Stirng，int等）</li><li>引用数据类型（POJO等简单对象）</li><li>复杂的引用数据类型（数组、集合等）</li></ul><p>常见传参方式：</p><ul><li>URL传参</li><li>RequestBody 传参</li></ul><p>组合一下大概有6种常见的场景。</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>环境说明：</p><ul><li>RESTful 风格传参</li><li>前端js: jQuery.js</li><li>参数格式: json格式</li><li>编码格式：UTF-8</li></ul><p>引入 jQuery, <a href="https://github.com/jquery/jquery/releases">下载地址</a>，将下载好的jquery.min.js放到<code>resources/static/js</code>下面</p><p>然后在 templates 下面创建一个 <code>parameterPassing.html</code>作为参数传递的测试页面。添加以下代码:</p><pre><code>&lt;head&gt;    ....    &lt;script src=&quot;/learning/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;</code></pre><p><strong>别忘了在 PageController 里面添加一个获取 parameterPassing 页面的接口</strong></p><p>再创建一个 ParameterController 用于接收参数的controller。</p><p>这篇文章的所有代码都只在这两个文件中，如果文章中有不太详细的地方，可以下载源码看一下。</p><p><strong>PS: 本来js是需要单独一个文件的，但是为了方便学习，这里就直接写在 html 里了。</strong></p><h2 id="2-GET-方式传递基本类型"><a href="#2-GET-方式传递基本类型" class="headerlink" title="2. GET 方式传递基本类型"></a>2. GET 方式传递基本类型</h2><p>最简单的一种常见，传递一个基本类型到后台。</p><h3 id="2-1-PathVariable-注解"><a href="#2-1-PathVariable-注解" class="headerlink" title="2.1 PathVariable 注解"></a>2.1 PathVariable 注解</h3><p>ParameterController:</p><pre><code>@RestController@RequestMapping(&quot;/parameter&quot;)public class ParameterController &#123;    private Logger logger = LoggerFactory.getLogger(ParameterController.class);    @GetMapping(&quot;/getString/&#123;str&#125;&quot;)    public String getString(@PathVariable(value = &quot;str&quot;) String str)&#123;        logger.info(&quot;GET 传参，传递基本类型。str：&#123;&#125;&quot;,str);        return &quot;收到参数：&quot; + str;    &#125;&#125;</code></pre><p>ParameterPassing.html</p><pre><code>&lt;body&gt;    &lt;h2&gt;测试参数传递&lt;/h2&gt;    &lt;button id = &quot;bt1&quot;&gt;get传递String&lt;/button&gt;    &lt;input id=&quot;in1&quot; type=&quot;text&quot;&gt;&lt;/body&gt;&lt;script&gt;    $(&quot;#bt1&quot;).click(        function () &#123;            $.ajax(                &#123;                    url:&quot;/learning/parameter/getString/&quot;+$(&quot;#in1&quot;).val(),                    method:&quot;GET&quot;,                    success:function (result) &#123;                        alert(result);                    &#125;                &#125;            )        &#125;    );&lt;/script&gt;</code></pre><h3 id="2-2-RequestParam-注解"><a href="#2-2-RequestParam-注解" class="headerlink" title="2.2 RequestParam 注解"></a>2.2 RequestParam 注解</h3><p>ParameterController</p><pre><code>    @GetMapping(&quot;/getName&quot;)    public String getName(@RequestParam(value = &quot;name&quot;) String name)&#123;        logger.info(&quot;GET 传参，传递基本类型。str：&#123;&#125;&quot;,name);        return &quot;收到参数：&quot; + name;    &#125;</code></pre><p>ParameterPassing.html</p><pre><code>    $(&quot;#bt2&quot;).click(        function () &#123;            $.ajax(                &#123;                    url: &quot;/learning/parameter/getName&quot;,                    method: &quot;GET&quot;,                    data: &#123;                        name: $(&quot;#in2&quot;).val()                    &#125;,                    success: function (result) &#123;                        alert(result);                    &#125;                &#125;            );        &#125;    );    //拼接url方式    $(&quot;#bt3&quot;).click(        function () &#123;            $.ajax(                &#123;                    url: &quot;/learning/parameter/getName?name=&quot;+$(&quot;#in3&quot;).val(),                    method: &quot;GET&quot;,                    success: function (result) &#123;                        alert(result);                    &#125;                &#125;            );        &#125;    );</code></pre><p><strong>注意:</strong></p><p>PathVariable 注解的参数是直接拼接在url里的，不是放在data里的。</p><p>RequestParam 注解的参数可以放在data里，也可以拼接url，格式是 <code>?key=value</code></p><p><strong>PS：前后端参数的key一定要一致不然会报一个”Required String parameter ‘nae’ is not present” 的错误</strong></p><h2 id="3-POST-方式传递基本类型"><a href="#3-POST-方式传递基本类型" class="headerlink" title="3. POST 方式传递基本类型"></a>3. POST 方式传递基本类型</h2><p>Post 方式传递基本类型与Get方式基本一样。</p><h3 id="3-1-PathVariable-注解"><a href="#3-1-PathVariable-注解" class="headerlink" title="3.1 PathVariable 注解"></a>3.1 PathVariable 注解</h3><p>ParameterController</p><pre><code>    @PostMapping(&quot;/postString/&#123;str&#125;&quot;)    public String postString(@PathVariable(value = &quot;str&quot;) String str)&#123;        logger.info(&quot;POST 传参，传递基本类型。str：&#123;&#125;&quot;,str);        return &quot;收到参数：&quot; + str;    &#125;</code></pre><p>ParameterPassing.html</p><pre><code>    $(&quot;#bt4&quot;).click(        function () &#123;            $.ajax(                &#123;                    url:&quot;/learning/parameter/postString/&quot;+$(&quot;#in4&quot;).val(),                    method:&quot;POST&quot;,                    success:function (result) &#123;                        alert(result);                    &#125;                &#125;            )        &#125;    );</code></pre><h3 id="3-2-RequestParam-注解"><a href="#3-2-RequestParam-注解" class="headerlink" title="3.2 RequestParam 注解"></a>3.2 RequestParam 注解</h3><p>ParameterController</p><pre><code>    @PostMapping(&quot;/postName&quot;)    public String postName(@RequestParam(value = &quot;name&quot;) String name)&#123;        logger.info(&quot;POST 传参，传递基本类型。str：&#123;&#125;&quot;,name);        return &quot;收到参数：&quot; + name;    &#125;</code></pre><p>ParameterPassing.html</p><pre><code>    $(&quot;#bt5&quot;).click(        function () &#123;            $.ajax(                &#123;                    url: &quot;/learning/parameter/postName&quot;,                    method: &quot;POST&quot;,                    data: &#123;                        name: $(&quot;#in5&quot;).val()                    &#125;,                    success: function (result) &#123;                        alert(result);                    &#125;                &#125;            );        &#125;    );    //拼接url方式    $(&quot;#bt6&quot;).click(        function () &#123;            $.ajax(                &#123;                    url: &quot;/learning/parameter/postName?name=&quot;+$(&quot;#in6&quot;).val(),                    method: &quot;POST&quot;,                    success: function (result) &#123;                        alert(result);                    &#125;                &#125;            );        &#125;    );</code></pre><p>基本类型的传参方式这几种方式差不多就够用了。如果你使用的是RESTful的风格，建议使用 2.1 的格式。</p><h2 id="4-POST-传递引用类型"><a href="#4-POST-传递引用类型" class="headerlink" title="4. POST 传递引用类型"></a>4. POST 传递引用类型</h2><p>PathVariable 注解不支持引用类型。</p><p>RequestParam 注解也不支持引用类型，有一种做法是将json串以String类型传递。用RequestParam 注解可以，不过需要对参数进行编码。</p><p>所以这里仅介绍下 RequestBody 注解。</p><p>ParameterController</p><pre><code>    @PostMapping(&quot;/postAccount&quot;)    public AccountInfo postAccount(@RequestBody AccountInfo accountInfo) &#123;        logger.info(&quot;GET 传参，传递基本类型。str：&#123;&#125;&quot;, accountInfo);        return accountInfo;    &#125;</code></pre><p>ParameterPassing.html</p><pre><code>    $(&quot;#bt7&quot;).click(        function () &#123;            var accountInfo = &#123;                accountId: 123,                name: $(&quot;#in7&quot;).val(),                pwd: &quot;root&quot;,                balance: 123            &#125;;            $.ajax(                &#123;                    url: &quot;/learning/parameter/postAccount&quot;,                    method: &quot;POST&quot;,                    data: JSON.stringify(accountInfo),                    contentType:&quot;application/json&quot;,                    success: function (result) &#123;                        alert(JSON.stringify(result));                    &#125;                &#125;            );        &#125;    );</code></pre><h2 id="5-传递数组"><a href="#5-传递数组" class="headerlink" title="5. 传递数组"></a>5. 传递数组</h2><h3 id="5-1-传递基本类型的数组"><a href="#5-1-传递基本类型的数组" class="headerlink" title="5.1 传递基本类型的数组"></a>5.1 传递基本类型的数组</h3><p>ParameterController</p><pre><code>    @PostMapping(&quot;/postNames&quot;)    public List&lt;String&gt; postNames(@RequestBody String[] names) &#123;        logger.info(&quot;GET 传参，传递基本类型。str：&#123;&#125;&quot;, Arrays.asList(names).toString());        return Arrays.asList(names);    &#125;</code></pre><p>ParameterPassing.html</p><pre><code>    $(&quot;#bt8&quot;).click(        function () &#123;            var names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,$(&quot;#in8&quot;).val()];            $.ajax(                &#123;                    url: &quot;/learning/parameter/postNames&quot;,                    method: &quot;POST&quot;,                    data: JSON.stringify(names),                    contentType:&quot;application/json&quot;,                    success: function (result) &#123;                        alert(JSON.stringify(result));                    &#125;                &#125;            );        &#125;    );</code></pre><h3 id="5-2-传递复杂类型的集合（数组）"><a href="#5-2-传递复杂类型的集合（数组）" class="headerlink" title="5.2 传递复杂类型的集合（数组）"></a>5.2 传递复杂类型的集合（数组）</h3><p>ParameterController</p><pre><code>    @PostMapping(&quot;/postAccountList&quot;)    public List&lt;AccountInfo&gt; postAccountList(@RequestBody List&lt;AccountInfo&gt; accounts) &#123;        logger.info(&quot;GET 传参，传递基本类型。str：&#123;&#125;&quot;, accounts.toString());        return accounts;    &#125;</code></pre><p>ParameterPassing.html</p><pre><code>    $(&quot;#bt9&quot;).click(        function () &#123;            var accounts = [];            var accountInfo1 = &#123;                accountId: 123,                name: $(&quot;#in9&quot;).val(),                pwd: &quot;root&quot;,                balance: 123            &#125;;            accounts.push(accountInfo1);            var accountInfo2 = &#123;                accountId: 123,                name: $(&quot;#in9&quot;).val(),                pwd: &quot;root&quot;,                balance: 123            &#125;;            accounts.push(accountInfo2);            $.ajax(                &#123;                    url: &quot;/learning/parameter/postAccountList&quot;,                    method: &quot;POST&quot;,                    data: JSON.stringify(accounts),                    contentType:&quot;application/json&quot;,                    success: function (result) &#123;                        alert(JSON.stringify(result));                    &#125;                &#125;            );        &#125;    );</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(五) 整合 静态资源</title>
      <link href="20180718.html"/>
      <url>20180718.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h2><p>由于 Spring Boot 采用了”约定优于配置”这种规范，所以在使用静态资源的时候也很简单。</p><p>Spring Boot 对于静态资源用一种默认的约定。</p><pre><code>resources/static: 放js、css、image等resources/templates: 放 html 或者各种模板引擎的模板文件。</code></pre><p>如果要使用 templates 首先要添加 templates的依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="1-访问static下的文件"><a href="#1-访问static下的文件" class="headerlink" title="1. 访问static下的文件"></a>1. 访问static下的文件</h2><p>在 static 下放一张图片, 名字为 <code>spring-boot.jpg</code>,</p><p>然后启动访问下:<code>http://localhost:9090/learning/spring-boot.jpg</code></p><h2 id="2-访问templates下的文件"><a href="#2-访问templates下的文件" class="headerlink" title="2. 访问templates下的文件"></a>2. 访问templates下的文件</h2><p>由于templates下的文件是模板文件，显示的时候需要数据的支持，所以需要写固定的controller来访问。我们在templates写个<code>helloSpring.html</code>文件，内容如下：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        hello spring！    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>编写对应的controller，创建一个<code>PageController</code>类，内容如下：</p><pre><code>/** * Create by ranzd on 2018/7/18 * * @author cm.zdran@gmail.com */@Controller@RequestMapping(&quot;/page&quot;)public class PageController &#123;    @RequestMapping(value = &quot;/helloSpring&quot;, method = RequestMethod.GET)    public String getAccountByName() &#123;        return &quot;helloSpring&quot;;    &#125;&#125;</code></pre><p><strong>静态资源的访问好像不支持RestController,下面这种写法是访问不到页面的</strong></p><pre><code>@RestController@RequestMapping(&quot;/page&quot;)public class PageController &#123;    @GetMapping(&quot;/helloSpring&quot;)    public String getAccountByName() &#123;        return &quot;helloSpring&quot;;    &#125;&#125;</code></pre><p>启动，访问一下 <code>http://localhost:9090/learning/page/helloSpring</code></p><h2 id="3-html-引用-static下的资源文件"><a href="#3-html-引用-static下的资源文件" class="headerlink" title="3. html 引用 static下的资源文件"></a>3. html 引用 static下的资源文件</h2><p>下面我们将图片加入到html的页面中去。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;img src=&quot;/learning/images/spring-boot.jpg&quot;&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>html中的路径是：项目名 + static 下的目录。当然你也可以理解为把static换成项目名就是html中的路径。</p><p>比如：图片在项目中的路径是: <code>/static/images/spring-boot.jpg</code>那么在html中引用它的路径就是把 static换成项目名：<code>/learning/images/spring-boot.jpg</code></p><p><strong>这里说的项目名是指在yaml里配置的  context-path 不是代码的项目名称</strong></p><h2 id="4-解决thymeleaf严格校验"><a href="#4-解决thymeleaf严格校验" class="headerlink" title="4. 解决thymeleaf严格校验"></a>4. 解决thymeleaf严格校验</h2><p>在使用 thymeleaf 的时候经常出现的一个问题是：</p><pre><code>org.xml.sax.SAXParseException: 元素类型 &quot;xxx&quot; 必须由匹配的结束标记 &quot;&lt;/xxx&gt;&quot; 终止。 </code></pre><p>这是因为 thymeleaf 对html代码进行了严格的校验。解决办法有两个。</p><p>第一个比较简单，就是把 终止标签补上就可以了。</p><p>第二个办法就是禁用严格校验。下面说一下禁用方式。</p><p><strong>以下解决方案参考自网络，个人的建议还是直接补上结束标签</strong></p><p>可以在 yaml 文件里添加一个配置</p><pre><code>spring:  thymeleaf:    mode: LEGACYHTML5    cache: false</code></pre><p>如果还是不行的话，可以添加一下依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;    &lt;artifactId&gt;nekohtml&lt;/artifactId&gt;    &lt;version&gt;1.9.21&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>如果还是不行，就把结束标签补上吧，别挣扎了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindBugs 常见错误类型整理</title>
      <link href="20180717.html"/>
      <url>20180717.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Dodgy-code-糟糕的代码"><a href="#1-Dodgy-code-糟糕的代码" class="headerlink" title="1.Dodgy code 糟糕的代码"></a>1.Dodgy code 糟糕的代码</h2><h3 id="1-1-Misuse-of-static-fields"><a href="#1-1-Misuse-of-static-fields" class="headerlink" title="1.1 Misuse of static fields"></a>1.1 Misuse of static fields</h3><p>滥用静态字段</p><ul><li>Write to static field from instance method </li></ul><pre><code>由于在方法内对静态属性进行赋值操作class A&#123;    private static int count;    public void init(int num)&#123;        count = num;    &#125;&#125;</code></pre><h3 id="1-2-Null-pointer-dereference"><a href="#1-2-Null-pointer-dereference" class="headerlink" title="1.2 Null pointer dereference"></a>1.2 Null pointer dereference</h3><p>引用null对象</p><ul><li>Load of known null value</li></ul><pre><code>引用了一个为 NULL 的对象class A&#123;    private static int count;    public void init(int num)&#123;        Integer num = null;        num.intValue();    &#125;&#125;</code></pre><h3 id="1-3-Dead-local-store"><a href="#1-3-Dead-local-store" class="headerlink" title="1.3 Dead local store"></a>1.3 Dead local store</h3><p>本地变量存储了闲置不用的对象</p><ul><li>Dead store to local variable</li></ul><pre><code>对变量进行赋值，但是后面的代码没有用到这个变量class A&#123;    //第一种情况    public void init(int a)&#123;        int num = 3;        num = a;    &#125;    //第二种情况    public void init(int a)&#123;        int num = 3;        //...    &#125;&#125;</code></pre><h3 id="1-4-Useless-code"><a href="#1-4-Useless-code" class="headerlink" title="1.4 Useless code"></a>1.4 Useless code</h3><p>无用的代码</p><ul><li>Useless object created</li></ul><pre><code>创建了无用的对象class A&#123;    public void init(int a)&#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();    &#125;&#125;</code></pre><ul><li>Useless non-empty void method</li></ul><pre><code>创建了无用的方法class A&#123;    public void init()&#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;123&quot;);        list.add(&quot;234&quot;);    &#125;&#125;</code></pre><h3 id="1-5-RuntimeException-capture"><a href="#1-5-RuntimeException-capture" class="headerlink" title="1.5 RuntimeException capture"></a>1.5 RuntimeException capture</h3><p>（滥用）异常捕获</p><ul><li>Exception is caught when Exception is not thrown</li></ul><pre><code>在不会抛出异常的代码里尝试捕获异常class A&#123;    public void init()&#123;        try&#123;            List&lt;String&gt; list = new ArrayList&lt;&gt;();        &#125;catch (Exception e) &#123;        &#125;    &#125;&#125;</code></pre><h3 id="1-6-Bad-use-of-return-value-from-method"><a href="#1-6-Bad-use-of-return-value-from-method" class="headerlink" title="1.6 Bad use of return value from method"></a>1.6 Bad use of return value from method</h3><p>方法的返回值使用不当</p><ul><li>Return value of method without side effect is ignored</li></ul><pre><code>忽略没有副作用的方法的返回值class A&#123;    public void init()&#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.size();    &#125;&#125;</code></pre><h3 id="1-7-Redundant-comparison-to-null"><a href="#1-7-Redundant-comparison-to-null" class="headerlink" title="1.7 Redundant comparison to null"></a>1.7 Redundant comparison to null</h3><p>对 null 值的冗余校验</p><ul><li>Redundant nullcheck of value known to be non-null</li></ul><pre><code>对已知的非空对象进行null值校验class A&#123;    public void init()&#123;        if(getList() != null)&#123;        &#125;else&#123;        &#125;    &#125;    private List&lt;String&gt; getList()&#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        return list    &#125;&#125;</code></pre><ul><li>Redundant nullcheck of value known to be null</li></ul><pre><code>对已知的空对象进行null值校验class A&#123;    public void init()&#123;        if(getList() == null)&#123;        &#125;else&#123;        &#125;    &#125;    private List&lt;String&gt; getList()&#123;        return null    &#125;&#125;</code></pre><h3 id="1-7-Suspicious-integer-expression"><a href="#1-7-Suspicious-integer-expression" class="headerlink" title="1.7 Suspicious integer expression"></a>1.7 Suspicious integer expression</h3><p>可疑的整数表达式</p><ul><li>Vacuous bit mask operation on integer value</li></ul><pre><code>整数值上的空位掩码操作class A&#123;    public void init(int num)&#123;        int a = num &amp; 0xFFFFFFFF;    &#125;&#125;</code></pre><h3 id="1-8-Duplicate-Branches"><a href="#1-8-Duplicate-Branches" class="headerlink" title="1.8 Duplicate Branches"></a>1.8 Duplicate Branches</h3><p>重复分支</p><ul><li>Method uses the same code for two branches</li></ul><pre><code>两个分支内的代码一样class A&#123;    public void init(int num)&#123;        if(num&gt;0)&#123;            num = 0;        &#125;else&#123;            num = 0;        &#125;    &#125;&#125;</code></pre><h3 id="1-9-Dubious-method-invocation"><a href="#1-9-Dubious-method-invocation" class="headerlink" title="1.9 Dubious method invocation"></a>1.9 Dubious method invocation</h3><p>可疑的方法调用</p><ul><li>Code contains a hard coded reference to an absolute pathname</li></ul><pre><code>代码包含绝对路径的硬编码引用class A&#123;    public void init(int num)&#123;        File file = new File(&quot;D:\test\test.txt&quot;);    &#125;&#125;</code></pre><h3 id="1-10-Test-for-floating-point-equality"><a href="#1-10-Test-for-floating-point-equality" class="headerlink" title="1.10 Test for floating point equality"></a>1.10 Test for floating point equality</h3><p>比较两个浮点数是否相等</p><ul><li>Test for floating point equality</li></ul><pre><code>比较两个浮点数是否相等class A&#123;    public void init(double a,double b)&#123;        if (a == b)&#123;        &#125;    &#125;&#125;</code></pre><h3 id="1-11-Null-pointer-dereference"><a href="#1-11-Null-pointer-dereference" class="headerlink" title="1.11 Null pointer dereference"></a>1.11 Null pointer dereference</h3><p>引用空对象</p><ul><li>Load of known null value</li></ul><pre><code>引用已知为null的对象class A&#123;    public void init(List&lt;String&gt; list)&#123;        if (list == null)&#123;            System.out.print(list.toString());        &#125;    &#125;&#125;</code></pre><h3 id="1-12-Switch-case-falls-through"><a href="#1-12-Switch-case-falls-through" class="headerlink" title="1.12 Switch case falls through"></a>1.12 Switch case falls through</h3><p>switch 语句使用不当</p><ul><li>Switch statement found where default case is missing</li></ul><pre><code>switch 语句缺少 default 分支class A&#123;    public void init(int a)&#123;        switch a &#123;            case 1:                break;            case 2:                 break;            &#125;    &#125;&#125;</code></pre><h2 id="2-Correctness-正确性"><a href="#2-Correctness-正确性" class="headerlink" title="2.Correctness 正确性"></a>2.Correctness 正确性</h2><h3 id="2-1-Null-pointer-dereference"><a href="#2-1-Null-pointer-dereference" class="headerlink" title="2.1 Null pointer dereference"></a>2.1 Null pointer dereference</h3><p>引用空指针</p><ul><li>Possible null pointer dereference</li></ul><pre><code>可能会抛出空指针异常class A&#123;    public void init(List&lt;String&gt; list)&#123;        System.out.print(list.size());    &#125;&#125;</code></pre><ul><li>Possible null pointer dereference in method on exception path</li></ul><pre><code>引用了某个异常控制的对象。class A&#123;    public void init()&#123;        List&lt;String&gt; list = null；        try&#123;            list = new ArrayList&lt;&gt;();        &#125;catch (Exception e) &#123;        &#125;        System.out.print(list.size());    &#125;&#125;</code></pre><ul><li>Method call passes null for non-null parameter</li></ul><pre><code>方法调用对非null参数传递null值class A&#123;    public void init(String str)&#123;        //compareTo方法要求参数不能为null，否则会抛出NullPointerException        &quot;abc&quot;.compareTo(str)    &#125;&#125;</code></pre><ul><li>Null value is guaranteed to be dereferenced</li></ul><pre><code>保证不能引用空值class A&#123;    public void init(boolean flag)&#123;        List&lt;String&gt; list = null;        if(flag)&#123;            list.add(&quot;abc&quot;);        &#125;    &#125;&#125;</code></pre><h3 id="2-2-Useless-non-informative-string-generated"><a href="#2-2-Useless-non-informative-string-generated" class="headerlink" title="2.2 Useless/non-informative string generated"></a>2.2 Useless/non-informative string generated</h3><p>生成了无用/非信息的字符串</p><ul><li>Invocation of toString on an array</li></ul><pre><code>无效的 toString 方法class A&#123;    public void init(int[] arr)&#123;        //会打印出 arr 的哈希值，而不是数组的的内容        System.out.print(arr);    &#125;&#125;</code></pre><h3 id="2-3-Bad-use-of-return-value-from-method"><a href="#2-3-Bad-use-of-return-value-from-method" class="headerlink" title="2.3 Bad use of return value from method"></a>2.3 Bad use of return value from method</h3><p>方法的返回值使用不当</p><ul><li>Method ignores return value</li></ul><pre><code>该方法的返回值应该进行检查class A&#123;    public void init(int[] arr)&#123;        String dateString = getHeaderField(name);        dateString.trim();    &#125;&#125;PS：这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：String dateString = getHeaderField(name);dateString = dateString.trim();</code></pre><h3 id="2-4-Format-string-problem"><a href="#2-4-Format-string-problem" class="headerlink" title="2.4 Format string problem"></a>2.4 Format string problem</h3><p>字符串格式化问题</p><ul><li>More arguments are passed than are actually used in the format string</li></ul><pre><code>传递的参数多于格式字符串中实际使用的参数class A&#123;    public void init(String num1,String num2)&#123;        //错误，这种写法不会格式化字符串        String dateString = String.format(&quot;num1: &#123;&#125;,num2：&#123;&#125;&quot;, num1,num2)        String dateString2 = String.format(&quot;num1: &#123;0&#125;,num2：&#123;1&#125;&quot;, num1,num2)        //正确的写法        String dateString3 = String.format(&quot;num1: %s,num2：%s&quot;, num1,num2)    &#125;&#125;</code></pre><h3 id="2-5-Comparing-incompatible-types-for-equality"><a href="#2-5-Comparing-incompatible-types-for-equality" class="headerlink" title="2.5 Comparing incompatible types for equality"></a>2.5 Comparing incompatible types for equality</h3><p>比较不兼容的类型是否相等</p><ul><li>Call to equals() comparing different types</li></ul><pre><code>调用equals（）比较不同的类型class A&#123;    public void init(String str)&#123;        Integer num = new Integer()        if(str.equals(num))&#123;        &#125;    &#125;&#125;</code></pre><h3 id="2-6-Questionable-use-of-reference-equality-rather-than-calling-equals"><a href="#2-6-Questionable-use-of-reference-equality-rather-than-calling-equals" class="headerlink" title="2.6 Questionable use of reference equality rather than calling equals"></a>2.6 Questionable use of reference equality rather than calling equals</h3><p>对象的比较使用了 “==” 而不是调用 equals 方法</p><ul><li>Suspicious reference comparison</li></ul><pre><code>可疑的比较class A&#123;    public void init(String str)&#123;        if(&quot;abc&quot; == str)&#123;        &#125;    &#125;&#125;</code></pre><h3 id="2-7-Redundant-comparison-to-null"><a href="#2-7-Redundant-comparison-to-null" class="headerlink" title="2.7 Redundant comparison to null"></a>2.7 Redundant comparison to null</h3><p>与null值的冗余比较</p><ul><li>Nullcheck of value previously dereferenced</li></ul><pre><code>没有对参数进行空值校验class A&#123;    public void init(String str)&#123;        System.out.println(getStr().size())    &#125;    private List&lt;String&gt; getList()&#123;        return null;    &#125;&#125;</code></pre><h2 id="3-Bad-practice-不好的做法"><a href="#3-Bad-practice-不好的做法" class="headerlink" title="3.Bad practice 不好的做法"></a>3.Bad practice 不好的做法</h2><h3 id="3-1-Stream-not-closed-on-all-paths"><a href="#3-1-Stream-not-closed-on-all-paths" class="headerlink" title="3.1 Stream not closed on all paths"></a>3.1 Stream not closed on all paths</h3><p>IO流没有关闭</p><ul><li>Method may fail to close stream</li></ul><pre><code>方法体内没有对IO流进行关闭</code></pre><h3 id="3-2-Dropped-or-ignored-exception"><a href="#3-2-Dropped-or-ignored-exception" class="headerlink" title="3.2 Dropped or ignored exception"></a>3.2 Dropped or ignored exception</h3><p>忽略了异常</p><ul><li>Method might ignore exception</li></ul><pre><code>方法忽略了异常class A&#123;    public void init()&#123;        try&#123;        &#125;catch (Exception e) &#123;            //当抛出异常时什么都没有做        &#125;    &#125;&#125;</code></pre><h3 id="3-3-Bad-use-of-return-value-from-method"><a href="#3-3-Bad-use-of-return-value-from-method" class="headerlink" title="3.3 Bad use of return value from method"></a>3.3 Bad use of return value from method</h3><p>方法返回值使用不当（多为忽略了方法返回值）</p><ul><li>Method ignores exceptional return value</li></ul><pre><code>忽略了方法的异常返回值class A&#123;    public void init()&#123;        File file = new File(&quot;/aaa&quot;)        //文件mkdir可能返回false        file.getParentFile().mkdirs()    &#125;&#125;</code></pre><h3 id="3-4-Incorrect-definition-of-Serializable-class"><a href="#3-4-Incorrect-definition-of-Serializable-class" class="headerlink" title="3.4 Incorrect definition of Serializable class"></a>3.4 Incorrect definition of Serializable class</h3><p>序列化的类定义不正确</p><ul><li>Non-transient non-serializable instance field in serializable class</li></ul><pre><code>可序列化的类中存在不可序列化的属性class A implements Serializable&#123;    //List对象不能直接序列化    private List&lt;String&gt; list;&#125;</code></pre><h3 id="3-5-Checking-String-equality-using-or"><a href="#3-5-Checking-String-equality-using-or" class="headerlink" title="3.5 Checking String equality using == or !="></a>3.5 Checking String equality using == or !=</h3><p>Stirng 对象的比较使用了 == 或 !=</p><ul><li>Comparison of String parameter using == or !=</li></ul><pre><code>Stirng 对象的比较使用了 == 或 !=String对象的比较应该使用 equals() 方法</code></pre><h3 id="3-6-Confusing-method-name"><a href="#3-6-Confusing-method-name" class="headerlink" title="3.6 Confusing method name"></a>3.6 Confusing method name</h3><p>不规范的方法名</p><ul><li>Method names should start with a lower case letter</li></ul><pre><code>方法名应该以小写字母开头，符合驼峰式命名格式</code></pre><h2 id="4-Malicious-code-vulnerability-恶意代码漏洞"><a href="#4-Malicious-code-vulnerability-恶意代码漏洞" class="headerlink" title="4 Malicious code vulnerability 恶意代码漏洞"></a>4 Malicious code vulnerability 恶意代码漏洞</h2><h3 id="4-1-Method-returning-array-may-expose-internal-representation"><a href="#4-1-Method-returning-array-may-expose-internal-representation" class="headerlink" title="4.1 Method returning array may expose internal representation"></a>4.1 Method returning array may expose internal representation</h3><p>返回数组的方法可以暴露内部表示</p><ul><li>May expose internal representation by returning reference to mutable object</li></ul><pre><code>可以通过返回的可变对象的引用来公开内部表示class A&#123;    private List&lt;String&gt; list = new ArrayList&lt;&gt;();    public List&lt;String&gt; getList()&#123;        return list;    &#125;&#125;</code></pre><ul><li>May expose internal representation by incorporating reference to mutable object</li></ul><pre><code>可以通过引用可变对象来公开内部表示class A&#123;    private List&lt;String&gt; list;    public void setList(List&lt;String&gt; list)&#123;        this.list = list;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FindBugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(四) 整合 Druid 监控</title>
      <link href="20180706.html"/>
      <url>20180706.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>上一篇文章 <a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a> 仅仅是集成了Druid，</p><p>没有详细说明Druid的使用。这次说一下简单Druid的简单使用。</p><h2 id="1-创建-Druid-的Servlet"><a href="#1-创建-Druid-的Servlet" class="headerlink" title="1. 创建 Druid 的Servlet"></a>1. 创建 Druid 的Servlet</h2><p>我们需要为Druid的监控页面起一个Servlet:</p><pre><code>@Configurationpublic class DruidConfig &#123;    @Bean    @ConditionalOnMissingBean    public ServletRegistrationBean druidServlet() &#123;        ServletRegistrationBean servletRegistrationBean =                 new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);        //添加初始化参数：initParams        //白名单：        //servletRegistrationBean.addInitParameter(&quot;allow&quot;,&quot;127.0.0.1&quot;);        //IP黑名单 (存在共同时，deny优先于allow) :         //如果满足deny的话提示:Sorry, you are not permitted to view this page.        //servletRegistrationBean.addInitParameter(&quot;deny&quot;,&quot;127.0.0.2&quot;);        //登录查看信息的账号密码.        servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;root&quot;);        servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;******&quot;);        //是否能够重置数据.        servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;true&quot;);        return servletRegistrationBean;    &#125;&#125;</code></pre><p>启动，访问一下：<code>http://localhost:9090/learning/druid/index.html</code>,输入用户名密码。就能看到监控页面了</p><h2 id="2-测试一下"><a href="#2-测试一下" class="headerlink" title="2. 测试一下"></a>2. 测试一下</h2><p>使用我们上次开发的根据名字查询账号信息的接口，打开SQL监控就能看到监控信息了</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(三) 整合 MyBatis + Druid</title>
      <link href="20180703.html"/>
      <url>20180703.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="0-环境说明"><a href="#0-环境说明" class="headerlink" title="0. 环境说明"></a>0. 环境说明</h2><ul><li>MyBatis Generator 1.3.6</li><li>MySQL 5.7.17</li><li>驱动:mysql-connector-java-5.1.2.jar</li></ul><h2 id="1-MyBatis-Generator"><a href="#1-MyBatis-Generator" class="headerlink" title="1. MyBatis Generator"></a>1. MyBatis Generator</h2><p><a href="https://github.com/mybatis/generator">MyBatis Generator</a>是一款在使用mybatis框架时，自动生成model，dao和mapper的工具，很大程度上减少了业务开发人员的手动编码时间。</p><p>我们将使用这个工具自动化的构建 MVC 框架中 M 层所需要的东西。</p><h2 id="2-创建本地数据库"><a href="#2-创建本地数据库" class="headerlink" title="2. 创建本地数据库"></a>2. 创建本地数据库</h2><p>在本地的数据库中创建一张表</p><pre><code># 创建数据库CREATE DATABASE LEARNING CHARACTER SET utf8;USE LEARNING;# 创建表结构CREATE TABLE ACCOUNT_INFO(    ACCOUNT_ID INTEGER PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50),    PWD VARCHAR(50),    BALANCE INTEGER);# 插入一条数据INSERT INTO ACCOUNT_INFO VALUES(NULL,&#39;root&#39;,&#39;root&#39;,100);</code></pre><h2 id="3-使用MyBatis-Generator"><a href="#3-使用MyBatis-Generator" class="headerlink" title="3. 使用MyBatis Generator"></a>3. 使用MyBatis Generator</h2><p>下载地址：</p><ul><li><a href="https://github.com/mybatis/generator/releases">mybatis-generator-core-1.3.6.zip</a></li><li><a href="https://dev.mysql.com/downloads/connector/j/">mysql-connector-java-5.1.2.jar</a></li></ul><p><strong>如果你是Windows用户,下载mysql-connector的时候可以选择 Platform Independent 版本</strong></p><p>将下载好的MySQL驱动jar包放到generator的lib目录下，</p><p>确保<code>mybatis-generator-core-1.3.6.jar</code>和<code>mysql-connector-java-5.1.2.jar</code>在同一个目录下。</p><p>准备一个 configuration.xml 的配置文件，内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;     &lt;!-- 配置驱动jar包路径.用了相对路径 --&gt;    &lt;classPathEntry location=&quot;mysql-connector-java-5.1.2.jar&quot; /&gt;    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;!-- 为了防止生成的代码中有很多注释，比较难看，加入下面的配置控制 --&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;         &lt;!-- 数据库连接 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://localhost/LEARNING&quot; userId=&quot;root&quot;            password=&quot;********&quot;&gt;            &lt;property name=&quot;remarks&quot; value=&quot;true&quot; /&gt;        &lt;/jdbcConnection&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- 数据表对应的model 层  --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.zdran.springboot.dao&quot;            targetProject=&quot;D:\bxwzh&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- sql mapper 隐射配置文件 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.zdran.springboot.mapping&quot;            targetProject=&quot;D:\bxwzh&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- 在ibatis2 中是dao层，但在mybatis3中，其实就是mapper接口 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;com.zdran.springboot.mapper&quot; targetProject=&quot;D:\bxwzh&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/javaClientGenerator&gt;    &lt;!-- 要对哪些数据表进行生成操作，必须要有一个. --&gt;    &lt;table tableName=&quot;ACCOUNT_INFO&quot; domainObjectName=&quot;AccountInfo&quot;&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p><strong>注意：数据库的密码需要换成你自己的。targetProject=”D:\bxwzh，这个目录尽量是空文件夹</strong></p><p>在 generator 的lib目录下执行下面的命令：</p><pre><code>java -jar mybatis-generator-core-1.3.6.jar -configfile configuration.xml  -overwrite出现：MyBatis Generator finished successfully. 就说明成功了。</code></pre><p>我们直接将com目录拷贝到项目目录下面去</p><p>在resources 新建 mybaits 目录，然后将 mapping 文件夹移动到 mybaits 下</p><p>现在我们的项目结构是下面这样的：</p><div align="center">    ![项目结构](/images/3001.jpg)</div><p>添加 mybaits依赖：</p><pre><code>&lt;!--springBoot和mybatis继承--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;    &lt;!-- 移除 logging --&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- mysql 驱动--&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="4-添加MyBatis的配置"><a href="#4-添加MyBatis的配置" class="headerlink" title="4. 添加MyBatis的配置"></a>4. 添加MyBatis的配置</h2><p>在配置文件里添加下面的配置：</p><pre><code>mybatis:  mapperLocations: classpath:mybatis/mapping/*.xml  typeAliasesPackage: com.zdran.springboot.daospring:    datasource:        name: test        url: jdbc:mysql://localhost:3306/LEARNING        username: root        password: ********        driver-class-name: com.mysql.jdbc.Driver</code></pre><h2 id="5-测试一下"><a href="#5-测试一下" class="headerlink" title="5. 测试一下"></a>5. 测试一下</h2><p>在 SpringbootApplication 类上面添加包的扫描路径</p><pre><code>/** * 启动程序 * Create by zdRan on 2018/6/28 * * @author cm.zdran@gmail.com */@SpringBootApplication@MapperScan(basePackages = &quot;com.zdran.springboot.mapper&quot;)public class SpringbootApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootApplication.class, args);    &#125;&#125;</code></pre><p>下面我们实现一个根据姓名查询账号信息的接口。创建对应的controller、service等</p><p>Service 层的实现：</p><pre><code>/** * Create by ranzd on 2018/7/2 * * @author cm.zdran@gmail.com */@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    AccountInfoMapper accountInfoMapper;    @Override    public AccountInfo queryByName(String name) &#123;        AccountInfoExample example = new AccountInfoExample();        example.createCriteria().andNameEqualTo(name);        List&lt;AccountInfo&gt; accountInfoList = accountInfoMapper.selectByExample(example);        if (accountInfoList != null &amp;&amp; accountInfoList.size() != 0) &#123;            return accountInfoList.get(0);        &#125;        return null;    &#125;&#125;</code></pre><p>Controller层的实现：</p><pre><code>/** * Create by ranzd on 2018/7/3 * * @author cm.zdran@gmail.com */@RestController@RequestMapping(&quot;/account&quot;)public class AccountController &#123;    private Logger logger = LoggerFactory.getLogger(AccountController.class);    @Autowired    AccountService accountService;    @GetMapping(&quot;/get/&#123;name&#125;&quot;)    public AccountInfo getAccountByName(@PathVariable String name) &#123;        logger.info(&quot;根据姓名获取账号信息。入参：name：&#123;&#125;&quot;, name);        AccountInfo accountInfo = accountService.queryByName(name);        if (accountInfo == null) &#123;            logger.info(&quot;根据姓名获取账号信息。获取失败&quot;);        &#125;        logger.info(&quot;根据姓名获取账号信息。出参：accountInfo：&#123;&#125;&quot;, accountInfo.toString());        return accountInfo;    &#125;&#125;</code></pre><p>运行一下，访问 <code>http://localhost:9090/learning/account/get/root</code></p><p><strong>url最后的 root 用户名</strong></p><h2 id="5-集成-druid"><a href="#5-集成-druid" class="headerlink" title="5. 集成 druid"></a>5. 集成 druid</h2><p>上面的配置方法是最简单的配置方法。还有一种常常用于生产环境的配置方法。</p><p>添加 druid 依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>添加druid配置</p><pre><code>spring:    datasource:        url: jdbc:mysql://localhost:3306/LEARNING        username: root        password: ********        driver-class-name: com.mysql.jdbc.Driver        initialSize: 5        minIdle: 5        maxActive: 10        maxWait: 10000        timeBetweenEvictionRunsMillis: 60000        minEvictableIdleTimeMillis: 300000        testOnBorrow: false        testOnReturn: false        testWhileIdle: true        keepAlive: true        removeAbandoned: true        removeAbandonedTimeout: 80        logAbandoned: true        poolPreparedStatements: true        maxPoolPreparedStatementPerConnectionSize: 20        filters: stat,slf4j,wall</code></pre><p>添加依赖，方便使用 ConfigurationProperties 注解，来读取yml里的配置信息</p><pre><code>&lt;!-- 为了方便使用@ConfigurationProperties注解 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>创建 druid 配置文件读取类</p><pre><code>/** * Create by ranzd on 2018/7/3 * * @author cm.zdran@gmail.com */@Configuration@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public class DruidDataSourceProperties &#123;    private String driverClassName;    private String url;    private String username;    private String password;    private int initialSize;    private int minIdle;    private int maxActive;    private long maxWait;    private long timeBetweenEvictionRunsMillis;    private long minEvictableIdleTimeMillis;    private boolean testOnBorrow;    private boolean testOnReturn;    private boolean testWhileIdle;    private boolean keepAlive;    private boolean removeAbandoned;    private int removeAbandonedTimeout;    private boolean logAbandoned;    private boolean poolPreparedStatements;    private int maxPoolPreparedStatementPerConnectionSize;    private String filters;    //省略了所有属性的 get 、set方法&#125;</code></pre><p><strong>上面的代码省略了所有属性的 get 、set方法，你的本地代码一定要有get、set方法</strong></p><p>删除 yml 里的 mybaits 配置：</p><pre><code>mybatis:  mapperLocations: classpath:mybatis/mapping/*.xml  typeAliasesPackage: com.zdran.springboot.dao</code></pre><p>删除 SpringbootApplication 类上面的 MapperScan 注解</p><pre><code>@MapperScan(basePackages = &quot;com.zdran.springboot.mapper&quot;)</code></pre><p>创建 mybaits 的配置类：</p><pre><code>/** * Create by ranzd on 2018/7/3 * * @author cm.zdran@gmail.com */@Configuration@EnableTransactionManagement@MapperScan(        basePackages = &quot;com.zdran.springboot.mapper&quot;,         sqlSessionFactoryRef = &quot;learningSqlSessionFactory&quot;)public class MyBatisConfig &#123;    private Logger logger = LoggerFactory.getLogger(MyBatisConfig.class);    @Autowired    DruidDataSourceProperties druidDataSourceProperties;    @Bean(name = &quot;learningSqlSessionFactory&quot;)    @Primary    public SqlSessionFactory learningSqlSessionFactory() throws Exception &#123;        final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();        sessionFactory.setDataSource(getDruidDataSource());        sessionFactory.setTypeAliasesPackage(&quot;com.zdran.springboot.dao&quot;);        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver()                .getResources(&quot;classpath:/mybatis/mapping/*.xml&quot;));        return sessionFactory.getObject();    &#125;    @Bean(name = &quot;learningDataSource&quot;)    public DataSource getDruidDataSource() &#123;        DruidDataSource druidDataSource = new DruidDataSource();        druidDataSource.setDriverClassName(druidDataSourceProperties.getDriverClassName());        druidDataSource.setUrl(druidDataSourceProperties.getUrl());        druidDataSource.setUsername(druidDataSourceProperties.getUsername());        druidDataSource.setPassword(druidDataSourceProperties.getPassword());        druidDataSource.setInitialSize(druidDataSourceProperties.getInitialSize());        druidDataSource.setMinIdle(druidDataSourceProperties.getMinIdle());        druidDataSource.setMaxActive(druidDataSourceProperties.getMaxActive());        druidDataSource.setMaxWait(druidDataSourceProperties.getMaxWait());        druidDataSource.setTimeBetweenEvictionRunsMillis(            druidDataSourceProperties.getTimeBetweenEvictionRunsMillis());        druidDataSource.setMinEvictableIdleTimeMillis(            druidDataSourceProperties.getMinEvictableIdleTimeMillis());        druidDataSource.setTestOnBorrow(druidDataSourceProperties.isTestOnBorrow());        druidDataSource.setTestOnReturn(druidDataSourceProperties.isTestOnReturn());        druidDataSource.setTestWhileIdle(druidDataSourceProperties.isTestWhileIdle());        druidDataSource.setKeepAlive(druidDataSourceProperties.isKeepAlive());        druidDataSource.setRemoveAbandoned(druidDataSourceProperties.isRemoveAbandoned());        druidDataSource.setRemoveAbandonedTimeout(            druidDataSourceProperties.getRemoveAbandonedTimeout());        druidDataSource.setLogAbandoned(druidDataSourceProperties.isLogAbandoned());        druidDataSource.setPoolPreparedStatements(            druidDataSourceProperties.isPoolPreparedStatements());        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(            druidDataSourceProperties.getMaxPoolPreparedStatementPerConnectionSize());        try &#123;            druidDataSource.setFilters(druidDataSourceProperties.getFilters());            druidDataSource.init();        &#125; catch (SQLException e) &#123;            logger.error(&quot;数据源初始化失败&quot;, e);        &#125;        return druidDataSource;    &#125;&#125;</code></pre><p>OK!重新启动测试一下刚才的接口。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> MyBatis </tag>
            
            <tag> Druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(二) 整合 log4j2</title>
      <link href="20180629.html"/>
      <url>20180629.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="1-log4j2-简介"><a href="#1-log4j2-简介" class="headerlink" title="1. log4j2 简介"></a>1. log4j2 简介</h2><p>良好的日志输出能够在遇到问题的时候很快的定位到出现问题的地方。所以我们首先把log4j集成进去。</p><p>我们使用的是log4j2，在使用方面与log4j基本上没什么区别，比较大的区别是<strong>log4j2不再支持properties配置文件，支持xml、json格式的文件</strong></p><h2 id="2-添加log4j2-依赖"><a href="#2-添加log4j2-依赖" class="headerlink" title="2. 添加log4j2 依赖"></a>2. 添加log4j2 依赖</h2><p>在pom文件中添加依赖：</p><pre><code class="xml">&lt;!-- 从parent项目中出去logging这个包，因为我们使用的是log4j2 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入log4j2支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;    &lt;version&gt;1.7.24&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;</code></pre><h2 id="3-添加-log4j2-的配置文件"><a href="#3-添加-log4j2-的配置文件" class="headerlink" title="3. 添加 log4j2 的配置文件"></a>3. 添加 log4j2 的配置文件</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--    status : 这个用于设置log4j2自身内部的信息输出,可以不设置,    当设置成trace时,会看到log4j2内部各种详细输出    monitorInterval : Log4j能够自动检测修改配置文件和重新配置本身,     设置间隔秒数。此处表示每隔600秒重读一次配置文件--&gt;&lt;Configuration status=&quot;OFF&quot; monitorInterval=&quot;600&quot;&gt;    &lt;!--日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL--&gt;    &lt;!--如果设置为WARN，则低于WARN的信息都不会输出--&gt;    &lt;Properties&gt;        &lt;!-- 配置日志文件输出目录,此处为项目根目录下的logs文件夹 --&gt;        &lt;Property name=&quot;LOG_HOME&quot;&gt;D:\sysLogs\learning&lt;/Property&gt;        &lt;property name=&quot;FILE_NAME&quot;&gt;learningSpringBoot&lt;/property&gt;    &lt;/Properties&gt;    &lt;Appenders&gt;        &lt;!--这个输出控制台的配置--&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!--控制台只输出level及其以上级别的信息（onMatch），            其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;INFO&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;!--日志输出的格式--&gt;            &lt;!--%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n--&gt;            &lt;PatternLayout pattern=&quot;|%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;|%5p|%5t|%4c:%L|%m%n&quot;/&gt;        &lt;/Console&gt;        &lt;RollingRandomAccessFile name=&quot;LEARNING&quot; fileName=&quot;$&#123;LOG_HOME&#125;/$&#123;FILE_NAME&#125;.log&quot;                                 filePattern=&quot;$&#123;LOG_HOME&#125;/backup/$&#123;FILE_NAME&#125;_%d&#123;yyyy-MM-dd&#125;_%i.log&quot;&gt;            &lt;!--%d&#123;yyyy-MM-dd &#39;at&#39; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n--&gt;            &lt;PatternLayout pattern=&quot;|%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;|%5p|%5t|%4c:%L|%m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;20MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;10&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;    &lt;/Appenders&gt;    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;    &lt;Loggers&gt;        &lt;Logger name=&quot;com.zdran.springboot&quot; level=&quot;INFO&quot; additivity=&quot;true&quot;&gt;            &lt;AppenderRef ref=&quot;LEARNING&quot;/&gt;        &lt;/Logger&gt;        &lt;Logger name=&quot;org.springframework&quot; level=&quot;INFO&quot; additivity=&quot;true&quot;&gt;            &lt;AppenderRef ref=&quot;LEARNING&quot;/&gt;        &lt;/Logger&gt;        &lt;Logger name=&quot;org.apache&quot; level=&quot;INFO&quot; additivity=&quot;true&quot;&gt;            &lt;AppenderRef ref=&quot;LEARNING&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;INFO&quot;&gt;            &lt;Appender-Ref ref=&quot;Console&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;</code></pre><p>这么详细的注释就不需要再解释了吧。。。</p><p>其中<code>&lt;Property name=&quot;LOG_HOME&quot;&gt;D:\sysLogs\learning&lt;/Property&gt;</code> 还有另外一种设置，我们可以在xml里配置一个占位符，然后可以在命令行启动的时候以参数额形式指定log的目录。可以像下面这样配置：</p><pre><code class="textile">&lt;Property name=&quot;LOG_HOME&quot;&gt;$&#123;sys:log4j.path&#125;/learning&lt;/Property&gt;启动命令 java -jar xxx.jar -log4j.path=D:\sysLogs\learning</code></pre><p>如果你使用了这种配置在启动的时候会报一个</p><pre><code>ERROR StatusLogger Cannot access RandomAccessFile java.io.IOException: 文件名、目录名或卷标语法不正确。 java.io.IOException: 文件名、目录名或卷标语法不正确。</code></pre><p>这个错误是因为占位符不是有效的路径导致的，可以通过下面的方法配置：</p><div align="center">    ![Edit Configurations...](/images/2001.jpg)</div>在 VM options 里配置一下参数 ```-Dlog4j.path=D:\sysLogs```。<div align="center">    ![VM options](/images/2002.jpg)</div>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Log4j2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记(一) hello world</title>
      <link href="20180628.html"/>
      <url>20180628.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/learning">Spring Boot 学习笔记 源码地址</a></li><li><a href="https://zdran.com/20180628.html">Spring Boot 学习笔记(一) hello world</a></li><li><a href="https://zdran.com/20180629.html">Spring Boot 学习笔记(二) 整合 log4j2</a></li><li><a href="https://zdran.com/20180703.html">Spring Boot 学习笔记(三) 整合 MyBatis + Druid</a></li><li><a href="https://zdran.com/20180706.html">Spring Boot 学习笔记(四) 整合 Druid 监控</a></li><li><a href="https://zdran.com/20180718.html">Spring Boot 学习笔记(五) 整合 静态资源</a></li><li><a href="https://zdran.com/20180725.html">Spring Boot 学习笔记(六) 整合 RESTful 参数传递</a></li><li><a href="https://zdran.com/20180730.html">Spring Boot 学习笔记(七) 整合 Swagger2</a></li><li><a href="https://zdran.com/20180809.html">Spring Boot 学习笔记(八) 整合 Filter</a></li><li><a href="https://zdran.com/20180830.html">Spring Boot 学习笔记(九) 整合 多环境配置</a></li><li><a href="https://zdran.com/20180904.html">Spring Boot 学习笔记(十) Redis集群搭建</a></li><li><a href="https://zdran.com/20180911.html">Spring Boot 学习笔记(十一) 整合 Redis</a></li><li><a href="https://zdran.com/20181016.html">Spring Boot 学习笔记(十二) 整合 定时任务</a></li><li><a href="https://zdran.com/20190418.html">Spring Boot 学习笔记(十三) 整合 AOP</a></li><li><a href="https://zdran.com/20190909.html">Spring Boot 学习笔记(十四) 整合 Guava</a></li></ul><hr><h2 id="0-环境说明"><a href="#0-环境说明" class="headerlink" title="0. 环境说明"></a>0. 环境说明</h2><ul><li>Windows 7</li><li>IDEA 2017.2.7</li><li>JDK 1.8</li><li>Maven 3.2.2</li><li>Spring Boot 2.0</li><li>Git 2.13.2</li><li>编码格式：UTF-8</li></ul><h2 id="1-Spring-Boot-简介"><a href="#1-Spring-Boot-简介" class="headerlink" title="1. Spring Boot 简介"></a>1. Spring Boot 简介</h2><p>Spring Boot 是一个轻量级框架，可以完成基于 Spring 的应用程序的大部分配置工作。</p><p>当我们使用传统的Spring MVC 框架做开发的时候 ，往往需要大量的xml文件来做各种配置，比如包的扫描、bean的注入、静态资源的路径、mybaits的整合，视图解析器的配置，消息转换器的配置。稍有不慎就会导致各种问题。</p><p>而 Spring Boot的主要目标就是简化配置。它使用 “约定大于配置” 的理念，可以让你不再关心繁琐的配置，可以很简单的搭建一个新的项目。</p><h2 id="2-创建一个Spring-Boot-项目"><a href="#2-创建一个Spring-Boot-项目" class="headerlink" title="2. 创建一个Spring Boot 项目"></a>2. 创建一个Spring Boot 项目</h2><p>打开 IDEA, File -&gt; New -&gt; Project..</p><p><img src="/images/001.jpg" alt="Spring Initializr 创建项目"></p><p>选择 Spring Initializr 配置好 JDK，然后 Next：</p><p><img src="/images/002.jpg" alt="配置包名"></p><p>配置好包名，Next：</p><p><img src="/images/003.jpg" alt="配置项目">  </p><p>这里我们选择 Web，并勾选上 Web，新建一个 Web项目。Next：</p><p><img src="/images/004.jpg" alt="配置项目"></p><p>选择新建项目的本地路径。 Finish：</p><p><img src="/images/005.jpg" alt="配置项目"></p><p>上面就是我们创建好的一个标准的 Sprint Boot Web项目。</p><p>简单说一下目录结构：</p><ul><li><p>SpringbootApplication：项目的启动类。有一个 main() 方法，只要运行这个main方法就可以启动项目，不需要依赖额外的tomcat。</p></li><li><p>application.properties：项目的配置文件。（PS：后期我们会修改为 yaml文件）</p></li><li><p>pom.xml：maven依赖文件</p></li></ul><h2 id="3-hello-world"><a href="#3-hello-world" class="headerlink" title="3. hello world"></a>3. hello world</h2><p>先写个 Controller 测试一下项目。</p><p>创建 <code>HelloWorldController</code>类，代码如下：</p><pre><code class="java">package com.zdran.springboot.helloworld;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * 测试项目类 * Create by zdRan on 2018/6/28 * * @author cm.zdran@gmail.com */@RestControllerpublic class HelloWorldController &#123;    /**     * 测试项目     *     * @return 字符串     */    @GetMapping(&quot;/helloWorld&quot;)    public String helloWorld() &#123;        return &quot;hello world,I am Spring Boot&quot;;    &#125;&#125;</code></pre><p>右击运行 SpringbootApplication 里的 mian() 方法：<br><img src="/images/006.jpg" alt="启动项目"></p><p>控制台出现下面的日志就说明启动成功了，端口号是8080：</p><p><img src="/images/007.jpg" alt="启动日志"></p><p>在 浏览器访问下 <code>http://localhost:8080/helloWorld</code>，你就能看到效果了。</p><h2 id="4-自定义配置"><a href="#4-自定义配置" class="headerlink" title="4. 自定义配置"></a>4. 自定义配置</h2><p>我们可以通过配置文件配置我们的url路径、端口号等。</p><p>首先：<strong>修改properties文件为yaml文件</strong>，直接重命名就好。右击 application.properties 文件 选择 Refactor -&gt; Rename… 修改为 application.yml</p><p>在 application.yml里添加下面的内容：</p><pre><code class="yaml">server:  port: 9090  servlet:    context-path: /learning</code></pre><p>注意：<strong>yaml文件的配置是根据缩进来的，所以一定要注意缩进是否正确</strong></p><p>现在我们的访问地址就变成了 <code>http://localhost:9090/learning/helloWorld</code> 了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 整合 PageHelper</title>
      <link href="20180627.html"/>
      <url>20180627.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h2><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;        &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p><strong>最好是用最新版本</strong></p><h2 id="2-注入-PageHelper"><a href="#2-注入-PageHelper" class="headerlink" title="2. 注入 PageHelper"></a>2. 注入 PageHelper</h2><p>创建 配置类</p><pre><code>import com.github.pagehelper.PageHelper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Properties;/** * 分页工具配置 * Create by ranzd on 2018/6/27 * * @author cm.zdran@gmail.com */@Configurationpublic class PageHelperConfiguration &#123;    @Bean    public PageHelper pageHelper() &#123;        PageHelper pageHelper = new PageHelper();        Properties properties = new Properties();        properties.setProperty(&quot;offsetAsPageNum&quot;,&quot;true&quot;);        properties.setProperty(&quot;rowBoundsWithCount&quot;,&quot;true&quot;);        properties.setProperty(&quot;reasonable&quot;,&quot;true&quot;);        pageHelper.setProperties(properties);        return pageHelper;    &#125;&#125;</code></pre><p>参数说明：</p><ul><li><p><code>offsetAsPageNum</code>：</p><p>  默认值为 <code>false</code>，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 <code>true</code> 时，会将 RowBounds 中的 <code>offset</code> 参数当成 <code>pageNum</code> 使用，可以用页码和页面大小两个参数进行分页。</p></li><li><p><code>rowBoundsWithCount</code>：</p><p>  默认值为<code>false</code>，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为<code>true</code>时，使用 RowBounds 分页会进行 count 查询。</p></li><li><p><code>pageSizeZero</code>：</p><p>  默认值为 <code>false</code>，当该参数设置为 <code>true</code> 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。</p></li><li><p><code>reasonable</code>：</p><p>  分页合理化参数，默认值为<code>false</code>。当该参数设置为 <code>true</code> 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认<code>false</code> 时，直接根据参数进行查询。</p></li><li><p><code>params</code>：</p><p>  为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置<code>pageNum,pageSize,count,pageSizeZero,reasonable</code>，不配置映射的用默认值， 默认值为<code>pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero</code>。</p></li><li><p><code>supportMethodsArguments</code>：</p><p>  支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。</p></li><li><p><code>autoRuntimeDialect</code>：</p><p>  默认值为 <code>false</code>。设置为 <code>true</code> 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。</p></li><li><p><code>closeConn</code>：</p><p>  默认值为 <code>true</code>。当使用运行时动态数据源或没有设置 <code>helperDialect</code> 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认<code>true</code>关闭，设置为 <code>false</code>后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。</p></li><li><p><code>helperDialect</code>:</p><p>  分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。<br>  你可以配置<code>helperDialect</code>属性来指定分页插件使用哪种方言。</p><p>  配置时，可以使用下面的缩写值：</p><p>  oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby</p><p>  特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用 SqlServer2005 的方式进行分页。<br>  你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。</p></li></ul><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><p>下标从 1 开始，仅对之后的第一条语句生效。</p><pre><code>    OrderExample example = new OrderExample();    example.or().andLoginidEqualTo(&quot;usernem&quot;);    PageHelper.startPage(1, 5);    List&lt;Order&gt; result = orderMapper.selectByExample(example);</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> PageHelper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下 搭建 Flutter 环境</title>
      <link href="20180625.html"/>
      <url>20180625.html</url>
      
        <content type="html"><![CDATA[<h2 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h2><ul><li>Widnwos 7 64位</li><li>IntelliJ IDEA 2017.2.6</li><li>Java 1.8</li><li>Gradle 4.8.1</li><li>Git</li><li>Android SDK</li></ul><h2 id="1-通过-IDEA-下载-Android-SDK"><a href="#1-通过-IDEA-下载-Android-SDK" class="headerlink" title="1. 通过 IDEA 下载 Android SDK"></a>1. 通过 IDEA 下载 Android SDK</h2><pre><code>File | Settings | Appearance Behavior | System Settings | Android SDK</code></pre><p>记得要下载一个Android系统镜像</p><p>配置 AdnroidSDK的环境变量</p><pre><code>ANDROID_HOME=D:\AndroidSDK这里的 D:\AndroidSDK 要换成你自己的本地路径</code></pre><h2 id="2-下载-Flutter-SDK"><a href="#2-下载-Flutter-SDK" class="headerlink" title="2. 下载 Flutter SDK"></a>2. 下载 Flutter SDK</h2><p>配置环境变量：</p><pre><code>PUB_HOSTED_URL=https://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</code></pre><p>使用git下载 flutter</p><pre><code>git clone -b beta https://github.com/flutter/flutter.git</code></pre><p>配置 Flutter的环境变量,在path环境变量后面直接添加flutter的路径就可以</p><p>检查一下flutter安装情况,在命令行执行 <code>flutter doctor</code></p><pre><code>flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.5.1, on Microsoft Windows [Version 6.1.7601], locale zh-CN)[√] Android toolchain - develop for Android devices (Android SDK 28.0.0-rc2)[X] Android Studio (not installed)[√] IntelliJ IDEA Ultimate Edition (version 2017.2)[!] Connected devices    ! No devices available! Doctor found issues in 2 categories.出现上面的结果就说明成功了。</code></pre><p>如果你出现了下面的这种结果：</p><pre><code>[✗] Android toolchain - develop for Android devices    ✗ Unable to locate Android SDK.      Install Android Studio from: https://developer.android.com/studio/index.html      On first launch it will assist you in installing the Android SDK components.      (or visit https://flutter.io/setup/#android-setup for detailed instructions).      If Android SDK has been installed to a custom location, set $ANDROID_HOME to that location.</code></pre><p>应该是本地没有Android SDK，或者没有配置 <code>$ANDROID_HOME</code> 的环境变量</p><h2 id="3-配置-IDEA"><a href="#3-配置-IDEA" class="headerlink" title="3. 配置 IDEA"></a>3. 配置 IDEA</h2><p>安装 Dart插件、 Flutter插件。安装后需要重启。</p><p><strong>注意：最好使用管理员权限打开IDEA，否则后面会出现一系列的问题</strong></p><p>创建一个 flutter项目。创建一个Android模拟器。</p><p>如果这个时候你很幸运的可以运行，那么就不用往下看了。</p><p>到这里之后，我明明创建了一个android模拟器，但是，点击运行的时候一直提示</p><pre><code>No connected devices found; please connect a device, or see flutter.io/setup for getting started instructions.</code></pre><p><strong>使用管理员权限打开就没问题了！</strong></p><h2 id="4-Gradle-的坑"><a href="#4-Gradle-的坑" class="headerlink" title="4. Gradle 的坑"></a>4. Gradle 的坑</h2><p>能够显示模拟器了，点运行的时候会一直停在 Initializing gradle 的地方。</p><pre><code>Launching lib\main.dart on Android SDK built for x86 64 in debug mode...Initializing gradle...</code></pre><p>检查一下 Gradle的环境变量。 如果没有就需要配置一下</p><pre><code>GRADLE_HOME=D:\tools\gradle-4.8.1追加 path 环境变量 ;%GRADLE_HOME%\bin</code></pre><p><strong>用管理员权限打开IDEA</strong></p><p>如果还不行, <strong>用IDEA的Terminal执行下面的命令</strong></p><pre><code>cd androidgradlew下面是运行时的结果：E:\workspace\hello_flutter&gt;cd androidE:\workspace\hello_flutter\android&gt;gradlew&gt; Configure project :appFile C:\Users\unicom\.android\repositories.cfg could not be loaded.Checking the license for package Android SDK Platform 27 in D:\AndroidSDK\licensesLicense for package Android SDK Platform 27 accepted.Preparing &quot;Install Android SDK Platform 27 (revision: 3)&quot;.&quot;Install Android SDK Platform 27 (revision: 3)&quot; ready.Installing Android SDK Platform 27 in D:\AndroidSDK\platforms\android-27&quot;Install Android SDK Platform 27 (revision: 3)&quot; complete.&quot;Install Android SDK Platform 27 (revision: 3)&quot; finished.&gt; Task :helpWelcome to Gradle 4.1.To run a build, run gradlew &lt;task&gt; ...To see a list of available tasks, run gradlew tasksTo see a list of command-line options, run gradlew --helpTo see more detail about a task, run gradlew help --task &lt;task&gt;BUILD SUCCESSFUL in 1m 0s1 actionable task: 1 executedE:\workspace\hello_flutter\android&gt;flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.5.1, on Microsoft Windows [Version 6.1.7601], locale zh-CN)[√] Android toolchain - develop for Android devices (Android SDK 28.0.0-rc2)[X] Android Studio (not installed)[√] IntelliJ IDEA Ultimate Edition (version 2017.2)[!] Connected devices    ! No devices available! Doctor found issues in 2 categories.</code></pre><p>再次点击运行。我的成功的在模拟器上运行了。</p><p>如果，还是不能运行：<strong>追加CLASS_PATH 环境变量：;%GRADLE_HOME%\lib</strong></p><hr><p>PS:不得不吐糟一下flutter对Windows用户太不友好了。</p><p>学习一种新的技术，如果遇到问题 Github 上的 <a href="https://github.com/flutter/flutter/issues">issues</a> 区，是最好的去处！！</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> IDEA </tag>
            
            <tag> Gradle </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外网访问Ubuntu下的Tomcat</title>
      <link href="20180614.html"/>
      <url>20180614.html</url>
      
        <content type="html"><![CDATA[<p>搞了两天终于可以了。需要修改三处地方，就可以实现外网访问了。</p><p><strong>注意：需要保证你的服务器不是通过路由器连的网络，如果是的话需要对路由器做转发配置。</strong></p><h2 id="1-修改tomcat目录下的-conf-server-xml文件"><a href="#1-修改tomcat目录下的-conf-server-xml文件" class="headerlink" title="1. 修改tomcat目录下的/conf/server.xml文件"></a>1. 修改tomcat目录下的/conf/server.xml文件</h2><pre><code>    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;</code></pre><p>将port字段修改为一个开放端口，你也可以改成80，这样在访问时就不用加端口号了，但是要记得开放80端口。这里我没有做修改。</p><p><strong>一定要确保该端口是开放的。</strong></p><h1 id="2-修改tomcat-conf-server-xml文件"><a href="#2-修改tomcat-conf-server-xml文件" class="headerlink" title="2. 修改tomcat/conf/server.xml文件"></a>2. 修改tomcat/conf/server.xml文件</h1><pre><code>  &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;  &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</code></pre><p>将localhost改为你的IP地址，ubuntu下可以使用ifconfig </p><p><strong>如果你的IP是路由器分配的话，需要对路由器做转发配置</strong></p><h1 id="3-最重要的一点！"><a href="#3-最重要的一点！" class="headerlink" title="3.最重要的一点！"></a>3.最重要的一点！</h1><p>百度到的大部分答案基本上到上面一步就结束了。如果你也这么幸运的成功了的话，这一步就没必要了。不过我的是没有成功。去stacoverflow上搜了一下。不成功的原因说是因为JVM没有监听IPv4的地址，所以无法访问。所以需要再修改下面两处。</p><p>修改tomcat目录下的/bin/catalina.sh文件和startup.sh。添加下面一句。</p><pre><code>JAVA_OPTS= $JAVA_OPTS -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv4Addresses</code></pre><p>我的加上这两句已经可以访问了 </p><p><strong>如果你的服务器系统是windows的话需要修改.bat的这两个文件</strong></p><h1 id="4-如果还是不能访问"><a href="#4-如果还是不能访问" class="headerlink" title="4. 如果还是不能访问"></a>4. 如果还是不能访问</h1><p>如果上面的你都配置好了，而且还不能访问的话，恰好你的服务器系统是Ubuntu的话，可以尝试下面的方法。<br>安装authbind。</p><pre><code>apt-get install authbind</code></pre><p>修改/etc/default/tomcat7文件。</p><p>修改为</p><pre><code>AUTHBIND=yes</code></pre><p>重启后再不能访问的话，就试试你能不能上网，或者是不是用了路由器而且没有做转发配置，或者是端口没有开放。</p><h2 id="阿里云ubuntu镜像80端口无法访问"><a href="#阿里云ubuntu镜像80端口无法访问" class="headerlink" title="阿里云ubuntu镜像80端口无法访问"></a>阿里云ubuntu镜像80端口无法访问</h2><p>阿里云服务器的ubuntu镜像默认情况是只有root用户才能访问1024以下的端口，所以如果这些都配置好了还不能访问的话，建议你用root用户启动tomcat，或者更改端口。再(我)或(不)者(会)添加路由规则将80端口转发到其他端口</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 音乐播放器-带seekBar滑动</title>
      <link href="20180601.html"/>
      <url>20180601.html</url>
      
        <content type="html"><![CDATA[<h2 id="XML布局文件"><a href="#XML布局文件" class="headerlink" title="XML布局文件"></a>XML布局文件</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;fill_parent&quot;    android:layout_height=&quot;fill_parent&quot;    &gt;&lt;Button android:id=&quot;@+id/play&quot;    android:layout_width=&quot;fill_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;播放&quot;/&gt;&lt;Button android:id=&quot;@+id/pause&quot;    android:layout_width=&quot;fill_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;暂停&quot;/&gt;&lt;SeekBar android:id=&quot;@+id/sb&quot;    android:layout_width=&quot;fill_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:max=&quot;100&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="JAVA代码"><a href="#JAVA代码" class="headerlink" title="JAVA代码"></a>JAVA代码</h2><pre><code>package com.pocketdigi;import android.app.Activity;import android.media.MediaPlayer;import android.net.Uri;import android.os.Bundle;import android.os.Handler;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.SeekBar;import android.widget.SeekBar.OnSeekBarChangeListener;public class main extends Activity &#123;    /** Called when the activity is first created. */    Button play,pause;    MediaPlayer mp;    SeekBar sb;    Handler handler=new Handler();    int Duration;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        play=(Button)findViewById(R.id.play);        pause=(Button)findViewById(R.id.pause);        sb=(SeekBar)findViewById(R.id.sb);        //找到相应View        mp =MediaPlayer.create(this,Uri.parse(&quot;/sdcard/徐若瑄-爱笑的眼睛.mp3&quot;));        //后面的参数必须是URI形式的，所以要把相应路径转换成URI        play.setOnClickListener(playlis);        pause.setOnClickListener(pauselis);        sb.setOnSeekBarChangeListener(sbLis);           //监听器        Duration=mp.getDuration();        //音乐文件持续时间        sb.setMax(Duration);        //设置SeekBar最大值为音乐文件持续时间    &#125;    private OnClickListener playlis=new OnClickListener()&#123;        @Override        public void onClick(View v) &#123;            // TODO Auto-generated method stub            handler.post(start);            //调用handler播放        &#125;    &#125;;    Runnable start=new Runnable()&#123;        @Override        public void run() &#123;            // TODO Auto-generated method stub            mp.start();            handler.post(updatesb);            //用一个handler更新SeekBar        &#125;    &#125;;    Runnable updatesb =new Runnable()&#123;        @Override        public void run() &#123;            // TODO Auto-generated method stub            sb.setProgress(mp.getCurrentPosition());            handler.postDelayed(updatesb, 1000);            //每秒钟更新一次        &#125;    &#125;;    private OnClickListener pauselis=new OnClickListener()&#123;        @Override        public void onClick(View v) &#123;            // TODO Auto-generated method stub            mp.pause();                    //暂停        &#125;    &#125;;    private OnSeekBarChangeListener sbLis=new OnSeekBarChangeListener()&#123;        @Override        public void onProgressChanged(SeekBar seekBar, int progress,                boolean fromUser) &#123;            // TODO Auto-generated method stub        &#125;        @Override        public void onStartTrackingTouch(SeekBar seekBar) &#123;            // TODO Auto-generated method stub        &#125;        @Override        public void onStopTrackingTouch(SeekBar seekBar) &#123;            // TODO Auto-generated method stub            mp.seekTo(sb.getProgress());            //SeekBar确定位置后，跳到指定位置        &#125;    &#125;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 学习笔记</title>
      <link href="20180529.html"/>
      <url>20180529.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>数据库中的表：一行叫一条记录。每一列叫一个属性，或一个字段。<br>主键：表中的某个特殊字段，具有唯一的确定的值，可以根据该字段唯一的确定一条记录<br>外键：表中的某个字段的值为另一张表（也可以是自身）中的某个字段的值。</p><h2 id="2-MySQL-的数据类型"><a href="#2-MySQL-的数据类型" class="headerlink" title="2 MySQL 的数据类型"></a>2 MySQL 的数据类型</h2><h3 id="2-1-数值"><a href="#2-1-数值" class="headerlink" title="2.1 数值"></a>2.1 数值</h3><ol><li>TINYINT 小整型</li><li>INT/INTEGER 整型</li><li>BIGINT 长整型</li><li>FLOAT 小数</li><li>DOUBLIE 双精度小数</li></ol><h3 id="2-2-日期"><a href="#2-2-日期" class="headerlink" title="2.2 日期"></a>2.2 日期</h3><ol><li>DATE  YYYY-MM-DD</li><li>TIME  HH:MM:SS</li><li>YEAT  YYYY</li><li>DATETIME 混合</li><li>TIMESTAMP 高精度</li></ol><h3 id="2-3-字符串"><a href="#2-3-字符串" class="headerlink" title="2.3 字符串"></a>2.3 字符串</h3><ol><li>CHAR 定长字符串</li><li>VARCHAR 不定长</li><li>BLOB 二进制文件</li><li>LONGBLOB 长二进制文件</li><li>TEXT 长文本数据</li><li>LONGTEXT 长文本数据</li></ol><p><strong>注：以上仅总结了常用类型，并不是所有类型</strong></p><h2 id="3-SQL语句"><a href="#3-SQL语句" class="headerlink" title="3 SQL语句"></a>3 SQL语句</h2><h3 id="3-1-数据库的创建"><a href="#3-1-数据库的创建" class="headerlink" title="3.1 数据库的创建"></a>3.1 数据库的创建</h3><pre><code>CREATE DATABASE 数据库名 [参数]</code></pre><p>例如创建一个名为test的数据库，设置字符集为utf-8</p><pre><code>CREATE DATABASE test CHARACTER SET utf8;</code></pre><p>出现下面的内容即说明创建成功。</p><pre><code>Query OK, 0 rows affected (0.00 sec)</code></pre><p>你可以使用下面的语句查看新创建的数据库</p><pre><code>SHOW DATABASES;</code></pre><p>选择需要操作的数据库</p><pre><code>USE test;</code></pre><p>执行完上面的语句后出现Database changed，<br>你所有的操作都将在test数据库中进行。</p><h3 id="3-2-创建表"><a href="#3-2-创建表" class="headerlink" title="3.2 创建表"></a>3.2 创建表</h3><pre><code>CREATE TABLE 表名 (    列名 列数据属性 [约束]，    列名 列数据属性，    ... ...);</code></pre><p>例如创建一个users表id是主键，自增长。<br>PRIMARY KEY：约束 主键约束<br>AUTO_INCREMENT：约束 自增长</p><pre><code>CREATE TABLE users(id INTEGER PRIMARY KEY AUTO_INCREMENT,account VARCHAR(50),pwd VARCHAR(50),);</code></pre><h3 id="3-3-插入数据"><a href="#3-3-插入数据" class="headerlink" title="3.3 插入数据"></a>3.3 插入数据</h3><pre><code>INSERT INTO 表名 VALUES (值1, 值2,...,NULL，...);</code></pre><p>这种插入方式一定要将所有的值都写上，如果为空的话写NULL。值与列要一一对应<br><strong>主键如果设置为自增的话写NULL</strong></p><p>也可以指定所要插入数据的列，向下面这样。</p><pre><code>INSERT INTO 表名 (列1, 列2,...) VALUES (值1, 值2,....);</code></pre><p>按回车后出现</p><pre><code>Query Ok, 1 row affected (0.05 sec) </code></pre><p>说明成功。否则请检查SQL语句。</p><p>例如向刚刚创建的users表中插入一条数据</p><pre><code>INSERT INTO users VALUES(NULL,&#39;admin&#39;,&#39;admin&#39;);</code></pre><p>第一列是id，主键自增，不需要插入。</p><h3 id="3-4-查询数据"><a href="#3-4-查询数据" class="headerlink" title="3.4 查询数据"></a>3.4 查询数据</h3><pre><code>SELECT * FROM 表名 [WHERE 条件]  [参数];</code></pre><p>例如查询users表里的所有数据的 account 列。</p><pre><code>SELECT account FROM users;</code></pre><h4 id="3-4-1-WHERE-查询"><a href="#3-4-1-WHERE-查询" class="headerlink" title="3.4.1 WHERE 查询"></a>3.4.1 WHERE 查询</h4><p>可以给FROM后面的表起一个别名。例如:</p><pre><code>SELECT tn.id,tn.account FROM tablename AS tnWHERE tn.id = 1;</code></pre><h4 id="3-4-2-WHERE-后的条件语句"><a href="#3-4-2-WHERE-后的条件语句" class="headerlink" title="3.4.2 WHERE 后的条件语句"></a>3.4.2 WHERE 后的条件语句</h4><pre><code>WHERE后面可以写多种条件语句。1. 关系语句: =,&gt;,&lt;,!=,&gt;=,&lt;=2. 逻辑语句: AND,OR,NOT3. IS NULL: 是否为空4. BETWEEN:在两者之间     WHERE u.id BETWEEN 11 AND 15;    id 在11-15之间。5. IN:在..之中    WHERE u.account IN (值1,值2,...);    查询 account 在(值1,值2,...)之中的数据5. LIKE:模糊匹配     WHERE  u.id LIKE &#39;通配符&#39;;    通配符    &#39;%&#39;:替代零个或多个字符    &#39;_&#39;:替代一个字符        WHERE u.account LIKE &#39;%A%&#39;;查询account字段中含有&#39;A&#39;的数据。     [charlist]:字符列中的任何单一字符         WHERE u.account LIKE &#39;[ASD]%&#39;; 查询以A S D 开头的数据。    [!charlist]:不在字符列中的任何单一字符        WHERE u.account LIKE &#39;[!ASD]%&#39;; 查询不以A S D 开头的数据 </code></pre><h4 id="3-4-3-聚合函数"><a href="#3-4-3-聚合函数" class="headerlink" title="3.4.3 聚合函数"></a>3.4.3 聚合函数</h4><pre><code>SELECT AVG(列名) FROM 表名</code></pre><pre><code>1. AVG(列名):返回某一列的平均值2. COUNT(列名):返回匹配指定条件的行数3. FIRST(列名):返回指定的字段中第一个记录的值。4. LAST(列名):返回指定的字段中最后一个记录的值。5. MAX(列名):返回一列中的最大值。NULL 值不包括在计算中。 6. MIN(列名):返回一列中的最小值。NULL 值不包括在计算中。7. SUM(列名):返回数值列的总数（总额）。8. UCASE(列名):把字段的值转换为大写。9. LCASE(列名):把字段的值转换为小写。 </code></pre><pre><code>10. MID(列名,开始位置，截取长度):用于从文本字段中提取字符。SELECT MID(account,1,3) as uname FROM users;</code></pre><pre><code>11. LEN(列名):返回文本字段中值的长度。12. ROUND(列名,小数位数):用于把数值字段舍入为指定的小数位数。13. CURDATE():返回当前日期。YYYY-MM-DD。14. CURTIME():返回当前时间。HH:MM:SS。15. NOW():返回当前时间。YYYY-MM-DD HH:MM:SS。16. YEAR(d)，MONTH(d),DAY(d):分别返回参数的年，月，日。17. ADDDATE(d,n):在d的时间上加n天。18. SUBDATE(d,n):在d的时间上减n天。</code></pre><pre><code>19. DATE_FORMAT(d,f):格式化时间d。%a 缩写星期名%b 缩写月名%c 月，数值%D 带有英文前缀的月中的天%d 月的天，数值(00-31)%e 月的天，数值(0-31)%f 微秒%H 小时 (00-23)%h 小时 (01-12)%I(大写的i) 小时 (01-12)%i 分钟，数值(00-59)%j 年的天 (001-366)%k 小时 (0-23)%l(小写的L) 小时 (1-12)%M 月名%m 月，数值(00-12)%p AM 或 PM%r 时间，12-小时（hh:mm:ss AM 或 PM）%S 秒(00-59)%s 秒(00-59)%T 时间, 24-小时 (hh:mm:ss)%U 周 (00-53) 星期日是一周的第一天%u 周 (00-53) 星期一是一周的第一天%V 周 (01-53) 星期日是一周的第一天，与 %X 使用%v 周 (01-53) 星期一是一周的第一天，与 %x 使用%W 星期名%w 周的天 （0=星期日, 6=星期六）%X 年，其中的星期日是周的第一天，4 位，与 %V 使用%x 年，其中的星期一是周的第一天，4 位，与 %v 使用%Y 年，4 位%y 年，2 位</code></pre><h4 id="3-4-4-分组查询"><a href="#3-4-4-分组查询" class="headerlink" title="3.4.4 分组查询"></a>3.4.4 分组查询</h4><p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p><pre><code>SELECT 列名, 聚合函数FROM 表名WHERE 条件GROUP BY 列名</code></pre><p>例如根据用户表中的role属性分组统计每组的人数</p><pre><code>SELECT role, COUNT(id)FROM usersGROUP BY role;</code></pre><h4 id="3-4-5-分组过滤"><a href="#3-4-5-分组过滤" class="headerlink" title="3.4.5 分组过滤"></a>3.4.5 分组过滤</h4><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。<br>例如根据用户表中的role属性分组统计每组的人数，查找人数大于10的role</p><pre><code>SELECT role, COUNT(id)FROM usersGROUP BY roleHAVING COUNT(id)&gt;10;</code></pre><h4 id="3-4-6-结果排序"><a href="#3-4-6-结果排序" class="headerlink" title="3.4.6 结果排序"></a>3.4.6 结果排序</h4><p>ORDER BY 语句用于根据指定的列对结果集进行排序。<br>默认为升序，降序使用关键字DESC。<br>例如根据用户表中的role属性分组统计每组的人数，按照人数降序排列</p><pre><code>SELECT role, COUNT(id) countFROM usersGROUP BY roleORDER BY count DESC;</code></pre><h3 id="3-5-更新数据"><a href="#3-5-更新数据" class="headerlink" title="3.5 更新数据"></a>3.5 更新数据</h3><pre><code>UPDATE 表名 SET 列名 = 新值 WHERE 条件</code></pre><p>WHERE的修改条件是可选的，不写的话修改表的所有数据</p><p>例如修改users表里的数据，将admin用户的密码改为root</p><pre><code>UPDATE users SET pwd = &#39;root&#39; WHERE account = &#39;admin&#39;;</code></pre><h3 id="3-6-删除数据"><a href="#3-6-删除数据" class="headerlink" title="3.6 删除数据"></a>3.6 删除数据</h3><pre><code>DELETE FROM 表名 WHERE 条件</code></pre><p>WHERE的修改条件是可选的，不写的话删除表的所有数据</p><h2 id="4-表属性的修改"><a href="#4-表属性的修改" class="headerlink" title="4 表属性的修改"></a>4 表属性的修改</h2><h3 id="4-1-表重命名"><a href="#4-1-表重命名" class="headerlink" title="4.1 表重命名"></a>4.1 表重命名</h3><pre><code>ALTER TABLE 表名 RENAME 新表名;</code></pre><h3 id="4-2-添加新的一列"><a href="#4-2-添加新的一列" class="headerlink" title="4.2 添加新的一列"></a>4.2 添加新的一列</h3><pre><code>ALTER TABLE 表名 ADD 列名 列数据类型 [AFTER 插入位置]</code></pre><p>例如在users表的pwd字段后面添加一个role字段类型是INTEGER</p><pre><code>ALTER TABLE users ADD role INTEGER AFTER pwd;</code></pre><h3 id="4-3-修改列"><a href="#4-3-修改列" class="headerlink" title="4.3 修改列"></a>4.3 修改列</h3><pre><code>ALTER TABLE 表名 CHANGE 列名称 新列名称 新数据类型;</code></pre><p>例如修改users表里的pwd字段改为password，类型是varchar(20)</p><pre><code>ALTER TABLE users CHANGE pwd password varchar(20);</code></pre><h2 id="5-完整性约束"><a href="#5-完整性约束" class="headerlink" title="5 完整性约束"></a>5 完整性约束</h2><pre><code>约束：对表中的列添加的一些限制条件。只有满足这些条件时才能数据才能插入。</code></pre><h3 id="5-1-实体完整性"><a href="#5-1-实体完整性" class="headerlink" title="5.1 实体完整性"></a>5.1 实体完整性</h3><pre><code>主键不能为空</code></pre><h3 id="5-2-参照完整性"><a href="#5-2-参照完整性" class="headerlink" title="5.2 参照完整性"></a>5.2 参照完整性</h3><pre><code>外键的值必须是某张表中存在的值，可以为空</code></pre><h3 id="5-3-用户自定义完整性"><a href="#5-3-用户自定义完整性" class="headerlink" title="5.3 用户自定义完整性"></a>5.3 用户自定义完整性</h3><pre><code>唯一性约束，某一列虽然不为主键，但是依然不能重复。</code></pre><h3 id="5-4-添加约束"><a href="#5-4-添加约束" class="headerlink" title="5.4 添加约束"></a>5.4 添加约束</h3><pre><code>ALTER TABLE 表名    ADD CONSTRAINT 约束名 约束类型(列名);</code></pre><p>例如，给users表的role列添加外键约束，引用自roles表的id列</p><pre><code>ALTER TABLE users    ADD CONSTRAINT uq_phone FOREIGN KEY (`role`)     REFERENCES `roles` (`id`);</code></pre><h3 id="5-5-常见约束类型"><a href="#5-5-常见约束类型" class="headerlink" title="5.5 常见约束类型"></a>5.5 常见约束类型</h3><pre><code>1. PRIMARY KEY: 主键 2. CHECK:限制列中的值的范围。MySQL好像不支持3. UNIQUE:唯一性约束4. NOT NULL：非空约束5. FOREIGN KEY:外键约束</code></pre><h2 id="6-范式"><a href="#6-范式" class="headerlink" title="6 范式"></a>6 范式</h2><p>函数依赖:如果A依赖B，那么当确定A值后，B值也就确定了。<br>例如，在一张表中由于主键是唯一确定且不重复的。所以，当主键的值确定了，那么其他列的值也就确定了。我们便说，其他列都依赖主键。</p><p>完全函数依赖：如果B函数依赖于A，并且对于A的任何一个真子集A1,都有 B不依赖与A1,称A对B完全函数依赖。</p><p>部分函数依赖：如果B函数依赖于A，但是B不完全函数依赖于A，称B对A部分函数依赖。<br>例如，在一张表中，有两列，一列是用户名，而另一列里某些行里记录的是用户的id，而某些行里在这一列里记录的是用户所在部门的id，那么用户名列便部分函数依赖于id列，因为存在某些行依赖于id列的子集(记录是部门id的行)。</p><p>传递函数依赖：如果A函数依赖于B，B函数依赖于C，则称A传递函数依赖于C。</p><h3 id="6-1-1NF-第一范式"><a href="#6-1-1NF-第一范式" class="headerlink" title="6.1 1NF(第一范式)"></a>6.1 1NF(第一范式)</h3><p>确保列不可分，即每一列只描述一个属性，即达到1NF</p><h3 id="6-2-2NF-第二范式"><a href="#6-2-2NF-第二范式" class="headerlink" title="6.2 2NF(第二范式)"></a>6.2 2NF(第二范式)</h3><p>在1NF的基础上消除部分函数依赖即达到2NF。即每一个非主属性(非主键列)完全函数依赖于主键。<br>例如，可以将上面部分函数依赖的例子中的表，改成两张表，一张用户表，一张部门表，所有的用户名列都完全依赖于主键。便达到2NF。</p><h3 id="6-3-3NF-第三范式"><a href="#6-3-3NF-第三范式" class="headerlink" title="6.3 3NF(第三范式)"></a>6.3 3NF(第三范式)</h3><p>在2NF的基础上消除传递函数依赖便达到3NF。即每一个非主属性(非主键列)即不部分依赖于主键，也不传递依赖于主键。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习笔记</title>
      <link href="20180524.html"/>
      <url>20180524.html</url>
      
        <content type="html"><![CDATA[<p><strong>环境声明：本人用的是ubuntu14.04的系统，所以本文内容均基于该平台</strong><br>本文是学习<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程 廖雪峰</a> 时的一些笔记。想深学习的可以查看原文。</p><h1 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网上有很多关于git的起源，简介，用途，这里就不多数了（或许是我不知道。。。）</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>sudo apt-get install git-core</code></pre><h2 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h2><p>git是分布式版本控制系统，所以每次提交时需要一个用户名，让人知道是谁提交的。<br>还需要提供一个邮箱，出了问题让别人能够联系到你。</p><pre><code>git config --global user.name &quot;zdran&quot;git config --global user.email &quot;cm.zdran@foxmail.com&quot;</code></pre><p><strong>需要注意的是，config –global 参数是指在本台计算机中的所有仓库都使用该配置当然你也可以给每个仓库都配置一个name和email</strong></p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p><strong>创建一个新的文件夹，虽然也可以用不空的文件，但是出了问题不要找我</strong><br><strong>路径不要出现空格，中文，特殊字符</strong></p><pre><code>mkdir learnGitcd learnGitgit init</code></pre><p>看到下面的显示说明你成功了</p><pre><code>Initialized empty Git repository in /home/woody/Documents/learnGit/.git/</code></pre><p>需要注意的是，成功后会多出一个.git的文件夹，在没有必须打开的情况下<br><strong>强烈不建议打开这个文件夹</strong></p><h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><p><strong>友情提示：创建的文件尽量使用utf-8的编码，Windows下的同学尽量不要使用记事本编辑，推荐sublime</strong><br>在当前文件夹下创建一个readme.txt文件，随便写点东西比如</p><pre><code>hello git</code></pre><p>然后保存</p><p>使用下面的命令可以查看当前仓库的状态</p><pre><code>git status</code></pre><p>显示结果：</p><pre><code>On branch masterInitial commitUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        readme.txt        nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre><p>意思就是说，你修改了一个文件，但是还没有提交。<br>使用下面的命令添加到仓库</p><pre><code>git add readme.txt</code></pre><p>注意这仅仅是添加到仓库了，告诉git，这个文件是需要版本控制的。但是还没有提交。<br>使用下面的命令提交到仓库</p><pre><code>git commit -m &quot;创建readme.txt文件&quot;</code></pre><p>-m 的参数是对这次提交的一次说明<br>显示结果：</p><pre><code>[master (root-commit) 3eb5f77] 创建readme.txt文件 1 file changed, 1 insertion(+)  create mode 100644 readme.txt</code></pre><p><strong>注意：虽然-m参数是可选的额，但是强烈建议你添加上，因为默认的配置是不添加-m参数是没有办法提交的</strong></p><h2 id="时光倒流-版本回退"><a href="#时光倒流-版本回退" class="headerlink" title="时光倒流(版本回退)"></a>时光倒流(版本回退)</h2><p>我想大部分同学使用git的最初的动力就是因为这个功能吧。</p><p>现在我们对readme文件进行修改，再随便添加些东西，然后readme内容就变成下面这样</p><pre><code>hello githello git 2.0</code></pre><p>然后再次add commit。</p><p>现在我们的仓库里有两个版本了，我们可以用下面的命令查看git的提交历史</p><pre><code>git log</code></pre><p>显示结果</p><pre><code>commit b5934a2d9f80d257ca50b9b80a4b31d5bb9fe03cAuthor: = &lt;woody@gmail.com&gt;Date:   Sun Jan 22 16:27:59 2017 +0800    第二次提交commit 3eb5f7721cb86c617faf0d2ad13a5cee9d1a3764Author: = &lt;woody@gmail.com&gt;Date:   Sun Jan 22 16:16:10 2017 +0800创建readme.txt文件</code></pre><p><strong>注意：commit字段是自动生成的，所以你的结果一定与我的不一样，以你的为准</strong></p><p>好了，下面下面我们将readme.txt回退到最开始创建的状态。git使用HEAD表示当前的版本，就是最新的版本。<br>上一个版本是HEAD^,再上一个版本是HEAD^^,上一百个版本是HEAD～100(当然你也可以打100个^)。<br>使用下面的命令回退到指定版本</p><pre><code>git reset --hard HEAD^HEAD is now at 3eb5f77 创建readme.txt文件</code></pre><p>看看内容改了没有。<br>现在我们再查看下log，结果如下：</p><pre><code>commit 3eb5f7721cb86c617faf0d2ad13a5cee9d1a3764Author: = &lt;coder.0012ff7c@gmail.com&gt;Date:   Sun Jan 22 16:16:10 2017 +0800    创建readme.txt文件</code></pre><p>好了，时光倒流成功！但是悲哀的发现我们回不到未来了。还是有办法的，–hard 参数支持commit值。<br>就是说你可以在–hard后面跟一个commit值，就能跳到那个版本。<br>执行下面的代码</p><pre><code>git reset --hard b5934aHEAD is now at b5934a2 第二次提交</code></pre><p>不用将所有的字符都写上，只要能区分出不同就好，git会自动去匹配</p><p>但是万一找不到commit值呢，没关系。使用下面的命令可以查看所有的历史</p><pre><code>git reflog</code></pre><p>显示结果：</p><pre><code>b5934a2 HEAD@&#123;0&#125;: reset: moving to b5934a3eb5f77 HEAD@&#123;1&#125;: reset: moving to HEAD^b5934a2 HEAD@&#123;2&#125;: commit: 第二次提交3eb5f77 HEAD@&#123;3&#125;: commit (initial): 创建readme.txt文件</code></pre><p>最前面那串字符就是。好了。搞定！</p><h2 id="工作区，暂存区，版本库"><a href="#工作区，暂存区，版本库" class="headerlink" title="工作区，暂存区，版本库"></a>工作区，暂存区，版本库</h2><p>工作区：就是指当前的目录，比如我们创建的learnGit目录<br>暂存区：通过git add 命令将文件添加到暂存区。<br>版本库：就是指创建仓库时自动生成的那个.git目录，也是强烈建议不要乱动的目录。<br>git中的文件必须先添加到暂存区，然后才能添加到版本库。</p><p>重新创建一个文件Hello.java，随便写点内容比如</p><pre><code>hello java</code></pre><p>然后再修改下readme文件，添加一行</p><pre><code>添加 hello.java 文件 </code></pre><p>然后查看下仓库状态</p><pre><code>git status</code></pre><p>显示结果：</p><pre><code>On branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)      modified:   readme.txt      Untracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)      Hello.javano changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>说明readme.txt被修改了，而hello.java还没有被添加到仓库。<br>然后我们将这两个文件添加到暂存区</p><pre><code>git add readme.txtgit add Hello.java</code></pre><p>你也可以使用下面的命令将当前文件夹下的所有文件都添加到暂存区<br>    git add –all</p><p>再查看下状态显示结果：</p><pre><code>On branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)      new file:   Hello.java      modified:   readme.txt</code></pre><p>然后再用commit命令添加到版本库<br>    git commit -m “添加Hello.java文件”<br>再查看下状态显示结果为</p><pre><code>On branch masternothing to commit, working tree clean</code></pre><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><h3 id="仅仅是修改了工作区，并没有add到暂存区"><a href="#仅仅是修改了工作区，并没有add到暂存区" class="headerlink" title="仅仅是修改了工作区，并没有add到暂存区"></a>仅仅是修改了工作区，并没有add到暂存区</h3><p>我们对Hello.java做一些修改，如下：</p><pre><code>public class Hello&#123;    public static void main(String[] args)&#123;    &#125;&#125;</code></pre><p>如果这个时候我们需要回到上一个版本，当然，你可以手动的修改Hello.java文件。<br>但是要是万一你哪里再记错了，就尴尬了。<br>查看一下状态</p><pre><code>git status</code></pre><pre><code>On branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   Hello.javano changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>git告诉你说，使用 git checkout – <file>… 可以放弃当前工作区的修改。试一下，</p><pre><code>git checkout Hello.java </code></pre><p>查看下Hello.java 文件，是不是恢复了。</p><h3 id="不仅仅修改了工作区，而且还add到了暂存区。"><a href="#不仅仅修改了工作区，而且还add到了暂存区。" class="headerlink" title="不仅仅修改了工作区，而且还add到了暂存区。"></a>不仅仅修改了工作区，而且还add到了暂存区。</h3><p>我们对Hello.java再次做一些修改，如下：</p><pre><code>public class Hello&#123;    public static void main(String[] args)&#123;    &#125;&#125;</code></pre><p>然后add到暂存区</p><pre><code>git add Hello.java</code></pre><p>查看一下状态</p><pre><code>On branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   Hello.java</code></pre><p>git告诉你说，使用 git reset HEAD <file>… 可以撤销缓存。然后我们尝试一下</p><pre><code>git reset HEAD Hello.java</code></pre><p>运行结果</p><pre><code>Unstaged changes after reset:M    Hello.java</code></pre><p>查看一下状态</p><pre><code>On branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   Hello.javano changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>是不是又回到第一种的状态了。</p><h3 id="不仅仅修改了工作区，还add到了暂存区，而且手贱的我还commit到了版本库。"><a href="#不仅仅修改了工作区，还add到了暂存区，而且手贱的我还commit到了版本库。" class="headerlink" title="不仅仅修改了工作区，还add到了暂存区，而且手贱的我还commit到了版本库。"></a>不仅仅修改了工作区，还add到了暂存区，而且手贱的我还commit到了版本库。</h3><p>如果你目前还没有推送到远程仓库，还有的救，还记得上面说的时光倒流么。不记得的可以翻一翻。</p><pre><code>git reset --hard HEAD^</code></pre><p>这样就回到了第二种情况。</p><h2 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h2><p>在仓库里新建一个文件，然后添加到版本库</p><pre><code>git add test.txtgit commit -m &quot;add test.txt&quot;</code></pre><p>然后我们将这个文件删除掉。</p><pre><code>rm test.txt</code></pre><p>查看一下状态</p><pre><code>On branch masterChanges not staged for commit:  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    deleted:    test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>git 检测到有文件被删除了，git告诉你有两种方式<br>    1. git rm <file>… ：从版本库删除文件，并重新commit<br>    2. 撤销删除操作，test.txt将被恢复。</p><p>使用下面的命令从版本库删除文件。</p><pre><code>git rm test.txtgit commit -m &quot;remove test.txt&quot;</code></pre><p>小结：通过以上的学习我们已经可以熟练的操作本地的git仓库了。</p><hr><h1 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h1><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><p>git是分布式版本控制系统。分布式，即最开始仅有一个仓库作为服务器，然后其他人从这个仓库克隆出代码，提交到这个仓库，<br>每个克隆的仓库都可以是一个服务器，各个仓库之间没有主次之分。</p><p>要学习远程仓库，首先得有个远程仓库，由于搭建远程git仓库有(本)点(人)复(不)杂(会)。这里使用github作为远程仓库</p><p>由于之前写过类似的，这里不再赘述。</p><p><strong>需要注意的是，在创建仓库是使用learnGit作为仓库名</strong></p><p><a href="http://blog.csdn.net/u013451048/article/details/52399278">在github创建远程仓库</a></p><p>你只需做到使用下面的命令测试成功就好</p><pre><code>ssh -v git@github.com </code></pre><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>将本地仓库与远程仓库关联，在本地仓库目录下执行下面的命令。</p><pre><code>git remote add origin git@github.com:coderRan/learnGit.git</code></pre><p><strong>注意：<a href="mailto:git@github.com">git@github.com</a>:coderRan/learnGit.git一定是你自己的创建的仓库，不要复制我的，<br>因为这是我的仓库，关联不会出问题，推送的时候你是推送不上去的，因为我的github没有添加你的ssh key</strong></p><p>现在仅仅是关联起来了，还没有将代码推送到远程仓库，执行下面的命令</p><pre><code>git push -u origin master</code></pre><p><strong>要是没有出现下面的结果请看0x03</strong></p><p>上传文件是需要时间的，所以要耐心等待一下。执行结果</p><pre><code>Counting objects: 16, done.Delta compression using up to 4 threads.Compressing objects: 100% (9/9), done.Writing objects: 100% (16/16), 1.29 KiB | 0 bytes/s, done.Total 16 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To github.com:coderRan/learnGit.git * [new branch]      master -&gt; masterBranch master set up to track remote branch master from origin.</code></pre><p>去你刚才创建的仓库看一下，应该上传上去了。</p><p>第一次推送有点麻烦，因为git需要将本地仓库的分支与远程仓库的分支进行关联。以后推送的话可以使用下面的命令</p><pre><code>git push origin master</code></pre><h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><p>在第一次使用 push 或者 clone 这个命令时，会弹出一个警告</p><pre><code>The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?</code></pre><p>这个是SSH链接需要你确认ssh key。<br>输入yes，结果</p><pre><code>Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</code></pre><p>这些警告只出现在第一次提交时，以后就不会出来了。</p><h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p>新建一个 目录<br>    mkdir newGit<br>    cd newGit<br>然后从我们刚刚新建的仓库克隆一个</p><pre><code>git clone git@github.com:coderRan/learnGit.git</code></pre><p>执行结果：</p><pre><code>Cloning into &#39;learnGit&#39;...remote: Counting objects: 16, done.remote: Compressing objects: 100% (8/8), done.remote: Total 16 (delta 1), reused 16 (delta 1), pack-reused 0Receiving objects: 100% (16/16), done.Resolving deltas: 100% (1/1), done.</code></pre><hr><h1 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h1><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>分支是什么呢？<br>你可以理解成树枝。<br>分支可以用来干什么呢？<br>使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线。</p><p>假如，你开发了一个支付宝，然后想添加一个扫福的功能，你总不能直接在你的版本库里乱改吧，这个版本正常用着呢，万一改错，不能用了就麻烦了。话说不是有clone么，克隆一份就好了，再怎么改也不会出问题，但是，你在开发过程中，完成一部分工作后总得提交到远程仓库吧。(有人说，不用提交啊，自己在本地仓库搞就好了。注意，协同作业)</p><p>这个时候就用到分支了。把仓库看成一棵树，随着一次次的commit，这棵树越长越高，分支就向树枝一样。在分支上可以随便撒野，不会搞坏主分支。你可以把你的修改先提交到自己创建的分支上，等你把这个扫福的功能开发完了，还能合并到主分支上。</p><h2 id="分支的创建"><a href="#分支的创建" class="headerlink" title="分支的创建"></a>分支的创建</h2><p>在我们创建好仓库后，版本库的状态是下面这样的，其中的[A],[B],[C] 代表一个commit</p><pre><code>  HEAD-&gt;master--&gt;|                 |    [A]--&gt;[B]--&gt;[C] </code></pre><p>其中 master 代表的是主分支，而HEAD代表的是当前分支，由于只有一个分支所以HEAD指向的是 master<br>我们使用下面的命令创建一个分支，然后切换到新建的分支。</p><pre><code>git branch mybranchgit checkout mybranch</code></pre><p>你也可以使用一条命令，创建并切换</p><pre><code>git checkout -b mybranch</code></pre><p>查看下分支</p><pre><code>git branch  master* mybranch</code></pre><p>现在git仓库的状态是下面这样的</p><pre><code>    master--&gt;|             |[A]--&gt;[B]--&gt;[C]              |             |&lt;--mybranch&lt;--HEAD</code></pre><p>然后我们再次对Hello.java文件做一下修改</p><pre><code>public class Hello&#123;    public static void main(String[] args)&#123;    &#125;    public void addBranch()&#123;    &#125;&#125;    </code></pre><p>然后commit到版本库</p><h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h2><p>现在git仓库的状态是下面这样的</p><pre><code>    master--&gt;|             |[A]--&gt;[B]--&gt;[C]~~&gt;[D]                    |                   |&lt;--mybranch&lt;--HEAD</code></pre><p>然后切换到 master 分支</p><pre><code>git checkout master</code></pre><p>现在git仓库的状态是下面这样的</p><pre><code> HEAD--&gt;master--&gt;|                 |    [A]--&gt;[B]--&gt;[C]~~&gt;[D]                        |                       |&lt;--mybranch</code></pre><p>合并到 master 分支 </p><pre><code>git merge mybranch </code></pre><p>执行结果</p><pre><code>Updating 28c1cc8..11d62a7Fast-forward Hello.java | 3 +++ 1 files changed, 3 insertions(+)</code></pre><p>现在git仓库的状态是下面这样的</p><pre><code>   HEAD--&gt;master--&gt;|                   |[A]--&gt;[B]--&gt;[C]~~&gt;[D]                    |                   |&lt;--mybranch</code></pre><h2 id="分支的删除"><a href="#分支的删除" class="headerlink" title="分支的删除"></a>分支的删除</h2><pre><code>git branch -d mybranch</code></pre><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>快速合并的速度确实很快，但是前提是两个分支没有冲突。</p><p>重新创建新的分支</p><pre><code>git checkout -b newbranch</code></pre><p>修改 readme.txt 文件</p><pre><code>hello git  hello git 2.0  添加 hello.java 文件  在 newbranch 分支上做的修改    </code></pre><p>提交</p><pre><code>git add readme.txt git commit -m &quot;newbranch 修改&quot;[newbranch b8ac4ad] newbranch 修改 1 file changed, 1 insertion(+)</code></pre><p>切换到 master 分支 </p><pre><code>git checkout master</code></pre><p>打开 readme.txt 文件，发现并没有改变，因为我们的修改不是在master分支上的。</p><p>添加一行</p><pre><code>hello git  hello git 2.0  添加 hello.java 文件  在 master 分支上做的修改</code></pre><p>提交</p><pre><code>git add readme.txt git commit -m &quot;master 修改&quot;[master 80c56bf] master 修改 1 file changed, 1 insertion(+)</code></pre><p>现在 两个分支上对一个文件的同一个地方（同一行）做了不同的修改，是没办法快速合并的。</p><p>合并下试试</p><pre><code>git merge newbranchgit merge newbranch Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>果然，git说， readme.txt 文件冲突了，修复后重新提交。<br>使用 git status 看看状态</p><pre><code>git statusOn branch masterYour branch is ahead of &#39;origin/master&#39; by 3 commits.  (use &quot;git push&quot; to publish your local commits)You have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)    both modified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>git说 对 readme.txt 共同的两个修改</p><p>我们直接打开 readme.txt 文件看看</p><pre><code>hello githello git 2.0添加 hello.java 文件&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD在 master 分支上做的修改=======在 newbranch 分支进行修改  &gt;&gt;&gt;&gt;&gt;&gt;&gt; newbranch</code></pre><p>其中 &lt;&lt;&lt;,===,&gt;&gt;&gt;是分割线。<br>我们修改一下</p><pre><code>hello githello git 2.0添加 hello.java 文件修复了冲突</code></pre><p>然后提交<br>    git add readme.txt<br>    git commit -m “修复了冲突”</p><pre><code>[master 9f1e5f5] 修复了冲突</code></pre><p>好了，解决。现在git已经将两个分支自动合并了。你可以使用 </p><pre><code>git log --graph</code></pre><p>查看分支图</p><p>然后删除 newbranch 分支</p><pre><code>git branch -d newbranch Deleted branch newbranch (was b8ac4ad).</code></pre><h2 id="合并的方式选择"><a href="#合并的方式选择" class="headerlink" title="合并的方式选择"></a>合并的方式选择</h2><p>从上面我们知道，分支的合并有两种方式，一种是 快速合并，一种是解决冲突的合并。</p><p>两种合并的区别是</p><pre><code>快速合并要保证没有冲突，合并完删除分支后，会丢掉分支信息。冲突合并会保留分支信息，Git会在merge时生成一个新的commit。</code></pre><p>可以使用<code>--no-ff</code>参数强制禁用快速合并</p><pre><code>git merge --no-ff -m &quot;禁用快速合并&quot; newbranch</code></pre><p>因为需要重新生成一个 commit 所以需要添加<code>-m</code>参数。</p><h1 id="Git-tag"><a href="#Git-tag" class="headerlink" title="Git tag"></a>Git tag</h1><p>有时我们需要定位到某个版本，但是目前我们只能通过那个长长的commit号来确定。<br>为了更好的定位，我们可以给commit 打个tag。</p><h2 id="默认在最新的commit上打tag"><a href="#默认在最新的commit上打tag" class="headerlink" title="默认在最新的commit上打tag"></a>默认在最新的commit上打tag</h2><pre><code>git tag v1.0</code></pre><h2 id="对任意commit打tag"><a href="#对任意commit打tag" class="headerlink" title="对任意commit打tag"></a>对任意commit打tag</h2><p>找到commit号(还记得怎么看commitid号么？)</p><pre><code>git tag v0.9 &lt;commitid&gt;</code></pre><h2 id="查看tag"><a href="#查看tag" class="headerlink" title="查看tag"></a>查看tag</h2><p>需要注意的是，tag是按字母排序的额，不是按时间排序的</p><pre><code>git tag</code></pre><h2 id="查看tag信息"><a href="#查看tag信息" class="headerlink" title="查看tag信息"></a>查看tag信息</h2><pre><code>git show &lt;tagname&gt;</code></pre><h2 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h2><pre><code>git tag -d &lt;tagname&gt;</code></pre><h2 id="操作远程仓库的tag"><a href="#操作远程仓库的tag" class="headerlink" title="操作远程仓库的tag"></a>操作远程仓库的tag</h2><p>因为tag默认是存储到本地的，所以需要手动将tag推送到远程仓库</p><pre><code>git push origin &lt;tagname&gt;</code></pre><p>如果tag比较多，可以一次将所有tag都推送到远程仓库</p><pre><code>git push origin --tags</code></pre><p>如果你已经将tag推送到远程仓库了，再想删除就有点麻烦了。<br>首先需要删除本地的tag</p><pre><code>git tag -d &lt;tagname&gt;</code></pre><p>然后再删除远程仓库的tag</p><pre><code>git push origin :refs/tags/&lt;tagname&gt;</code></pre><hr><p>好了，有了这些基本上可以应付工作中的需要了。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接Redis异常：JedisMovedDataException</title>
      <link href="20180518.html"/>
      <url>20180518.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>java API连接redis<br>出现下面的异常信息：</p><pre><code>redis.clients.jedis.exceptions.JedisMovedDataException: MOVED 1539 127.0.0.1:6379</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将连接对象从 Jedis 换成 JedisCluster。就可以了。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>MOVED表示使用的是Redis群集。而 Jedis 不是集群模式。</p><pre><code>//import redis.clients.jedis.HostAndPort;//import redis.clients.jedis.JedisCluster;HostAndPort hostAndPort = new HostAndPort(host, port);Set&lt;HostAndPort&gt; hostAndPortSet = new HashSet&lt;&gt;();hostAndPortSet.add(hostAndPort);JedisCluster jedis = new JedisCluster(hostAndPortSet);jedis.setnx(key, value);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> JedisMovedDataException </tag>
            
            <tag> JedisCluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign 的简单使用及传参方式</title>
      <link href="20180517.html"/>
      <url>20180517.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-Feign-简介"><a href="#0-Feign-简介" class="headerlink" title="0. Feign 简介"></a>0. Feign 简介</h2><p>Feign 是简化Java HTTP客户端开发的工具。它使用注解的方式将HTTP的URL封装成接口，每个URL对应一个接口，大大简化了HTTP客户端的开发。</p><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;    &lt;artifactId&gt;feign-core&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;    &lt;artifactId&gt;feign-jackson&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="2-定义API"><a href="#2-定义API" class="headerlink" title="2. 定义API"></a>2. 定义API</h2><pre><code>import feign.Headers;import feign.Param;import feign.RequestLine;import java.util.List;/** * Create by zdran@gmail.com on 2018/3/20 * *///Headers 注解：配置请求头信息@Headers(&#123;&quot;Accept: application/json&quot;, &quot;Content-Type: application/json&quot;&#125;)public interface UserApi &#123;    /**     * RequestLine 注解：请求的方法与url，这里需要注意的是url写的是与Controller里的地址，不是完整的url地址。     * GET 请求方法，遵循RESTful风格     * @return     */    @RequestLine(&quot;GET /user/all&quot;)    List&lt;User&gt; getAllUser();    /**     * restful方式传参     * @param name     * @return     */    @RequestLine(&quot;GET /user/&#123;name&#125;&quot;)    User getByName(@Param(&quot;name&quot;) String name);    /**     * url方式传参数     * @param id     * @return     */    @RequestLine(&quot;GET /user/id?id=&#123;id&#125;&quot;)    User getById(@Param(&quot;id&quot;) String id);    /**     * post 传参，传复杂类型     * @param user     */    @RequestLine(&quot;POST /user/add&quot;)    void addUser(User user);&#125;</code></pre><h2 id="3-定义实现API的controller"><a href="#3-定义实现API的controller" class="headerlink" title="3. 定义实现API的controller"></a>3. 定义实现API的controller</h2><pre><code>import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import javax.validation.Valid;import java.util.ArrayList;import java.util.List;/** * Create by zdran@gmail.com on 2018/3/20 * */@RestController@RequestMapping(value = &quot;/user&quot;, produces = &quot;application/json&quot;)public class UserController &#123;    @GetMapping(value = &quot;/all&quot;)    List&lt;User&gt; getAll()&#123;        List&lt;User&gt; users = new ArrayList&lt;&gt;();        User user = new User();        user.setName(&quot;获取所有用户&quot;);        users.add(user);        return users;    &#125;    @GetMapping(value = &quot;/&#123;name&#125;&quot;)    User getByName(@PathVariable String name)&#123;        User user = new User();        user.setName(&quot;获取用户：&quot;+name);        return user;    &#125;    @GetMapping(value = &quot;/id&quot;)    User getById(String id)&#123;        User user = new User();        user.setName(&quot;获取用户：&quot;+id);        return user;    &#125;    @PostMapping(value = &quot;/add&quot;)    void addUser(@RequestBody User user)&#123;    &#125;&#125;</code></pre><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h2><pre><code>import feign.Feign;import feign.httpclient.ApacheHttpClient;import feign.jackson.JacksonDecoder;import feign.jackson.JacksonEncoder;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * Create by zdran@gmail.com on 2018/3/20 * */@Controllerpublic class ClientController &#123;    private static final String apiBaseUrl = &quot;http://localhost:8080/feign&quot;;    UserApi userApi = Feign.builder()            .client(new ApacheHttpClient())            .encoder(new JacksonEncoder())            .decoder(new JacksonDecoder())            .target(UserApi.class, apiBaseUrl);    @GetMapping(value = &quot;/client/user/&#123;name&#125;&quot;)    public User getUserInfo(@PathVariable String name)&#123;        return userApi.getByName(name);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 使用 Jsoup 拦截XSS</title>
      <link href="20180511.html"/>
      <url>20180511.html</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>使用 Spring Boot 的 Filter 对参数拦截，使用 Jsoup 对 参数中的 XSS进行过滤</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Spring Boot 2.0 </li><li>Jsoup (可选)</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Spring Boot 的 Filter 拦截到前端的参数后进行过滤（看着是不是很简单？？）。 </p><p>说白了就是两个功能：参数拦截、脚本过滤。</p><h3 id="参数拦截"><a href="#参数拦截" class="headerlink" title="参数拦截"></a>参数拦截</h3><p>想要过滤XSS首先要能拦截到前端的参数。</p><p>先写个Filter:</p><pre><code>import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;public class XSSEscapeFilter implements Filter &#123;      @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;      @Override    public void destroy() &#123;    &#125;      @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        //后面会有 XssHttpServletRequestWrapper 的代码。这个类是自己定义的        chain.doFilter(new XssHttpServletRequestWrapper((HttpServletRequest) request), response);    &#125;&#125;</code></pre><p>这个Filter 是可以拦截到请求的，但是呢，如果想要对参数进行修改就需要重新定义 HttpServletRequestWrapper，只有用自定义的HttpServletRequestWrapper 才能对参数进行修改。</p><p>下面定义 XssHttpServletRequestWrapper：</p><pre><code>import org.apache.commons.lang3.StringUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.safety.Whitelist;import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.io.*;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * 实现XSS过滤 * Create by zdRan on 2018/5/8 * * @author cm.zdran@gmail.com */public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123;    private HttpServletRequest orgRequest = null;    public XssHttpServletRequestWrapper(HttpServletRequest request) &#123;        super(request);        orgRequest = request;    &#125;    @Override    public String getParameter(String name) &#123;           // 对参数进行修改        return name;    &#125;    @Override    public Map getParameterMap() &#123;           // 对参数进行修改        return super.getParameterMap();;    &#125;    @Override    public String[] getParameterValues(String name) &#123;        String[] arr = super.getParameterValues(name);        // 对参数进行修改        return arr;    &#125;    @Override    public String getHeader(String name) &#123;        //对参数进行修改        return super.getHeader(name);;    &#125;    /**     * 获取最原始的request     *     * @return     */    public HttpServletRequest getOrgRequest() &#123;        return orgRequest;    &#125;    /**     * 获取最原始的request的静态方法     *     * @return     */    public static HttpServletRequest getOrgRequest(HttpServletRequest req) &#123;        if (req instanceof XssHttpServletRequestWrapper) &#123;            return ((XssHttpServletRequestWrapper) req).getOrgRequest();        &#125;        return req;    &#125;</code></pre><p>这样就能对参数进行修改了，但是，目前的情况还不能处理POST请求，或者 RequestBody 注解。</p><p>当使用 RequestBody 注解时，你会发现，重写的这几个方法都没有走，说明我们没有重写全方法。</p><p>找了一些资料发现：<strong>RequestBody注解读取参数的方法是getInputStream()</strong> 。</p><p>我们重写一下这个方法：</p><pre><code> @Override    public ServletInputStream getInputStream() throws IOException &#123;        BufferedReader br = new BufferedReader(new InputStreamReader(orgRequest.getInputStream()));        String line = br.readLine();        String result = &quot;&quot;;        if (line != null) &#123;            //对参数进行处理        &#125;        return new WrappedServletInputStream(new ByteArrayInputStream(result.getBytes()));    &#125;</code></pre><p>然后启动这个 Filter</p><pre><code>import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.DispatcherType;/** * Create by zdRan on 2018/5/8 * * @author cm.zdran@gmail.com */@Configurationpublic class XssFilterConfiguration &#123;    /**     * xss过滤拦截器     */    @Bean    public FilterRegistrationBean xssFilterRegistrationBean() &#123;        FilterRegistrationBean initXssFilterBean = new FilterRegistrationBean();        initXssFilterBean.setFilter(new XSSEscapeFilter());        initXssFilterBean.setOrder(1);        initXssFilterBean.setEnabled(true);        initXssFilterBean.addUrlPatterns(&quot;/*&quot;);        initXssFilterBean.setDispatcherTypes(DispatcherType.REQUEST);        return initXssFilterBean;    &#125;&#125;</code></pre><p>到这里基本上就拦截到参数了，你可以自己定义对参数的修改规则。也可以使用jsoup对XSS进行过滤</p><h3 id="脚本过滤"><a href="#脚本过滤" class="headerlink" title="脚本过滤"></a>脚本过滤</h3><p>使用 jsoup 对参数中的 标签进行过滤<br>添加依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;    &lt;version&gt;1.11.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>完整的 XssHttpServletRequestWrapper 代码：</p><pre><code>import org.apache.commons.lang3.StringUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.safety.Whitelist;import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.io.*;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * 实现XSS过滤 * Create by zdRan on 2018/5/8 * * @author cm.zdran@gmail.com */public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123;    private HttpServletRequest orgRequest = null;    /**    * 配置可以通过过滤的白名单    * /    private static final Whitelist whitelist = new Whitelist();    /**     * 配置过滤化参数,不对代码进行格式化     */    private static final Document.OutputSettings outputSettings = new Document.OutputSettings().prettyPrint(false);    public XssHttpServletRequestWrapper(HttpServletRequest request) &#123;        super(request);        orgRequest = request;    &#125;    @Override    public ServletInputStream getInputStream() throws IOException &#123;        BufferedReader br = new BufferedReader(new InputStreamReader(orgRequest.getInputStream()));        String line = br.readLine();        String result = &quot;&quot;;        if (line != null) &#123;            result += clean(line);        &#125;        return new WrappedServletInputStream(new ByteArrayInputStream(result.getBytes()));    &#125;    /**     * 覆盖getParameter方法，将参数名和参数值都做xss过滤。&lt;br/&gt;     * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt;     * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖     */    @Override    public String getParameter(String name) &#123;        if ((&quot;content&quot;.equals(name) || name.endsWith(&quot;WithHtml&quot;))) &#123;            return super.getParameter(name);        &#125;        name = clean(name);        String value = super.getParameter(name);        if (StringUtils.isNotBlank(value)) &#123;            value = clean(value);        &#125;        return value;    &#125;    @Override    public Map getParameterMap() &#123;        Map map = super.getParameterMap();        // 返回值Map        Map&lt;String, String&gt; returnMap = new HashMap&lt;String, String&gt;();        Iterator entries = map.entrySet().iterator();        Map.Entry entry;        String name = &quot;&quot;;        String value = &quot;&quot;;        while (entries.hasNext()) &#123;            entry = (Map.Entry) entries.next();            name = (String) entry.getKey();            Object valueObj = entry.getValue();            if (null == valueObj) &#123;                value = &quot;&quot;;            &#125; else if (valueObj instanceof String[]) &#123;                String[] values = (String[]) valueObj;                for (int i = 0; i &lt; values.length; i++) &#123;                    value = values[i] + &quot;,&quot;;                &#125;                value = value.substring(0, value.length() - 1);            &#125; else &#123;                value = valueObj.toString();            &#125;            returnMap.put(name, clean(value).trim());        &#125;        return returnMap;    &#125;    @Override    public String[] getParameterValues(String name) &#123;        String[] arr = super.getParameterValues(name);        if (arr != null) &#123;            for (int i = 0; i &lt; arr.length; i++) &#123;                arr[i] = clean(arr[i]);            &#125;        &#125;        return arr;    &#125;    /**     * 覆盖getHeader方法，将参数名和参数值都做xss过滤。&lt;br/&gt;     * 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt;     * getHeaderNames 也可能需要覆盖     */    @Override    public String getHeader(String name) &#123;        name = clean(name);        String value = super.getHeader(name);        if (StringUtils.isNotBlank(value)) &#123;            value = clean(value);        &#125;        return value;    &#125;    /**     * 获取最原始的request     *     * @return     */    public HttpServletRequest getOrgRequest() &#123;        return orgRequest;    &#125;    /**     * 获取最原始的request的静态方法     *     * @return     */    public static HttpServletRequest getOrgRequest(HttpServletRequest req) &#123;        if (req instanceof XssHttpServletRequestWrapper) &#123;            return ((XssHttpServletRequestWrapper) req).getOrgRequest();        &#125;        return req;    &#125;    public String clean(String content) &#123;        String result = Jsoup.clean(content, &quot;&quot;, whitelist, outputSettings);        return result;    &#125;    private class WrappedServletInputStream extends ServletInputStream &#123;        public void setStream(InputStream stream) &#123;            this.stream = stream;        &#125;        private InputStream stream;        public WrappedServletInputStream(InputStream stream) &#123;            this.stream = stream;        &#125;        @Override        public int read() throws IOException &#123;            return stream.read();        &#125;        @Override        public boolean isFinished() &#123;            return true;        &#125;        @Override        public boolean isReady() &#123;            return true;        &#125;        @Override        public void setReadListener(ReadListener readListener) &#123;        &#125;    &#125;&#125;</code></pre><p>好了。到这就算结束了，不过目前还有一个小问题。</p><p>使用 Jsoup 是可以过滤掉所有的html标签，但是也有个问题，比如</p><p>参数是: <code>&#123;&quot;name&quot;:&quot;&lt;html&quot;,&quot;passwd&quot;:&quot;12345&quot;&#125;,过滤后的结果是：&#123;&quot;name&quot;:&quot;</code></p><p>因为没有找到<code>&lt;html&gt;</code>标签的结束位置，所以就会过滤掉后面所有的参数。</p><p>这样就会导致 controller 获取参数的时候异常。</p><p>但是这种 html 标签即便是返回给前端，浏览器也无法解析，因为标签是错误的。如果你真的需要过滤这种参数。</p><p>可以尝试直接过滤特殊字符。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Filter </tag>
            
            <tag> XSS </tag>
            
            <tag> Jsoup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 使用Git报错&quot;Could not read from remote repository&quot;</title>
      <link href="20180508.html"/>
      <url>20180508.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用IntelliJ IDEA 操作github仓库时，突然出现下面的错误</p><pre><code>&quot;Could not read from remote repository&quot;</code></pre><p>之前一直用着好好的，忽然就不能用了。在命令行下pull了一些，没有问题。怀疑是IDEA的配置问题。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>个人觉得应该是 IDEA 的SSH过期了。</p><p>PS: 出现这种情况的原因之一就是，你很久没有更新过这个仓库的代码了。估计是仓库心凉了 :)</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在 Setting窗口找到git，将ssh executable项设置为native。入下图<br><img src="/images/20180508.jpg" alt="Git设置"></p>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.0 实现优雅停机</title>
      <link href="20180504.html"/>
      <url>20180504.html</url>
      
        <content type="html"><![CDATA[<h2 id="前期踩的坑-Spring-Boot-1-x"><a href="#前期踩的坑-Spring-Boot-1-x" class="headerlink" title="前期踩的坑 (Spring Boot 1.x)"></a>前期踩的坑 (Spring Boot 1.x)</h2><h3 id="1-添加mavne依赖"><a href="#1-添加mavne依赖" class="headerlink" title="1. 添加mavne依赖"></a>1. 添加mavne依赖</h3><pre><code>&lt;!-- springboot监控 --&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;  &lt;/dependency&gt;  </code></pre><h3 id="2-启用shutdown"><a href="#2-启用shutdown" class="headerlink" title="2. 启用shutdown"></a>2. 启用shutdown</h3><p>在配置文件里添加下面的配置</p><pre><code>#启用shutdown endpoint的HTTP访问endpoints.shutdown.enabled=true#不需要验证 endpoints.shutdown.sensitive=false</code></pre><p>启动的时候可以看到下面的日志，就说明成功了<br><img src="/images/%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97.png" alt="启动日志"></p><h3 id="3-优雅停机"><a href="#3-优雅停机" class="headerlink" title="3. 优雅停机"></a>3. 优雅停机</h3><p>发送POST请求 <code>http://localhost:8080/shutdown</code><br>如果响应码是404 可以尝试POST <code>http://localhost:8080/actuator/shutdown</code></p><h2 id="Spring-Boot-2-0"><a href="#Spring-Boot-2-0" class="headerlink" title="Spring Boot 2.0"></a>Spring Boot 2.0</h2><p>如果你使用的spring boot版本是2.x的就会发现，这些POST请求都会出现404的结果。</p><p>下面是Spring Boot 2.0 优雅停机的实现方式。</p><h3 id="1-修改Application启动类"><a href="#1-修改Application启动类" class="headerlink" title="1.修改Application启动类"></a>1.修改Application启动类</h3><h4 id="tomcat容器"><a href="#tomcat容器" class="headerlink" title="tomcat容器"></a>tomcat容器</h4><pre><code>@SpringBootApplicationpublic class ShutdownApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ShutdownApplication.class, args);    &#125;    /**     * 用于接受 shutdown 事件     */    @Bean    public GracefulShutdown gracefulShutdown() &#123;        return new GracefulShutdown();    &#125;    /**     * 配置tomcat     *     * @return     */    @Bean    public ServletWebServerFactory servletContainer() &#123;        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();        tomcat.addConnectorCustomizers(gracefulShutdown());        return tomcat;    &#125;    /**     * 优雅关闭 Spring Boot。容器必须是 tomcat     */    private class GracefulShutdown implements TomcatConnectorCustomizer, ApplicationListener&lt;ContextClosedEvent&gt; &#123;        private final Logger log = LoggerFactory.getLogger(GracefulShutdown.class);        private volatile Connector connector;        private final int waitTime = 10;        @Override        public void customize(Connector connector) &#123;            this.connector = connector;        &#125;        @Override        public void onApplicationEvent(ContextClosedEvent contextClosedEvent) &#123;            this.connector.pause();            Executor executor = this.connector.getProtocolHandler().getExecutor();            if (executor instanceof ThreadPoolExecutor) &#123;                try &#123;                    ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;                    threadPoolExecutor.shutdown();                    if (!threadPoolExecutor.awaitTermination(waitTime, TimeUnit.SECONDS)) &#123;                        log.warn(&quot;Tomcat 进程在&quot; + waitTime + &quot; 秒内无法结束，尝试强制结束&quot;);                    &#125;                &#125; catch (InterruptedException ex) &#123;                    Thread.currentThread().interrupt();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="Undertow容器-没有使用过，不保证可用"><a href="#Undertow容器-没有使用过，不保证可用" class="headerlink" title="Undertow容器 (没有使用过，不保证可用)"></a>Undertow容器 (没有使用过，不保证可用)</h4><pre><code>@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;    /**     * 优雅关闭 Spring Boot     */    @Component    public class GracefulShutdown implements ApplicationListener&lt;ContextClosedEvent&gt; &#123;        @Autowired        private GracefulShutdownWrapper gracefulShutdownWrapper;        @Autowired        private ServletWebServerApplicationContext context;        @Override        public void onApplicationEvent(ContextClosedEvent contextClosedEvent)&#123;            gracefulShutdownWrapper.getGracefulShutdownHandler().shutdown();            try &#123;                UndertowServletWebServer webServer = (UndertowServletWebServer)context.getWebServer();                Field field = webServer.getClass().getDeclaredField(&quot;undertow&quot;);                field.setAccessible(true);                Undertow undertow = (Undertow) field.get(webServer);                List&lt;Undertow.ListenerInfo&gt; listenerInfo = undertow.getListenerInfo();                Undertow.ListenerInfo listener = listenerInfo.get(0);                ConnectorStatistics connectorStatistics = listener.getConnectorStatistics();                while (connectorStatistics.getActiveConnections() &gt; 0)&#123;&#125;            &#125;catch (Exception e)&#123;                // Application Shutdown            &#125;        &#125;    &#125;    @Component    public class GracefulShutdownWrapper implements HandlerWrapper&#123;        private GracefulShutdownHandler gracefulShutdownHandler;        @Override        public HttpHandler wrap(HttpHandler handler) &#123;            if(gracefulShutdownHandler == null) &#123;                this.gracefulShutdownHandler = new GracefulShutdownHandler(handler);            &#125;            return gracefulShutdownHandler;        &#125;        public GracefulShutdownHandler getGracefulShutdownHandler() &#123;            return gracefulShutdownHandler;        &#125;    &#125;    @Component    @AllArgsConstructor    public class UndertowExtraConfiguration &#123;        private final GracefulShutdownWrapper gracefulShutdownWrapper;        @Bean        public UndertowServletWebServerFactory servletWebServerFactory() &#123;            UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory();            factory.addDeploymentInfoCustomizers(deploymentInfo -&gt; deploymentInfo.addOuterHandlerChainWrapper(gracefulShutdownWrapper));            factory.addBuilderCustomizers(builder -&gt; builder.setServerOption(UndertowOptions.ENABLE_STATISTICS, true));            return factory;        &#125;    &#125;&#125;</code></pre><h3 id="2-使用-kill-命令杀死进程"><a href="#2-使用-kill-命令杀死进程" class="headerlink" title="2. 使用 kill 命令杀死进程"></a>2. 使用 kill 命令杀死进程</h3><p>使用下面的命令杀死进程。该命令是向 某个进程发送终止信号。</p><pre><code>kill -15 [PID]</code></pre><p><a href="http://www.spring4all.com/article/1022">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pom编译报错</title>
      <link href="20180424.html"/>
      <url>20180424.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>IDEA的maven项目导入到eclipse下，出现下面的错误</p><p>org.codehaus.plexus.archiver.jar.Manifest.write(java.io.PrintWriter)</p><p><img src="/images/20180424-1.png" alt=""></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>出现这个问题的原因是由于 maven的版本的问题，需要安装eclipse的maven扩展插件。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>点击 help -&gt; Install New Software -&gt; Work with 输入如下地址:</p><pre><code>https://otto.takari.io/content/sites/m2e.extras/m2eclipse-mavenarchiver/0.17.2/N/LATEST/ </code></pre><p>如果这个地址出现无法下载的情况可以改为下面这个地址：</p><pre><code>http://repo1.maven.org/maven2/.m2e/connectors/m2eclipse-mavenarchiver/0.17.2/N/LATEST/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32. Longest Valid Parentheses</title>
      <link href="20180401.html"/>
      <url>20180401.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/leetcode">刷题仓库地址</a></li><li><a href="https://zdran.com/20180327.html">4. Median of Two Sorted Arrays</a></li><li><a href="https://zdran.com/20180328.html">10. Regular Expression Matching</a></li><li><a href="https://zdran.com/20180329.html">23. Merge k Sorted Lists</a></li><li><a href="https://zdran.com/20180330.html">25. Reverse Nodes in k-Group</a></li><li><a href="https://zdran.com/20180331.html">30. Substring with Concatenation of All Words</a></li><li><a href="https://zdran.com/20180401.html">32. Longest Valid Parentheses</a></li><li><a href="https://zdran.com/20190321.html">37. Sudoku Solver</a></li></ul><hr><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p><p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code>Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4.</code></pre><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>给定一个只包含字符’（’和’）’的字符串，找出最长有效（格式良好）的括号中的字符串的长度。 </p><p>对于“（（）”，最长的有效括号是“（）”，长度= 2。</p><h2 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h2><p>采用栈，判断栈顶元素与当前元素是否匹配，匹配成功则弹出，不成功则压入栈，入栈的是索引值，不是字符。</p><p>遇到 ‘(‘ 入栈索引值</p><p>遇到 ‘)’ 先出栈，</p><p>如果栈为空，直接入栈</p><p>如果栈不空，用当前索引减去栈顶索引，即得新的有效格式的长度。</p><h2 id="Accept-Code"><a href="#Accept-Code" class="headerlink" title="Accept Code"></a>Accept Code</h2><pre><code>public static int longestValidParentheses(String s) &#123;    int ans = 0;    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    stack.push(-1);    for (int i = 0; i &lt; s.length(); i++) &#123;        char c = s.charAt(i);        if (c == &#39;(&#39;) &#123;            stack.push(i);        &#125; else &#123;            stack.pop();            if (stack.empty()) &#123;                stack.push(i);            &#125; else &#123;                ans = i - stack.peek() &gt; ans ? i - stack.peek() : ans;            &#125;        &#125;    &#125;    return ans;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30. Substring with Concatenation of All Words</title>
      <link href="20180331.html"/>
      <url>20180331.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/leetcode">刷题仓库地址</a></li><li><a href="https://zdran.com/20180327.html">4. Median of Two Sorted Arrays</a></li><li><a href="https://zdran.com/20180328.html">10. Regular Expression Matching</a></li><li><a href="https://zdran.com/20180329.html">23. Merge k Sorted Lists</a></li><li><a href="https://zdran.com/20180330.html">25. Reverse Nodes in k-Group</a></li><li><a href="https://zdran.com/20180331.html">30. Substring with Concatenation of All Words</a></li><li><a href="https://zdran.com/20180401.html">32. Longest Valid Parentheses</a></li><li><a href="https://zdran.com/20190321.html">37. Sudoku Solver</a></li></ul><hr><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given a string, s, and a list of words, words, that are all of the same length.<br>Find all starting indices of substring(s) in s that is a concatenation of each word in<br>words exactly once and without any intervening characters.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="$xslt">For example, given:s: &quot;barfoothefoobarman&quot;words: [&quot;foo&quot;, &quot;bar&quot;]You should return the indices: [0,9].(order does not matter).</code></pre><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>给你一个字符串s和一个长度相同的单词列表。从s中找出所有以单词列表串起来的子串的起始位置，这些字符串中的每个单词只是一个字符串，没有任何中介字符。</p><p>单词列表的串联顺序是任意的。意思就是找出s中恰好包含所有单词的子串的起始位置</p><h2 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h2><p>滑块、或者叫窗口搜索。大致意思是定义两个指针，start、end，我们的最终目的是希望，从start至end能恰好包含所有的单词，<br>即，所有单词可以串联成start至end的字符串。</p><p>初始化的时候start和end都是指向0，定义一个count，记录窗口(start,end)内的单词个数。</p><p>如果 end + word.length 没有超过 s.length,说明end后面还有可用的单词，然后开始循环</p><p>如果s的子串 [end,end+word.length),是一个单词，那么end移动到end+word.length，单词个数加1，</p><p>如果count与总的单词个数相等，说明找到一个答案。</p><p>如果s的子串 [end,end+word.length),不是一个单词，start后移，end = start，单词个数清零。</p><p>关于重复单词的问题：</p><p>定义两个map集合，一个用于记录原始的单词与个数的映射，一个用于记录滑块窗口的单词与个数的映射。</p><p>每次移动end的时候，判断一下滑块里的当前单词个数是否超出了原始的单词个数，超出就移动start，临时数据清零</p><h2 id="Accept-Code"><a href="#Accept-Code" class="headerlink" title="Accept Code"></a>Accept Code</h2><pre><code>    public static List&lt;Integer&gt; findSubstring(String s, String[] words) &#123;        Map&lt;String, Integer&gt; wordMap = new HashMap&lt;&gt;();        for (String word : words) &#123;            if (wordMap.containsKey(word)) &#123;                wordMap.put(word, wordMap.get(word) + 1);            &#125; else &#123;                wordMap.put(word, 1);            &#125;        &#125;        Map&lt;String, Integer&gt; temp = new HashMap&lt;&gt;();        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        int start = 0;        int end = 0;        int wordLength = words[0].length();        int arrLength = words.length;        int tempArrLength = 0;        while (end + wordLength &lt; s.length() + 1) &#123;            String tempWord = s.substring(end, end + wordLength);            Integer value = wordMap.get(tempWord);            Integer tempValue = temp.get(tempWord);            if (value != null &amp;&amp; (tempValue == null || tempValue &lt; value)) &#123;                if (tempValue == null) &#123;                    tempValue = 0;                &#125;                temp.put(tempWord, tempValue + 1);                end += wordLength;                tempArrLength++;            &#125; else &#123;                start++;                end = start;                tempArrLength = 0;                temp.clear();            &#125;            if (tempArrLength == arrLength) &#123;                ans.add(start);                start++;                end = start;                tempArrLength = 0;                temp.clear();            &#125;        &#125;        return ans;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. Reverse Nodes in k-Group</title>
      <link href="20180330.html"/>
      <url>20180330.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/leetcode">刷题仓库地址</a></li><li><a href="https://zdran.com/20180327.html">4. Median of Two Sorted Arrays</a></li><li><a href="https://zdran.com/20180328.html">10. Regular Expression Matching</a></li><li><a href="https://zdran.com/20180329.html">23. Merge k Sorted Lists</a></li><li><a href="https://zdran.com/20180330.html">25. Reverse Nodes in k-Group</a></li><li><a href="https://zdran.com/20180331.html">30. Substring with Concatenation of All Words</a></li><li><a href="https://zdran.com/20180401.html">32. Longest Valid Parentheses</a></li><li><a href="https://zdran.com/20190321.html">37. Sudoku Solver</a></li></ul><hr><h1 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>You may not alter the values in the nodes, only nodes itself may be changed.</p><p>Only constant memory is allowed.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="$xslt">For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</code></pre><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。</p><p><strong><em>Notes</em></strong>:</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><h2 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h2><p>使用栈，当栈内的元素足够k个，弹出所有元素形成新的链表。不足k个元素时入栈。</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>注意测试数据：<br>[],1</p><h2 id="Accept-Code"><a href="#Accept-Code" class="headerlink" title="Accept Code"></a>Accept Code</h2><pre><code>/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */public class ReverseNodes &#123;    public ListNode reverseKGroup(ListNode head, int k) &#123;        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();        int index = 0;        ListNode result = null;        ListNode left = null;        ListNode right;        boolean isFirst = true;        while (head != null) &#123;            right = head;            head = head.next;            right.next = null;            stack.push(right);            index++;            if (k == index) &#123;                index = 0;                if (isFirst) &#123;                    result = revers(stack);                    left = result;                    isFirst = false;                &#125; else &#123;                    left.next = revers(stack);                &#125;                while (left.next != null) &#123;                    left = left.next;                &#125;            &#125;        &#125;        while (!stack.empty()) &#123;            if (left == null) &#123;                result = stack.remove(0);                left = result;            &#125; else &#123;                left.next = stack.remove(0);                left = left.next;            &#125;        &#125;        return result;    &#125;    private ListNode revers(Stack&lt;ListNode&gt; stack) &#123;        ListNode head;        ListNode temp = stack.pop();        head = temp;        while (!stack.empty()) &#123;            temp.next = stack.pop();            temp = temp.next;        &#125;        return head;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23. Merge k Sorted Lists</title>
      <link href="20180329.html"/>
      <url>20180329.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/leetcode">刷题仓库地址</a></li><li><a href="https://zdran.com/20180327.html">4. Median of Two Sorted Arrays</a></li><li><a href="https://zdran.com/20180328.html">10. Regular Expression Matching</a></li><li><a href="https://zdran.com/20180329.html">23. Merge k Sorted Lists</a></li><li><a href="https://zdran.com/20180330.html">25. Reverse Nodes in k-Group</a></li><li><a href="https://zdran.com/20180331.html">30. Substring with Concatenation of All Words</a></li><li><a href="https://zdran.com/20180401.html">32. Longest Valid Parentheses</a></li><li><a href="https://zdran.com/20190321.html">37. Sudoku Solver</a></li></ul><hr><h1 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="$xslt">Input:[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>合并k个已排序的链接列表并将其作为一个排序列表返回。分析并描述其复杂性。</p><h2 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h2><p>分治 + 归并排序。将数组进行分支，直到每组有两个链表的时候，把这两个链表进行归并排序。</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h2 id="Accept-Code"><a href="#Accept-Code" class="headerlink" title="Accept Code"></a>Accept Code</h2><pre><code>/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */public class MergekLists &#123;    public ListNode mergeKLists(ListNode[] lists) &#123;        if (lists == null || lists.length == 0) &#123;            return null;        &#125;        return divide(0, lists.length - 1, lists);    &#125;    private ListNode divide(int start, int end, ListNode[] listNodes) &#123;        if (start == end) &#123;            return listNodes[start];        &#125;        ListNode left = divide(start, (start + end) / 2, listNodes);        ListNode right = divide((start + end) / 2 + 1, end, listNodes);        return mergeTwoLists(left, right);    &#125;    public ListNode mergeTwoLists(ListNode leftList, ListNode rightList) &#123;        if (leftList == null) return rightList;        if (rightList == null) return leftList;        if (leftList.val &lt; rightList.val) &#123;            leftList.next = mergeTwoLists(leftList.next, rightList);            return leftList;        &#125; else &#123;            rightList.next = mergeTwoLists(leftList, rightList.next);            return rightList;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. Regular Expression Matching</title>
      <link href="20180328.html"/>
      <url>20180328.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/leetcode">刷题仓库地址</a></li><li><a href="https://zdran.com/20180327.html">4. Median of Two Sorted Arrays</a></li><li><a href="https://zdran.com/20180328.html">10. Regular Expression Matching</a></li><li><a href="https://zdran.com/20180329.html">23. Merge k Sorted Lists</a></li><li><a href="https://zdran.com/20180330.html">25. Reverse Nodes in k-Group</a></li><li><a href="https://zdran.com/20180331.html">30. Substring with Concatenation of All Words</a></li><li><a href="https://zdran.com/20180401.html">32. Longest Valid Parentheses</a></li><li><a href="https://zdran.com/20190321.html">37. Sudoku Solver</a></li></ul><hr><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Implement regular expression matching with support for ‘.’ and ‘*’. </p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="$xslt">&#39;.&#39; Matches any single character.&#39;*&#39; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true</code></pre><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>实现正则表达式匹配，支持’.’和’*’</p><p>‘.’ 匹配任意一个字符。</p><p>‘*‘ 匹配0个或多个 ‘*‘ 前面的一个字符</p><h2 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h2><p>使用递归。整体思路是：如果当前字符匹配成功，最终结果是之后的字符是否匹配成功。</p><p>定义递归函数<code>recursion(String s,String p,int sIndex,int pIndex)</code></p><ol><li><p>结束条件: sIndex &gt;= s.length() || pIndex &gt;= p.length() </p><p> 需要注意的是: </p><p> 当s匹配结束后，还要判断模式串后面是否有 ‘a*b*‘等字符。<br> 当p匹配结束后，当且仅当s也匹配结束时返回true。</p></li><li><p>当 <code>p.charAt(pIndex+1) != &#39;*&#39;</code>时，</p><p> 即 当前匹配的不是 ‘*’</p><p> 当 <code>p.charAt(pIndex) == s.charAt(sIndex)|| p.charAt(pIndex) == &#39;.&#39;</code>时</p><p> 返回 recursion(s,p,sIndex+1,pIndex+1)</p><p> 如果条件不成立，则返回 false。</p></li><li><p>当 <code>p.charAt(pIndex+1) != &#39;*&#39;</code>时，</p><p> 即当前匹配的是 ‘*’</p><p> 使用贪心策略，如果当前位置的字符匹配，保持 pIndex不动，不断移动sIndex，每移动一次sIndex，</p><p> 就判断一次 recursion(s,p,sIndex,pIndex+2)。如果 ‘*’后面的所有字符都匹配，</p><p> 可以直接返回true。</p><p> 如果当前位置的字符不匹配，即 ‘*’ 已经匹配了足够多的字符（也有可能一个字符都没有匹配），</p><p> 说明 ‘*’ 匹配结束，返回 recursion(s,p,sIndex,pIndex+2)。</p></li></ol><ol start="4"><li><strong>注意递归结束条件，注意边界问题</strong></li></ol><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>注意测试数据:</p><pre><code>&quot;&quot;   &quot;a*&quot;&quot;ab&quot;  &quot;c*a*b*d*&quot;&quot;a&quot;  &quot;c*.a*&quot;&quot;abc&quot;  &quot;.*&quot;</code></pre><ol><li></li></ol><h2 id="Accept-Code"><a href="#Accept-Code" class="headerlink" title="Accept Code"></a>Accept Code</h2><pre><code>public class RegularExpressionMatching &#123;    public boolean isMatch(String s, String p) &#123;        return recursion(s, p, 0, 0);    &#125;    private boolean recursion(String s, String p, int sIndex, int pIndex) &#123;        if (pIndex &gt;= p.length()) &#123;            return sIndex &gt;= s.length();        &#125;        //解决 s = ab ，p = a*b*c*d        if (sIndex &gt;= s.length()) &#123;            if (pIndex + 1 &lt; p.length() &amp;&amp; p.charAt(pIndex + 1) == &#39;*&#39;) &#123;                return recursion(s, p, sIndex, pIndex + 2);            &#125; else &#123;                return false;            &#125;        &#125;        //解决 s = aa,p =  a        if (pIndex + 1 &gt;= p.length()) &#123;            if (p.charAt(pIndex) == s.charAt(sIndex) || p.charAt(pIndex) == &#39;.&#39;) &#123;                return sIndex + 1 == s.length();            &#125; else &#123;                return false;            &#125;        &#125;        if ((pIndex + 1 &lt; p.length()) &amp;&amp; p.charAt(pIndex + 1) != &#39;*&#39;) &#123;            if (s.charAt(sIndex) == p.charAt(pIndex) || (sIndex &lt; s.length() &amp;&amp; p.charAt(pIndex) == &#39;.&#39;)) &#123;                return recursion(s, p, sIndex + 1, pIndex + 1);            &#125; else &#123;                return false;            &#125;        &#125; else &#123;            while ((sIndex &lt; s.length() &amp;&amp; s.charAt(sIndex) == p.charAt(pIndex)) || (sIndex &lt; s.length() &amp;&amp; p.charAt(pIndex) == &#39;.&#39;)) &#123;                if (recursion(s, p, sIndex, pIndex + 2)) &#123;                    return true;                &#125;                sIndex++;            &#125;            return recursion(s, p, sIndex, pIndex + 2);        &#125;    &#125;    public boolean isMatch2(String s, String p) &#123;        boolean[] match = new boolean[s.length() + 1];        match[s.length()] = true;        for (int i = p.length() - 1; i &gt;= 0; i--) &#123;            if (p.charAt(i) == &#39;*&#39;) &#123;                // 如果是星号，从后往前匹配                for (int j = s.length() - 1; j &gt;= 0; j--) &#123;                    match[j] = match[j] || (match[j + 1] &amp;&amp; (p.charAt(i - 1) == &#39;.&#39; || (p.charAt(i - 1) == s.charAt(j))));                &#125;                // 记得把i多减一，因为星号是和其前面的字符配合使用的                i--;            &#125; else &#123;                // 如果不是星号，从前往后匹配                for (int j = 0; j &lt; s.length(); j++) &#123;                    match[j] = match[j + 1] &amp;&amp; (p.charAt(i) == &#39;.&#39; || (p.charAt(i) == s.charAt(j)));                &#125;                // 只要试过了pattern中最后一个字符，就要把match[s.length()]置为false                match[s.length()] = false;            &#125;        &#125;        return match[0];    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Median of Two Sorted Arrays</title>
      <link href="20180327.html"/>
      <url>20180327.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/zdRan/leetcode">刷题仓库地址</a></li><li><a href="https://zdran.com/20180327.html">4. Median of Two Sorted Arrays</a></li><li><a href="https://zdran.com/20180328.html">10. Regular Expression Matching</a></li><li><a href="https://zdran.com/20180329.html">23. Merge k Sorted Lists</a></li><li><a href="https://zdran.com/20180330.html">25. Reverse Nodes in k-Group</a></li><li><a href="https://zdran.com/20180331.html">30. Substring with Concatenation of All Words</a></li><li><a href="https://zdran.com/20180401.html">32. Longest Valid Parentheses</a></li><li><a href="https://zdran.com/20190321.html">37. Sudoku Solver</a></li></ul><hr><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="$xslt">Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5</code></pre><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>给定两个有序数组nums1和nums2大小分别为m和n。 </p><p>找到这两个数组的中位数。整体运行时间复杂度应为O（log（m + n））。</p><h2 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h2><p>归并排序，二路归并，归并到一半就出结果了。注意结果是小数。</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>注意测试数据:</p><pre><code>num1 = [],num2 = [1,2,3]num1 = [1,2,3],num2 = [1]num1 = [1],num2 = [1,2,3]</code></pre><h2 id="Accept-Code"><a href="#Accept-Code" class="headerlink" title="Accept Code"></a>Accept Code</h2><pre><code>public class MedianTwoArrays &#123;    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;        int T = nums1.length + nums2.length;        double result;        List&lt;Integer&gt; nums3 = new ArrayList&lt;&gt;(T);        int i1 = 0;        int i2 = 0;        int i3 = 0;        int num1;        int num2;        while (i3 &lt;= T / 2) &#123;            num1 = (i1 == nums1.length) ? Integer.MAX_VALUE : nums1[i1];            num2 = (i2 == nums2.length) ? Integer.MAX_VALUE : nums2[i2];            if (num1 &lt; num2) &#123;                nums3.add(num1);                i1++;            &#125; else &#123;                nums3.add(num2);                i2++;            &#125;            i3++;        &#125;        int temp;        if (T % 2 != 0) &#123;            temp = nums3.get(i3 - 1);            result = (temp + temp) / 2.0;        &#125; else &#123;            temp = nums3.get(i3 - 2) + nums3.get(i3 - 1);            result = temp / 2.0;        &#125;        return result;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Material + Github 搭建博客</title>
      <link href="20180326.html"/>
      <url>20180326.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-准备环境"><a href="#0-准备环境" class="headerlink" title="0. 准备环境"></a>0. 准备环境</h2><ul><li>git</li><li>Node.js</li><li>github 账号</li></ul><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-安装-git"><a href="#1-1-安装-git" class="headerlink" title="1.1 安装 git"></a>1.1 安装 git</h3><p><a href="https://git-scm.com/downloads">Git下载地址 </a></p><p>一路 next 没啥好说的</p><p>验证一下，在命令行下执行</p><pre><code>D:\GitRepository&gt;git --versiongit version 2.13.2.windows.1</code></pre><p>就说明成功了</p><h3 id="1-2-安装-Node-js"><a href="#1-2-安装-Node-js" class="headerlink" title="1.2 安装 Node.js"></a>1.2 安装 Node.js</h3><p><a href="https://nodejs.org/zh-cn/">Node.js下载地址</a></p><p>一路 next 没啥好说的</p><p>验证一下，在命令行下执行</p><pre><code>D:\GitRepository&gt;node -vv6.11.5D:\GitRepository&gt;npm -v3.10.10</code></pre><h3 id="1-3-安装-Hexo"><a href="#1-3-安装-Hexo" class="headerlink" title="1.3 安装 Hexo"></a>1.3 安装 Hexo</h3><pre><code>npm install -g hexo-cli </code></pre><h2 id="2-创建本地Blog"><a href="#2-创建本地Blog" class="headerlink" title="2. 创建本地Blog"></a>2. 创建本地Blog</h2><p>在命令行下进入一个空文件夹内，</p><p>执行</p><pre><code>hexo init</code></pre><p>本地blog就创建成功了</p><p>执行</p><pre><code>hexo ghexo s</code></pre><p>访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 就能看到自己的blog了。</p><h2 id="3-主题安装"><a href="#3-主题安装" class="headerlink" title="3. 主题安装"></a>3. 主题安装</h2><p>这里使用的是 <a href="https://github.com/viosey/hexo-theme-material">viosey</a> 主题</p><h3 id="3-1-下载主题："><a href="#3-1-下载主题：" class="headerlink" title="3.1 下载主题："></a>3.1 下载主题：</h3><pre><code>cd themesgit clone https://github.com/viosey/hexo-theme-material.git material</code></pre><h3 id="3-2-使用主题："><a href="#3-2-使用主题：" class="headerlink" title="3.2 使用主题："></a>3.2 使用主题：</h3><p>修改<strong><em>主目录</em></strong>下的 <code>_config.yml</code> 文件的 theme 值，改为 git 克隆下来的文件夹名称。</p><p>重命名 <strong><em>theme/material</em></strong> 目录下<code>_config.template.yml</code> 为 <code>_config.yml</code></p><h3 id="3-3-站内搜索"><a href="#3-3-站内搜索" class="headerlink" title="3.3 站内搜索"></a>3.3 站内搜索</h3><p>安装 <a href="https://github.com/PaicHyperionDev/hexo-generator-search">hexo-generator-search</a> 插件。</p><p>修改<strong><em>theme/material</em></strong> 目录 <code>_config.yml</code> 中的 search值</p><pre><code>search:    use: local    swiftype_key: </code></pre><p>然后在<strong><em>主目录</em></strong>的<code>_config.yml</code>文件中添加</p><pre><code>search:    path: search.xml    field: all</code></pre><p>其他相关配置可查看文档</p><h2 id="4-提交部署"><a href="#4-提交部署" class="headerlink" title="4. 提交部署"></a>4. 提交部署</h2><p>在github上创建 xxxx.github.io仓库,其中xxxx是你github的用户名</p><p>安装 hexo-deployer-git</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>配置<strong><em>主目录</em></strong>的<code>_config.yml</code>文件</p><pre><code>deploy:  type: git  repo: 仓库地址  branch: master</code></pre><p>部署到github</p><pre><code>hexo d -g</code></pre><p>访问下 <a href="https://xxxx.github.io/">https://xxxx.github.io/</a>。试试（xxxx是你自己的用户名）</p><h2 id="5-写blog"><a href="#5-写blog" class="headerlink" title="5. 写blog"></a>5. 写blog</h2><p>创建blog模板</p><pre><code>hexo new 这是我的第一篇文章</code></pre><p>会在 <code>source/_posts</code> 目录下创建一个md文件。可以编辑这个文件创作blog</p><h2 id="6-多台机器"><a href="#6-多台机器" class="headerlink" title="6. 多台机器"></a>6. 多台机器</h2><p>有时候需要在不同的地方写blog。这就需要在多台机器上同步 blog。</p><p>主要思路是创建两个分支，一个用于管理blog，一个用于管理原文件</p><p>在blog目录下</p><h3 id="6-1-创建源文件git目录"><a href="#6-1-创建源文件git目录" class="headerlink" title="6.1 创建源文件git目录"></a>6.1 创建源文件git目录</h3><pre><code> git init git remote add origin https://github.com/xx/xx.github.io // 填入你的repo地址</code></pre><h3 id="6-2-创建-source-分支"><a href="#6-2-创建-source-分支" class="headerlink" title="6.2 创建 source 分支"></a>6.2 创建 source 分支</h3><pre><code> git checkout -b source git add . git commit -m &#39;add source&#39; git push origin source</code></pre><h3 id="6-3-多机器同步"><a href="#6-3-多机器同步" class="headerlink" title="6.3 多机器同步"></a>6.3 多机器同步</h3><p>clone 仓库到本地</p><p>初始化 Hexo。跟上面的步骤一样，不再赘述。注意分支的切换</p><h2 id="7-分类-amp-标签"><a href="#7-分类-amp-标签" class="headerlink" title="7 分类 &amp;标签"></a>7 分类 &amp;标签</h2><h3 id="7-1-创建分类"><a href="#7-1-创建分类" class="headerlink" title="7.1 创建分类"></a>7.1 创建分类</h3><p>执行</p><pre><code> hexo new page categories</code></pre><p>打开 <code>source/categories/index.md</code></p><p>修改为：</p><pre><code>---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot;---</code></pre><h3 id="7-2-给文章添加分类"><a href="#7-2-给文章添加分类" class="headerlink" title="7.2 给文章添加分类"></a>7.2 给文章添加分类</h3><pre><code>---layout: hexotitle: Hexo + Material + Github 搭建博客与配置date: 2018-03-26 13:22:22categories: - 工具tags: 学习笔记---</code></pre><h2 id="8-SEO-优化部分（补充）"><a href="#8-SEO-优化部分（补充）" class="headerlink" title="8. SEO 优化部分（补充）"></a>8. SEO 优化部分（补充）</h2><p>由于博客接入了 Google 与百度搜索，所以做了一下 SEO 优化。</p><h3 id="8-1-站点地图"><a href="#8-1-站点地图" class="headerlink" title="8.1 站点地图"></a>8.1 站点地图</h3><p>安装插件：</p><pre><code>npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save</code></pre><p>修改博客的 <code>_config.yml</code> 配置文件，添加以下内容</p><pre><code>## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;# 替换成你自己的域名url: https://www.zdran.com ... ...Plugins:- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap:    path: baidusitemap.xmlsitemap:    path: sitemap.xml</code></pre><p>然后提交给百度和 Google，就会被定期检索到了</p><h3 id="8-2-百度提交URL"><a href="#8-2-百度提交URL" class="headerlink" title="8.2 百度提交URL"></a>8.2 百度提交URL</h3><p>提交百度的URL需要手动处理，可以使用 hexo-baidu-url-submit 工具来处理。</p><p>安装：</p><pre><code>npm install hexo-baidu-url-submit --save</code></pre><p>然后在 <code>_config.yml</code>  文件里添加以下配置：</p><pre><code>baidu_url_submit:  count: 1 ## 提交最新的一个链接  host: www.hui-wang.info ## 在百度站长平台中注册的域名  token: your_token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里deploy:- type: baidu_url_submitter ## 这是新加的</code></pre><p><a href="https://hui-wang.info/2016/10/23/Hexo%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%99%BE%E5%BA%A6%E4%B8%BB%E5%8A%A8%E6%8F%90%E4%BA%A4%E9%93%BE%E6%8E%A5/">原文地址</a></p><h3 id="8-3-robots-文件"><a href="#8-3-robots-文件" class="headerlink" title="8.3 robots 文件"></a>8.3 robots 文件</h3><p>在 <code>\source</code>中新建文件 robots.txt ,参考以下内容：</p><pre><code>User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://zdran.com/sitemap.xmlSitemap: https://zdran.com/baidusitemap.xml</code></pre><p><strong>请将域名换成你自己的域名！！！</strong></p><p>将 robots 文件提交给 google 和百度    </p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>timeline</title>
      <link href="timeline/index.html"/>
      <url>timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
